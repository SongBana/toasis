var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("@oasis-engine/miniprogram-adapter")) : typeof define === "function" && define.amd ? define(["exports", "@oasis-engine/miniprogram-adapter"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.oasis = {}, global.require$$0));
})(this, function(exports2, require$$0) {
  "use strict";
  const _interopDefaultLegacy = (e) => e && typeof e === "object" && "default" in e ? e : { default: e };
  const require$$0__default = /* @__PURE__ */ _interopDefaultLegacy(require$$0);
  var miniprogram$a = {};
  var miniprogram$9 = {};
  var miniprogram$8 = {};
  (function(exports3) {
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.ContainmentType = void 0;
    (function(ContainmentType) {
      ContainmentType[ContainmentType["Disjoint"] = 0] = "Disjoint";
      ContainmentType[ContainmentType["Contains"] = 1] = "Contains";
      ContainmentType[ContainmentType["Intersects"] = 2] = "Intersects";
    })(exports3.ContainmentType || (exports3.ContainmentType = {}));
    exports3.PlaneIntersectionType = void 0;
    (function(PlaneIntersectionType) {
      PlaneIntersectionType[PlaneIntersectionType["Back"] = 0] = "Back";
      PlaneIntersectionType[PlaneIntersectionType["Front"] = 1] = "Front";
      PlaneIntersectionType[PlaneIntersectionType["Intersecting"] = 2] = "Intersecting";
    })(exports3.PlaneIntersectionType || (exports3.PlaneIntersectionType = {}));
    function _defineProperties2(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties2(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var MathUtil = /* @__PURE__ */ function() {
      function MathUtil2() {
      }
      MathUtil2.clamp = function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      };
      MathUtil2.equals = function equals(a, b) {
        return Math.abs(a - b) <= MathUtil2.zeroTolerance;
      };
      MathUtil2.isPowerOf2 = function isPowerOf2(v) {
        return (v & v - 1) === 0;
      };
      MathUtil2.radianToDegree = function radianToDegree(r) {
        return r * MathUtil2.radToDegreeFactor;
      };
      MathUtil2.degreeToRadian = function degreeToRadian(d) {
        return d * MathUtil2.degreeToRadFactor;
      };
      return MathUtil2;
    }();
    MathUtil.zeroTolerance = 1e-6;
    MathUtil.radToDegreeFactor = 180 / Math.PI;
    MathUtil.degreeToRadFactor = Math.PI / 180;
    var Vector3 = /* @__PURE__ */ function() {
      Vector32.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._z = left._z + right._z;
        out._onValueChanged && out._onValueChanged();
      };
      Vector32.subtract = function subtract(left, right, out) {
        out._x = left._x - right._x;
        out._y = left._y - right._y;
        out._z = left._z - right._z;
        out._onValueChanged && out._onValueChanged();
      };
      Vector32.multiply = function multiply(left, right, out) {
        out._x = left._x * right._x;
        out._y = left._y * right._y;
        out._z = left._z * right._z;
        out._onValueChanged && out._onValueChanged();
      };
      Vector32.divide = function divide(left, right, out) {
        out._x = left._x / right._x;
        out._y = left._y / right._y;
        out._z = left._z / right._z;
        out._onValueChanged && out._onValueChanged();
      };
      Vector32.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z;
      };
      Vector32.cross = function cross(left, right, out) {
        var ax = left._x;
        var ay = left._y;
        var az = left._z;
        var bx = right._x;
        var by = right._y;
        var bz = right._z;
        out.set(ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx);
      };
      Vector32.distance = function distance(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        return Math.sqrt(x * x + y * y + z * z);
      };
      Vector32.distanceSquared = function distanceSquared(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        return x * x + y * y + z * z;
      };
      Vector32.equals = function equals(left, right) {
        return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y) && MathUtil.equals(left._z, right._z);
      };
      Vector32.lerp = function lerp(start2, end, t, out) {
        var _x = start2._x, _y = start2._y, _z = start2._z;
        out._x = _x + (end._x - _x) * t;
        out._y = _y + (end._y - _y) * t;
        out._z = _z + (end._z - _z) * t;
        out._onValueChanged && out._onValueChanged();
      };
      Vector32.max = function max(left, right, out) {
        out._x = Math.max(left._x, right._x);
        out._y = Math.max(left._y, right._y);
        out._z = Math.max(left._z, right._z);
        out._onValueChanged && out._onValueChanged();
      };
      Vector32.min = function min(left, right, out) {
        out._x = Math.min(left._x, right._x);
        out._y = Math.min(left._y, right._y);
        out._z = Math.min(left._z, right._z);
        out._onValueChanged && out._onValueChanged();
      };
      Vector32.negate = function negate(a, out) {
        out._x = -a._x;
        out._y = -a._y;
        out._z = -a._z;
        out._onValueChanged && out._onValueChanged();
      };
      Vector32.normalize = function normalize(a, out) {
        var _x = a._x, _y = a._y, _z = a._z;
        var len = Math.sqrt(_x * _x + _y * _y + _z * _z);
        if (len > MathUtil.zeroTolerance) {
          len = 1 / len;
          out.set(_x * len, _y * len, _z * len);
        }
      };
      Vector32.scale = function scale(a, s, out) {
        out._x = a._x * s;
        out._y = a._y * s;
        out._z = a._z * s;
        out._onValueChanged && out._onValueChanged();
      };
      Vector32.transformNormal = function transformNormal(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8];
        out._y = _x * e[1] + _y * e[5] + _z * e[9];
        out._z = _x * e[2] + _y * e[6] + _z * e[10];
        out._onValueChanged && out._onValueChanged();
      };
      Vector32.transformToVec3 = function transformToVec3(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8] + e[12];
        out._y = _x * e[1] + _y * e[5] + _z * e[9] + e[13];
        out._z = _x * e[2] + _y * e[6] + _z * e[10] + e[14];
        out._onValueChanged && out._onValueChanged();
      };
      Vector32.transformToVec4 = function transformToVec4(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8] + e[12];
        out._y = _x * e[1] + _y * e[5] + _z * e[9] + e[13];
        out._z = _x * e[2] + _y * e[6] + _z * e[10] + e[14];
        out._w = _x * e[3] + _y * e[7] + _z * e[11] + e[15];
        out._onValueChanged && out._onValueChanged();
      };
      Vector32.transformCoordinate = function transformCoordinate(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        var w = _x * e[3] + _y * e[7] + _z * e[11] + e[15];
        w = 1 / w;
        out._x = (_x * e[0] + _y * e[4] + _z * e[8] + e[12]) * w;
        out._y = (_x * e[1] + _y * e[5] + _z * e[9] + e[13]) * w;
        out._z = (_x * e[2] + _y * e[6] + _z * e[10] + e[14]) * w;
        out._onValueChanged && out._onValueChanged();
      };
      Vector32.transformByQuat = function transformByQuat(v, quaternion, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var qx = quaternion._x, qy = quaternion._y, qz = quaternion._z, qw = quaternion._w;
        var ix = qw * _x + qy * _z - qz * _y;
        var iy = qw * _y + qz * _x - qx * _z;
        var iz = qw * _z + qx * _y - qy * _x;
        var iw = -qx * _x - qy * _y - qz * _z;
        out._x = ix * qw - iw * qx - iy * qz + iz * qy;
        out._y = iy * qw - iw * qy - iz * qx + ix * qz;
        out._z = iz * qw - iw * qz - ix * qy + iy * qx;
        out._onValueChanged && out._onValueChanged();
      };
      function Vector32(x, y, z) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        this._x = void 0;
        this._y = void 0;
        this._z = void 0;
        this._onValueChanged = null;
        this._x = x;
        this._y = y;
        this._z = z;
      }
      var _proto = Vector32.prototype;
      _proto.set = function set(x, y, z) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.add = function add(right) {
        this._x += right._x;
        this._y += right._y;
        this._z += right._z;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.subtract = function subtract(right) {
        this._x -= right._x;
        this._y -= right._y;
        this._z -= right._z;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.multiply = function multiply(right) {
        this._x *= right._x;
        this._y *= right._y;
        this._z *= right._z;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.divide = function divide(right) {
        this._x /= right._x;
        this._y /= right._y;
        this._z /= right._z;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.length = function length2() {
        var _x = this._x, _y = this._y, _z = this._z;
        return Math.sqrt(_x * _x + _y * _y + _z * _z);
      };
      _proto.lengthSquared = function lengthSquared() {
        var _x = this._x, _y = this._y, _z = this._z;
        return _x * _x + _y * _y + _z * _z;
      };
      _proto.negate = function negate() {
        this._x = -this._x;
        this._y = -this._y;
        this._z = -this._z;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.normalize = function normalize() {
        Vector32.normalize(this, this);
        return this;
      };
      _proto.scale = function scale(s) {
        this._x *= s;
        this._y *= s;
        this._z *= s;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.transformNormal = function transformNormal(m) {
        Vector32.transformNormal(this, m, this);
        return this;
      };
      _proto.transformToVec3 = function transformToVec3(m) {
        Vector32.transformToVec3(this, m, this);
        return this;
      };
      _proto.transformCoordinate = function transformCoordinate(m) {
        Vector32.transformCoordinate(this, m, this);
        return this;
      };
      _proto.transformByQuat = function transformByQuat(quaternion) {
        Vector32.transformByQuat(this, quaternion, this);
        return this;
      };
      _proto.clone = function clone() {
        return new Vector32(this._x, this._y, this._z);
      };
      _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._z = source.z;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) {
          outOffset = 0;
        }
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
        out[outOffset + 2] = this._z;
      };
      _createClass2(Vector32, [{
        key: "x",
        get: function get() {
          return this._x;
        },
        set: function set(value) {
          this._x = value;
          this._onValueChanged && this._onValueChanged();
        }
      }, {
        key: "y",
        get: function get() {
          return this._y;
        },
        set: function set(value) {
          this._y = value;
          this._onValueChanged && this._onValueChanged();
        }
      }, {
        key: "z",
        get: function get() {
          return this._z;
        },
        set: function set(value) {
          this._z = value;
          this._onValueChanged && this._onValueChanged();
        }
      }]);
      return Vector32;
    }();
    Vector3._zero = new Vector3(0, 0, 0);
    Vector3._one = new Vector3(1, 1, 1);
    var BoundingSphere = /* @__PURE__ */ function() {
      BoundingSphere2.fromPoints = function fromPoints(points, out) {
        if (!points || points.length === 0) {
          throw new Error("points must be array and length must > 0");
        }
        var len = points.length;
        var center = BoundingSphere2._tempVec30;
        center.x = center.y = center.z = 0;
        for (var i = 0; i < len; ++i) {
          Vector3.add(points[i], center, center);
        }
        Vector3.scale(center, 1 / len, out.center);
        var radius = 0;
        for (var _i = 0; _i < len; ++_i) {
          var distance = Vector3.distanceSquared(center, points[_i]);
          distance > radius && (radius = distance);
        }
        out.radius = Math.sqrt(radius);
      };
      BoundingSphere2.fromBox = function fromBox(box, out) {
        var center = out.center;
        var min = box.min, max = box.max;
        center.x = (min.x + max.x) * 0.5;
        center.y = (min.y + max.y) * 0.5;
        center.z = (min.z + max.z) * 0.5;
        out.radius = Vector3.distance(center, max);
      };
      function BoundingSphere2(center, radius) {
        if (center === void 0) {
          center = null;
        }
        if (radius === void 0) {
          radius = 0;
        }
        this.center = new Vector3();
        this.radius = 0;
        center && this.center.copyFrom(center);
        this.radius = radius;
      }
      var _proto = BoundingSphere2.prototype;
      _proto.clone = function clone() {
        return new BoundingSphere2(this.center, this.radius);
      };
      _proto.copyFrom = function copyFrom(source) {
        this.center.copyFrom(source.center);
        this.radius = source.radius;
        return this;
      };
      return BoundingSphere2;
    }();
    BoundingSphere._tempVec30 = new Vector3();
    var BoundingBox = /* @__PURE__ */ function() {
      BoundingBox2.fromCenterAndExtent = function fromCenterAndExtent(center, extent, out) {
        Vector3.subtract(center, extent, out.min);
        Vector3.add(center, extent, out.max);
      };
      BoundingBox2.fromPoints = function fromPoints(points, out) {
        if (!points || points.length === 0) {
          throw new Error("points must be array and length must > 0");
        }
        var min = out.min, max = out.max;
        min.x = min.y = min.z = Number.MAX_VALUE;
        max.x = max.y = max.z = -Number.MAX_VALUE;
        for (var i = 0, l = points.length; i < l; ++i) {
          var point = points[i];
          Vector3.min(min, point, min);
          Vector3.max(max, point, max);
        }
      };
      BoundingBox2.fromSphere = function fromSphere(sphere, out) {
        var center = sphere.center, radius = sphere.radius;
        var min = out.min, max = out.max;
        min.x = center.x - radius;
        min.y = center.y - radius;
        min.z = center.z - radius;
        max.x = center.x + radius;
        max.y = center.y + radius;
        max.z = center.z + radius;
      };
      BoundingBox2.transform = function transform(source, matrix, out) {
        var center = BoundingBox2._tempVec30;
        var extent = BoundingBox2._tempVec31;
        source.getCenter(center);
        source.getExtent(extent);
        Vector3.transformCoordinate(center, matrix, center);
        var x = extent.x, y = extent.y, z = extent.z;
        var e = matrix.elements;
        extent.x = Math.abs(x * e[0]) + Math.abs(y * e[4]) + Math.abs(z * e[8]);
        extent.y = Math.abs(x * e[1]) + Math.abs(y * e[5]) + Math.abs(z * e[9]);
        extent.z = Math.abs(x * e[2]) + Math.abs(y * e[6]) + Math.abs(z * e[10]);
        Vector3.subtract(center, extent, out.min);
        Vector3.add(center, extent, out.max);
      };
      BoundingBox2.merge = function merge(box1, box2, out) {
        Vector3.min(box1.min, box2.min, out.min);
        Vector3.max(box1.max, box2.max, out.max);
        return out;
      };
      function BoundingBox2(min, max) {
        if (min === void 0) {
          min = null;
        }
        if (max === void 0) {
          max = null;
        }
        this.min = new Vector3();
        this.max = new Vector3();
        min && this.min.copyFrom(min);
        max && this.max.copyFrom(max);
      }
      var _proto = BoundingBox2.prototype;
      _proto.getCenter = function getCenter(out) {
        Vector3.add(this.min, this.max, out);
        Vector3.scale(out, 0.5, out);
        return out;
      };
      _proto.getExtent = function getExtent(out) {
        Vector3.subtract(this.max, this.min, out);
        Vector3.scale(out, 0.5, out);
        return out;
      };
      _proto.getCorners = function getCorners(out) {
        if (out === void 0) {
          out = [];
        }
        var min = this.min, max = this.max;
        var minX = min.x;
        var minY = min.y;
        var minZ = min.z;
        var maxX = max.x;
        var maxY = max.y;
        var maxZ = max.z;
        var len = out.length;
        if (len < 8) {
          for (var i = 0, l = 8 - len; i < l; ++i) {
            out[len + i] = new Vector3();
          }
        }
        out[0].set(minX, maxY, maxZ);
        out[1].set(maxX, maxY, maxZ);
        out[2].set(maxX, minY, maxZ);
        out[3].set(minX, minY, maxZ);
        out[4].set(minX, maxY, minZ);
        out[5].set(maxX, maxY, minZ);
        out[6].set(maxX, minY, minZ);
        out[7].set(minX, minY, minZ);
        return out;
      };
      _proto.transform = function transform(matrix) {
        BoundingBox2.transform(this, matrix, this);
        return this;
      };
      _proto.clone = function clone() {
        return new BoundingBox2(this.min, this.max);
      };
      _proto.copyFrom = function copyFrom(source) {
        this.min.copyFrom(source.min);
        this.max.copyFrom(source.max);
        return this;
      };
      return BoundingBox2;
    }();
    BoundingBox._tempVec30 = new Vector3();
    BoundingBox._tempVec31 = new Vector3();
    var CollisionUtil = /* @__PURE__ */ function() {
      function CollisionUtil2() {
      }
      CollisionUtil2.distancePlaneAndPoint = function distancePlaneAndPoint(plane, point) {
        return Vector3.dot(plane.normal, point) + plane.distance;
      };
      CollisionUtil2.intersectsPlaneAndPoint = function intersectsPlaneAndPoint(plane, point) {
        var distance = CollisionUtil2.distancePlaneAndPoint(plane, point);
        if (distance > 0) {
          return exports3.PlaneIntersectionType.Front;
        }
        if (distance < 0) {
          return exports3.PlaneIntersectionType.Back;
        }
        return exports3.PlaneIntersectionType.Intersecting;
      };
      CollisionUtil2.intersectsPlaneAndBox = function intersectsPlaneAndBox(plane, box) {
        var min = box.min, max = box.max;
        var normal = plane.normal;
        var front = CollisionUtil2._tempVec30;
        var back = CollisionUtil2._tempVec31;
        if (normal.x >= 0) {
          front.x = max.x;
          back.x = min.x;
        } else {
          front.x = min.x;
          back.x = max.x;
        }
        if (normal.y >= 0) {
          front.y = max.y;
          back.y = min.y;
        } else {
          front.y = min.y;
          back.y = max.y;
        }
        if (normal.z >= 0) {
          front.z = max.z;
          back.z = min.z;
        } else {
          front.z = min.z;
          back.z = max.z;
        }
        if (CollisionUtil2.distancePlaneAndPoint(plane, front) < 0) {
          return exports3.PlaneIntersectionType.Back;
        }
        if (CollisionUtil2.distancePlaneAndPoint(plane, back) > 0) {
          return exports3.PlaneIntersectionType.Front;
        }
        return exports3.PlaneIntersectionType.Intersecting;
      };
      CollisionUtil2.intersectsPlaneAndSphere = function intersectsPlaneAndSphere(plane, sphere) {
        var center = sphere.center, radius = sphere.radius;
        var distance = CollisionUtil2.distancePlaneAndPoint(plane, center);
        if (distance > radius) {
          return exports3.PlaneIntersectionType.Front;
        }
        if (distance < -radius) {
          return exports3.PlaneIntersectionType.Back;
        }
        return exports3.PlaneIntersectionType.Intersecting;
      };
      CollisionUtil2.intersectsRayAndPlane = function intersectsRayAndPlane(ray, plane) {
        var normal = plane.normal;
        var zeroTolerance = MathUtil.zeroTolerance;
        var dir = Vector3.dot(normal, ray.direction);
        if (Math.abs(dir) < zeroTolerance) {
          return -1;
        }
        var position = Vector3.dot(normal, ray.origin);
        var distance = (-plane.distance - position) / dir;
        if (distance < 0) {
          if (distance < -zeroTolerance) {
            return -1;
          }
          distance = 0;
        }
        return distance;
      };
      CollisionUtil2.intersectsRayAndBox = function intersectsRayAndBox(ray, box) {
        var zeroTolerance = MathUtil.zeroTolerance;
        var origin = ray.origin, direction = ray.direction;
        var min = box.min, max = box.max;
        var dirX = direction.x;
        var dirY = direction.y;
        var dirZ = direction.z;
        var oriX = origin.x;
        var oriY = origin.y;
        var oriZ = origin.z;
        var distance = 0;
        var tmax = Number.MAX_VALUE;
        if (Math.abs(dirX) < zeroTolerance) {
          if (oriX < min.x || oriX > max.x) {
            return -1;
          }
        } else {
          var inverse = 1 / dirX;
          var t1 = (min.x - oriX) * inverse;
          var t2 = (max.x - oriX) * inverse;
          if (t1 > t2) {
            var temp = t1;
            t1 = t2;
            t2 = temp;
          }
          distance = Math.max(t1, distance);
          tmax = Math.min(t2, tmax);
          if (distance > tmax) {
            return -1;
          }
        }
        if (Math.abs(dirY) < zeroTolerance) {
          if (oriY < min.y || oriY > max.y) {
            return -1;
          }
        } else {
          var _inverse = 1 / dirY;
          var _t = (min.y - oriY) * _inverse;
          var _t2 = (max.y - oriY) * _inverse;
          if (_t > _t2) {
            var _temp = _t;
            _t = _t2;
            _t2 = _temp;
          }
          distance = Math.max(_t, distance);
          tmax = Math.min(_t2, tmax);
          if (distance > tmax) {
            return -1;
          }
        }
        if (Math.abs(dirZ) < zeroTolerance) {
          if (oriZ < min.z || oriZ > max.z) {
            return -1;
          }
        } else {
          var _inverse2 = 1 / dirZ;
          var _t3 = (min.z - oriZ) * _inverse2;
          var _t4 = (max.z - oriZ) * _inverse2;
          if (_t3 > _t4) {
            var _temp2 = _t3;
            _t3 = _t4;
            _t4 = _temp2;
          }
          distance = Math.max(_t3, distance);
          tmax = Math.min(_t4, tmax);
          if (distance > tmax) {
            return -1;
          }
        }
        return distance;
      };
      CollisionUtil2.intersectsRayAndSphere = function intersectsRayAndSphere(ray, sphere) {
        var origin = ray.origin, direction = ray.direction;
        var center = sphere.center, radius = sphere.radius;
        var m = CollisionUtil2._tempVec30;
        Vector3.subtract(origin, center, m);
        var b = Vector3.dot(m, direction);
        var c = Vector3.dot(m, m) - radius * radius;
        if (b > 0 && c > 0) {
          return -1;
        }
        var discriminant = b * b - c;
        if (discriminant < 0) {
          return -1;
        }
        var distance = -b - Math.sqrt(discriminant);
        if (distance < 0) {
          distance = 0;
        }
        return distance;
      };
      CollisionUtil2.intersectsBoxAndBox = function intersectsBoxAndBox(boxA, boxB) {
        if (boxA.min.x > boxB.max.x || boxB.min.x > boxA.max.x) {
          return false;
        }
        if (boxA.min.y > boxB.max.y || boxB.min.y > boxA.max.y) {
          return false;
        }
        return !(boxA.min.z > boxB.max.z || boxB.min.z > boxA.max.z);
      };
      CollisionUtil2.intersectsSphereAndSphere = function intersectsSphereAndSphere(sphereA, sphereB) {
        var radiisum = sphereA.radius + sphereB.radius;
        return Vector3.distanceSquared(sphereA.center, sphereB.center) < radiisum * radiisum;
      };
      CollisionUtil2.intersectsSphereAndBox = function intersectsSphereAndBox(sphere, box) {
        var center = sphere.center;
        var max = box.max;
        var min = box.min;
        var closestPoint = CollisionUtil2._tempVec30;
        closestPoint.set(Math.max(min.x, Math.min(center.x, max.x)), Math.max(min.y, Math.min(center.y, max.y)), Math.max(min.z, Math.min(center.z, max.z)));
        var distance = Vector3.distanceSquared(center, closestPoint);
        return distance <= sphere.radius * sphere.radius;
      };
      CollisionUtil2.intersectsFrustumAndBox = function intersectsFrustumAndBox(frustum, box) {
        var min = box.min, max = box.max;
        var back = CollisionUtil2._tempVec30;
        for (var i = 0; i < 6; ++i) {
          var plane = frustum.getPlane(i);
          var normal = plane.normal;
          back.set(normal.x >= 0 ? min.x : max.x, normal.y >= 0 ? min.y : max.y, normal.z >= 0 ? min.z : max.z);
          if (Vector3.dot(normal, back) > -plane.distance) {
            return false;
          }
        }
        return true;
      };
      CollisionUtil2.frustumContainsBox = function frustumContainsBox(frustum, box) {
        var min = box.min, max = box.max;
        var front = CollisionUtil2._tempVec30;
        var back = CollisionUtil2._tempVec31;
        var result = exports3.ContainmentType.Contains;
        for (var i = 0; i < 6; ++i) {
          var plane = frustum.getPlane(i);
          var normal = plane.normal;
          if (normal.x >= 0) {
            front.x = max.x;
            back.x = min.x;
          } else {
            front.x = min.x;
            back.x = max.x;
          }
          if (normal.y >= 0) {
            front.y = max.y;
            back.y = min.y;
          } else {
            front.y = min.y;
            back.y = max.y;
          }
          if (normal.z >= 0) {
            front.z = max.z;
            back.z = min.z;
          } else {
            front.z = min.z;
            back.z = max.z;
          }
          if (CollisionUtil2.intersectsPlaneAndPoint(plane, back) === exports3.PlaneIntersectionType.Front) {
            return exports3.ContainmentType.Disjoint;
          }
          if (CollisionUtil2.intersectsPlaneAndPoint(plane, front) === exports3.PlaneIntersectionType.Front) {
            result = exports3.ContainmentType.Intersects;
          }
        }
        return result;
      };
      CollisionUtil2.frustumContainsSphere = function frustumContainsSphere(frustum, sphere) {
        var result = exports3.ContainmentType.Contains;
        for (var i = 0; i < 6; ++i) {
          var plane = frustum.getPlane(i);
          var intersectionType = CollisionUtil2.intersectsPlaneAndSphere(plane, sphere);
          if (intersectionType === exports3.PlaneIntersectionType.Front) {
            return exports3.ContainmentType.Disjoint;
          } else if (intersectionType === exports3.PlaneIntersectionType.Intersecting) {
            result = exports3.ContainmentType.Intersects;
            break;
          }
        }
        return result;
      };
      return CollisionUtil2;
    }();
    CollisionUtil._tempVec30 = new Vector3();
    CollisionUtil._tempVec31 = new Vector3();
    var Plane = /* @__PURE__ */ function() {
      Plane2.normalize = function normalize(p, out) {
        var normal = p.normal;
        var factor = 1 / normal.length();
        Vector3.scale(normal, factor, out.normal);
        out.distance = p.distance * factor;
      };
      Plane2.fromPoints = function fromPoints(point0, point1, point2, out) {
        var x0 = point0.x;
        var y0 = point0.y;
        var z0 = point0.z;
        var x1 = point1.x - x0;
        var y1 = point1.y - y0;
        var z1 = point1.z - z0;
        var x2 = point2.x - x0;
        var y2 = point2.y - y0;
        var z2 = point2.z - z0;
        var yz = y1 * z2 - z1 * y2;
        var xz = z1 * x2 - x1 * z2;
        var xy = x1 * y2 - y1 * x2;
        var invPyth = 1 / Math.sqrt(yz * yz + xz * xz + xy * xy);
        var x = yz * invPyth;
        var y = xz * invPyth;
        var z = xy * invPyth;
        var normal = out.normal;
        normal.x = x;
        normal.y = y;
        normal.z = z;
        out.distance = -(x * x0 + y * y0 + z * z0);
      };
      function Plane2(normal, distance) {
        if (normal === void 0) {
          normal = null;
        }
        if (distance === void 0) {
          distance = 0;
        }
        this.normal = new Vector3();
        this.distance = 0;
        normal && this.normal.copyFrom(normal);
        this.distance = distance;
      }
      var _proto = Plane2.prototype;
      _proto.normalize = function normalize() {
        Plane2.normalize(this, this);
        return this;
      };
      _proto.clone = function clone() {
        var out = new Plane2();
        out.copyFrom(this);
        return out;
      };
      _proto.copyFrom = function copyFrom(source) {
        this.normal.copyFrom(source.normal);
        this.distance = source.distance;
        return this;
      };
      return Plane2;
    }();
    var BoundingFrustum = /* @__PURE__ */ function() {
      function BoundingFrustum2(matrix) {
        if (matrix === void 0) {
          matrix = null;
        }
        this.near = void 0;
        this.far = void 0;
        this.left = void 0;
        this.right = void 0;
        this.top = void 0;
        this.bottom = void 0;
        this.near = new Plane();
        this.far = new Plane();
        this.left = new Plane();
        this.right = new Plane();
        this.top = new Plane();
        this.bottom = new Plane();
        matrix && this.calculateFromMatrix(matrix);
      }
      var _proto = BoundingFrustum2.prototype;
      _proto.getPlane = function getPlane(index) {
        switch (index) {
          case 0:
            return this.near;
          case 1:
            return this.far;
          case 2:
            return this.left;
          case 3:
            return this.right;
          case 4:
            return this.top;
          case 5:
            return this.bottom;
          default:
            return null;
        }
      };
      _proto.calculateFromMatrix = function calculateFromMatrix(matrix) {
        var me = matrix.elements;
        var m11 = me[0];
        var m12 = me[1];
        var m13 = me[2];
        var m14 = me[3];
        var m21 = me[4];
        var m22 = me[5];
        var m23 = me[6];
        var m24 = me[7];
        var m31 = me[8];
        var m32 = me[9];
        var m33 = me[10];
        var m34 = me[11];
        var m41 = me[12];
        var m42 = me[13];
        var m43 = me[14];
        var m44 = me[15];
        var nearNormal = this.near.normal;
        nearNormal.set(-m14 - m13, -m24 - m23, -m34 - m33);
        this.near.distance = -m44 - m43;
        this.near.normalize();
        var farNormal = this.far.normal;
        farNormal.set(m13 - m14, m23 - m24, m33 - m34);
        this.far.distance = m43 - m44;
        this.far.normalize();
        var leftNormal = this.left.normal;
        leftNormal.set(-m14 - m11, -m24 - m21, -m34 - m31);
        this.left.distance = -m44 - m41;
        this.left.normalize();
        var rightNormal = this.right.normal;
        rightNormal.set(m11 - m14, m21 - m24, m31 - m34);
        this.right.distance = m41 - m44;
        this.right.normalize();
        var topNormal = this.top.normal;
        topNormal.set(m12 - m14, m22 - m24, m32 - m34);
        this.top.distance = m42 - m44;
        this.top.normalize();
        var bottomNormal = this.bottom.normal;
        bottomNormal.set(-m14 - m12, -m24 - m22, -m34 - m32);
        this.bottom.distance = -m44 - m42;
        this.bottom.normalize();
      };
      _proto.intersectsBox = function intersectsBox(box) {
        return CollisionUtil.intersectsFrustumAndBox(this, box);
      };
      _proto.intersectsSphere = function intersectsSphere(sphere) {
        return CollisionUtil.frustumContainsSphere(this, sphere) !== exports3.ContainmentType.Disjoint;
      };
      _proto.clone = function clone() {
        var out = new BoundingFrustum2();
        out.copyFrom(this);
        return out;
      };
      _proto.copyFrom = function copyFrom(source) {
        this.near.copyFrom(source.near);
        this.far.copyFrom(source.far);
        this.left.copyFrom(source.left);
        this.right.copyFrom(source.right);
        this.top.copyFrom(source.top);
        this.bottom.copyFrom(source.bottom);
        return this;
      };
      return BoundingFrustum2;
    }();
    var Matrix3x3 = /* @__PURE__ */ function() {
      Matrix3x32.add = function add(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        oe[0] = le[0] + re[0];
        oe[1] = le[1] + re[1];
        oe[2] = le[2] + re[2];
        oe[3] = le[3] + re[3];
        oe[4] = le[4] + re[4];
        oe[5] = le[5] + re[5];
        oe[6] = le[6] + re[6];
        oe[7] = le[7] + re[7];
        oe[8] = le[8] + re[8];
      };
      Matrix3x32.subtract = function subtract(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        oe[0] = le[0] - re[0];
        oe[1] = le[1] - re[1];
        oe[2] = le[2] - re[2];
        oe[3] = le[3] - re[3];
        oe[4] = le[4] - re[4];
        oe[5] = le[5] - re[5];
        oe[6] = le[6] - re[6];
        oe[7] = le[7] - re[7];
        oe[8] = le[8] - re[8];
      };
      Matrix3x32.multiply = function multiply(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        var l11 = le[0], l12 = le[1], l13 = le[2];
        var l21 = le[3], l22 = le[4], l23 = le[5];
        var l31 = le[6], l32 = le[7], l33 = le[8];
        var r11 = re[0], r12 = re[1], r13 = re[2];
        var r21 = re[3], r22 = re[4], r23 = re[5];
        var r31 = re[6], r32 = re[7], r33 = re[8];
        oe[0] = l11 * r11 + l21 * r12 + l31 * r13;
        oe[1] = l12 * r11 + l22 * r12 + l32 * r13;
        oe[2] = l13 * r11 + l23 * r12 + l33 * r13;
        oe[3] = l11 * r21 + l21 * r22 + l31 * r23;
        oe[4] = l12 * r21 + l22 * r22 + l32 * r23;
        oe[5] = l13 * r21 + l23 * r22 + l33 * r23;
        oe[6] = l11 * r31 + l21 * r32 + l31 * r33;
        oe[7] = l12 * r31 + l22 * r32 + l32 * r33;
        oe[8] = l13 * r31 + l23 * r32 + l33 * r33;
      };
      Matrix3x32.equals = function equals(left, right) {
        var le = left.elements;
        var re = right.elements;
        return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]);
      };
      Matrix3x32.lerp = function lerp(start2, end, t, out) {
        var se = start2.elements;
        var ee = end.elements;
        var oe = out.elements;
        var inv = 1 - t;
        oe[0] = se[0] * inv + ee[0] * t;
        oe[1] = se[1] * inv + ee[1] * t;
        oe[2] = se[2] * inv + ee[2] * t;
        oe[3] = se[3] * inv + ee[3] * t;
        oe[4] = se[4] * inv + ee[4] * t;
        oe[5] = se[5] * inv + ee[5] * t;
        oe[6] = se[6] * inv + ee[6] * t;
        oe[7] = se[7] * inv + ee[7] * t;
        oe[8] = se[8] * inv + ee[8] * t;
      };
      Matrix3x32.rotationQuaternion = function rotationQuaternion(quaternion, out) {
        var oe = out.elements;
        var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        oe[0] = 1 - yy - zz;
        oe[3] = yx - wz;
        oe[6] = zx + wy;
        oe[1] = yx + wz;
        oe[4] = 1 - xx - zz;
        oe[7] = zy - wx;
        oe[2] = zx - wy;
        oe[5] = zy + wx;
        oe[8] = 1 - xx - yy;
      };
      Matrix3x32.scaling = function scaling(s, out) {
        var oe = out.elements;
        oe[0] = s._x;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = s._y;
        oe[5] = 0;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 1;
      };
      Matrix3x32.translation = function translation(_translation, out) {
        var oe = out.elements;
        oe[0] = 1;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 1;
        oe[5] = 0;
        oe[6] = _translation._x;
        oe[7] = _translation._y;
        oe[8] = 1;
      };
      Matrix3x32.invert = function invert(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2];
        var a21 = ae[3], a22 = ae[4], a23 = ae[5];
        var a31 = ae[6], a32 = ae[7], a33 = ae[8];
        var b12 = a33 * a22 - a23 * a32;
        var b22 = -a33 * a21 + a23 * a31;
        var b32 = a32 * a21 - a22 * a31;
        var det = a11 * b12 + a12 * b22 + a13 * b32;
        if (!det) {
          return;
        }
        det = 1 / det;
        oe[0] = b12 * det;
        oe[1] = (-a33 * a12 + a13 * a32) * det;
        oe[2] = (a23 * a12 - a13 * a22) * det;
        oe[3] = b22 * det;
        oe[4] = (a33 * a11 - a13 * a31) * det;
        oe[5] = (-a23 * a11 + a13 * a21) * det;
        oe[6] = b32 * det;
        oe[7] = (-a32 * a11 + a12 * a31) * det;
        oe[8] = (a22 * a11 - a12 * a21) * det;
      };
      Matrix3x32.normalMatrix = function normalMatrix(mat4, out) {
        var ae = mat4.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];
        var a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];
        var a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];
        var a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];
        var b00 = a11 * a22 - a12 * a21;
        var b01 = a11 * a23 - a13 * a21;
        var b02 = a11 * a24 - a14 * a21;
        var b03 = a12 * a23 - a13 * a22;
        var b04 = a12 * a24 - a14 * a22;
        var b05 = a13 * a24 - a14 * a23;
        var b06 = a31 * a42 - a32 * a41;
        var b07 = a31 * a43 - a33 * a41;
        var b08 = a31 * a44 - a34 * a41;
        var b09 = a32 * a43 - a33 * a42;
        var b10 = a32 * a44 - a34 * a42;
        var b11 = a33 * a44 - a34 * a43;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) {
          return null;
        }
        det = 1 / det;
        oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
        oe[1] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
        oe[2] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
        oe[3] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
        oe[4] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
        oe[5] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
        oe[6] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
        oe[7] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
        oe[8] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
      };
      Matrix3x32.rotate = function rotate(a, r, out) {
        var ae = a.elements;
        var oe = out.elements;
        var s = Math.sin(r);
        var c = Math.cos(r);
        var a11 = ae[0], a12 = ae[1], a13 = ae[2];
        var a21 = ae[3], a22 = ae[4], a23 = ae[5];
        var a31 = ae[6], a32 = ae[7], a33 = ae[8];
        oe[0] = c * a11 + s * a21;
        oe[1] = c * a12 + s * a22;
        oe[2] = c * a13 + s * a23;
        oe[3] = c * a21 - s * a11;
        oe[4] = c * a22 - s * a12;
        oe[5] = c * a23 - s * a13;
        oe[6] = a31;
        oe[7] = a32;
        oe[8] = a33;
      };
      Matrix3x32.scale = function scale(m, s, out) {
        var x = s._x, y = s._y;
        var ae = m.elements;
        var oe = out.elements;
        oe[0] = x * ae[0];
        oe[1] = x * ae[1];
        oe[2] = x * ae[2];
        oe[3] = y * ae[3];
        oe[4] = y * ae[4];
        oe[5] = y * ae[5];
        oe[6] = ae[6];
        oe[7] = ae[7];
        oe[8] = ae[8];
      };
      Matrix3x32.translate = function translate(m, translation, out) {
        var x = translation._x, y = translation._y;
        var ae = m.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2];
        var a21 = ae[3], a22 = ae[4], a23 = ae[5];
        var a31 = ae[6], a32 = ae[7], a33 = ae[8];
        oe[0] = a11;
        oe[1] = a12;
        oe[2] = a13;
        oe[3] = a21;
        oe[4] = a22;
        oe[5] = a23;
        oe[6] = x * a11 + y * a21 + a31;
        oe[7] = x * a12 + y * a22 + a32;
        oe[8] = x * a13 + y * a23 + a33;
      };
      Matrix3x32.transpose = function transpose(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        if (out === a) {
          var a12 = ae[1];
          var a13 = ae[2];
          var a23 = ae[5];
          oe[1] = ae[3];
          oe[2] = ae[6];
          oe[3] = a12;
          oe[5] = ae[7];
          oe[6] = a13;
          oe[7] = a23;
        } else {
          oe[0] = ae[0];
          oe[1] = ae[3];
          oe[2] = ae[6];
          oe[3] = ae[1];
          oe[4] = ae[4];
          oe[5] = ae[7];
          oe[6] = ae[2];
          oe[7] = ae[5];
          oe[8] = ae[8];
        }
      };
      function Matrix3x32(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        if (m11 === void 0) {
          m11 = 1;
        }
        if (m12 === void 0) {
          m12 = 0;
        }
        if (m13 === void 0) {
          m13 = 0;
        }
        if (m21 === void 0) {
          m21 = 0;
        }
        if (m22 === void 0) {
          m22 = 1;
        }
        if (m23 === void 0) {
          m23 = 0;
        }
        if (m31 === void 0) {
          m31 = 0;
        }
        if (m32 === void 0) {
          m32 = 0;
        }
        if (m33 === void 0) {
          m33 = 1;
        }
        this.elements = new Float32Array(9);
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m21;
        e[4] = m22;
        e[5] = m23;
        e[6] = m31;
        e[7] = m32;
        e[8] = m33;
      }
      var _proto = Matrix3x32.prototype;
      _proto.set = function set(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m21;
        e[4] = m22;
        e[5] = m23;
        e[6] = m31;
        e[7] = m32;
        e[8] = m33;
        return this;
      };
      _proto.add = function add(right) {
        Matrix3x32.add(this, right, this);
        return this;
      };
      _proto.subtract = function subtract(right) {
        Matrix3x32.subtract(this, right, this);
        return this;
      };
      _proto.multiply = function multiply(right) {
        Matrix3x32.multiply(this, right, this);
        return this;
      };
      _proto.determinant = function determinant() {
        var e = this.elements;
        var a11 = e[0], a12 = e[1], a13 = e[2];
        var a21 = e[3], a22 = e[4], a23 = e[5];
        var a31 = e[6], a32 = e[7], a33 = e[8];
        var b12 = a33 * a22 - a23 * a32;
        var b22 = -a33 * a21 + a23 * a31;
        var b32 = a32 * a21 - a22 * a31;
        return a11 * b12 + a12 * b22 + a13 * b32;
      };
      _proto.identity = function identity() {
        var e = this.elements;
        e[0] = 1;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 1;
        e[5] = 0;
        e[6] = 0;
        e[7] = 0;
        e[8] = 1;
        return this;
      };
      _proto.invert = function invert() {
        Matrix3x32.invert(this, this);
        return this;
      };
      _proto.rotate = function rotate(r) {
        Matrix3x32.rotate(this, r, this);
        return this;
      };
      _proto.scale = function scale(s) {
        Matrix3x32.scale(this, s, this);
        return this;
      };
      _proto.translate = function translate(translation) {
        Matrix3x32.translate(this, translation, this);
        return this;
      };
      _proto.transpose = function transpose() {
        Matrix3x32.transpose(this, this);
        return this;
      };
      _proto.clone = function clone() {
        var e = this.elements;
        var ret = new Matrix3x32(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
        return ret;
      };
      _proto.copyFrom = function copyFrom(source) {
        var e = this.elements;
        var se = source.elements;
        e[0] = se[0];
        e[1] = se[1];
        e[2] = se[2];
        e[3] = se[3];
        e[4] = se[4];
        e[5] = se[5];
        e[6] = se[6];
        e[7] = se[7];
        e[8] = se[8];
        return this;
      };
      _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var srce = this.elements;
        for (var i = 0; i < 12; i++) {
          srce[i] = array[i + offset];
        }
        return this;
      };
      _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) {
          outOffset = 0;
        }
        var e = this.elements;
        out[outOffset] = e[0];
        out[outOffset + 1] = e[1];
        out[outOffset + 2] = e[2];
        out[outOffset + 3] = e[3];
        out[outOffset + 4] = e[4];
        out[outOffset + 5] = e[5];
        out[outOffset + 6] = e[6];
        out[outOffset + 7] = e[7];
        out[outOffset + 8] = e[8];
      };
      _proto.copyFromMatrix = function copyFromMatrix(source) {
        var ae = source.elements;
        var e = this.elements;
        e[0] = ae[0];
        e[1] = ae[1];
        e[2] = ae[2];
        e[3] = ae[4];
        e[4] = ae[5];
        e[5] = ae[6];
        e[6] = ae[8];
        e[7] = ae[9];
        e[8] = ae[10];
        return this;
      };
      return Matrix3x32;
    }();
    var Quaternion = /* @__PURE__ */ function() {
      Quaternion2.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._z = left._z + right._z;
        out._w = left._w + right._w;
        out._onValueChanged && out._onValueChanged();
      };
      Quaternion2.multiply = function multiply(left, right, out) {
        var ax = left._x, ay = left._y, az = left._z, aw = left._w;
        var bx = right._x, by = right._y, bz = right._z, bw = right._w;
        out._x = ax * bw + aw * bx + ay * bz - az * by;
        out._y = ay * bw + aw * by + az * bx - ax * bz;
        out._z = az * bw + aw * bz + ax * by - ay * bx;
        out._w = aw * bw - ax * bx - ay * by - az * bz;
        out._onValueChanged && out._onValueChanged();
      };
      Quaternion2.conjugate = function conjugate(a, out) {
        out._x = -a._x;
        out._y = -a._y;
        out._z = -a._z;
        out._w = a._w;
        out._onValueChanged && out._onValueChanged();
      };
      Quaternion2.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
      };
      Quaternion2.equals = function equals(left, right) {
        return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y) && MathUtil.equals(left._z, right._z) && MathUtil.equals(left._w, right._w);
      };
      Quaternion2.rotationAxisAngle = function rotationAxisAngle(axis, rad, out) {
        var normalAxis = Quaternion2._tempVector3;
        Vector3.normalize(axis, normalAxis);
        rad *= 0.5;
        var s = Math.sin(rad);
        out._x = normalAxis._x * s;
        out._y = normalAxis._y * s;
        out._z = normalAxis._z * s;
        out._w = Math.cos(rad);
        out._onValueChanged && out._onValueChanged();
      };
      Quaternion2.rotationEuler = function rotationEuler(x, y, z, out) {
        Quaternion2.rotationYawPitchRoll(y, x, z, out);
      };
      Quaternion2.rotationYawPitchRoll = function rotationYawPitchRoll(yaw, pitch, roll, out) {
        var halfRoll = roll * 0.5;
        var halfPitch = pitch * 0.5;
        var halfYaw = yaw * 0.5;
        var sinRoll = Math.sin(halfRoll);
        var cosRoll = Math.cos(halfRoll);
        var sinPitch = Math.sin(halfPitch);
        var cosPitch = Math.cos(halfPitch);
        var sinYaw = Math.sin(halfYaw);
        var cosYaw = Math.cos(halfYaw);
        var cosYawPitch = cosYaw * cosPitch;
        var sinYawPitch = sinYaw * sinPitch;
        out._x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
        out._y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
        out._z = cosYawPitch * sinRoll - sinYawPitch * cosRoll;
        out._w = cosYawPitch * cosRoll + sinYawPitch * sinRoll;
        out._onValueChanged && out._onValueChanged();
      };
      Quaternion2.rotationMatrix3x3 = function rotationMatrix3x3(m, out) {
        var me = m.elements;
        var m11 = me[0], m12 = me[1], m13 = me[2];
        var m21 = me[3], m22 = me[4], m23 = me[5];
        var m31 = me[6], m32 = me[7], m33 = me[8];
        var scale = m11 + m22 + m33;
        var sqrt, half;
        if (scale > 0) {
          sqrt = Math.sqrt(scale + 1);
          out._w = sqrt * 0.5;
          sqrt = 0.5 / sqrt;
          out._x = (m23 - m32) * sqrt;
          out._y = (m31 - m13) * sqrt;
          out._z = (m12 - m21) * sqrt;
        } else if (m11 >= m22 && m11 >= m33) {
          sqrt = Math.sqrt(1 + m11 - m22 - m33);
          half = 0.5 / sqrt;
          out._x = 0.5 * sqrt;
          out._y = (m12 + m21) * half;
          out._z = (m13 + m31) * half;
          out._w = (m23 - m32) * half;
        } else if (m22 > m33) {
          sqrt = Math.sqrt(1 + m22 - m11 - m33);
          half = 0.5 / sqrt;
          out._x = (m21 + m12) * half;
          out._y = 0.5 * sqrt;
          out._z = (m32 + m23) * half;
          out._w = (m31 - m13) * half;
        } else {
          sqrt = Math.sqrt(1 + m33 - m11 - m22);
          half = 0.5 / sqrt;
          out._x = (m13 + m31) * half;
          out._y = (m23 + m32) * half;
          out._z = 0.5 * sqrt;
          out._w = (m12 - m21) * half;
        }
        out._onValueChanged && out._onValueChanged();
      };
      Quaternion2.invert = function invert(a, out) {
        var x = a._x, y = a._y, z = a._z, w = a._w;
        var dot = x * x + y * y + z * z + w * w;
        if (dot > MathUtil.zeroTolerance) {
          var invDot = 1 / dot;
          out._x = -x * invDot;
          out._y = -y * invDot;
          out._z = -z * invDot;
          out._w = w * invDot;
          out._onValueChanged && out._onValueChanged();
        }
      };
      Quaternion2.lerp = function lerp(start2, end, t, out) {
        var inv = 1 - t;
        if (Quaternion2.dot(start2, end) >= 0) {
          out._x = start2._x * inv + end._x * t;
          out._y = start2._y * inv + end._y * t;
          out._z = start2._z * inv + end._z * t;
          out._w = start2._w * inv + end._w * t;
        } else {
          out._x = start2._x * inv - end._x * t;
          out._y = start2._y * inv - end._y * t;
          out._z = start2._z * inv - end._z * t;
          out._w = start2._w * inv - end._w * t;
        }
        out.normalize();
      };
      Quaternion2.slerp = function slerp(start2, end, t, out) {
        var ax = start2._x;
        var ay = start2._y;
        var az = start2._z;
        var aw = start2._w;
        var bx = end._x;
        var by = end._y;
        var bz = end._z;
        var bw = end._w;
        var scale0, scale1;
        var cosom = ax * bx + ay * by + az * bz + aw * bw;
        if (cosom < 0) {
          cosom = -cosom;
          bx = -bx;
          by = -by;
          bz = -bz;
          bw = -bw;
        }
        if (1 - cosom > MathUtil.zeroTolerance) {
          var omega = Math.acos(cosom);
          var sinom = Math.sin(omega);
          scale0 = Math.sin((1 - t) * omega) / sinom;
          scale1 = Math.sin(t * omega) / sinom;
        } else {
          scale0 = 1 - t;
          scale1 = t;
        }
        out._x = scale0 * ax + scale1 * bx;
        out._y = scale0 * ay + scale1 * by;
        out._z = scale0 * az + scale1 * bz;
        out._w = scale0 * aw + scale1 * bw;
        out._onValueChanged && out._onValueChanged();
      };
      Quaternion2.normalize = function normalize(a, out) {
        var _x = a._x, _y = a._y, _z = a._z, _w = a._w;
        var len = Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
        if (len > MathUtil.zeroTolerance) {
          len = 1 / len;
          out._x = _x * len;
          out._y = _y * len;
          out._z = _z * len;
          out._w = _w * len;
          out._onValueChanged && out._onValueChanged();
        }
      };
      Quaternion2.rotationX = function rotationX(rad, out) {
        rad *= 0.5;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out._x = s;
        out._y = 0;
        out._z = 0;
        out._w = c;
        out._onValueChanged && out._onValueChanged();
      };
      Quaternion2.rotationY = function rotationY(rad, out) {
        rad *= 0.5;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out._x = 0;
        out._y = s;
        out._z = 0;
        out._w = c;
        out._onValueChanged && out._onValueChanged();
      };
      Quaternion2.rotationZ = function rotationZ(rad, out) {
        rad *= 0.5;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out._x = 0;
        out._y = 0;
        out._z = s;
        out._w = c;
        out._onValueChanged && out._onValueChanged();
      };
      Quaternion2.rotateX = function rotateX(quaternion, rad, out) {
        var _x = quaternion._x, _y = quaternion._y, _z = quaternion._z, _w = quaternion._w;
        rad *= 0.5;
        var bx = Math.sin(rad);
        var bw = Math.cos(rad);
        out._x = _x * bw + _w * bx;
        out._y = _y * bw + _z * bx;
        out._z = _z * bw - _y * bx;
        out._w = _w * bw - _x * bx;
        out._onValueChanged && out._onValueChanged();
      };
      Quaternion2.rotateY = function rotateY(quaternion, rad, out) {
        var _x = quaternion._x, _y = quaternion._y, _z = quaternion._z, _w = quaternion._w;
        rad *= 0.5;
        var by = Math.sin(rad);
        var bw = Math.cos(rad);
        out._x = _x * bw - _z * by;
        out._y = _y * bw + _w * by;
        out._z = _z * bw + _x * by;
        out._w = _w * bw - _y * by;
        out._onValueChanged && out._onValueChanged();
      };
      Quaternion2.rotateZ = function rotateZ(quaternion, rad, out) {
        var _x = quaternion._x, _y = quaternion._y, _z = quaternion._z, _w = quaternion._w;
        rad *= 0.5;
        var bz = Math.sin(rad);
        var bw = Math.cos(rad);
        out._x = _x * bw + _y * bz;
        out._y = _y * bw - _x * bz;
        out._z = _z * bw + _w * bz;
        out._w = _w * bw - _z * bz;
        out._onValueChanged && out._onValueChanged();
      };
      Quaternion2.scale = function scale(a, s, out) {
        out._x = a._x * s;
        out._y = a._y * s;
        out._z = a._z * s;
        out._w = a._w * s;
        out._onValueChanged && out._onValueChanged();
      };
      function Quaternion2(x, y, z, w) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (w === void 0) {
          w = 1;
        }
        this._x = void 0;
        this._y = void 0;
        this._z = void 0;
        this._w = void 0;
        this._onValueChanged = null;
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
      }
      var _proto = Quaternion2.prototype;
      _proto.set = function set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.conjugate = function conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.getAxisAngle = function getAxisAngle(out) {
        var _x = this._x, _y = this._y, _z = this._z;
        var length2 = _x * _x + _y * _y + _z * _z;
        if (length2 < MathUtil.zeroTolerance) {
          out._x = 1;
          out._y = 0;
          out._z = 0;
          return 0;
        } else {
          var inv = 1 / length2;
          out._x = this._x * inv;
          out._y = this._y * inv;
          out._z = this._z * inv;
          return Math.acos(this._w) * 2;
        }
      };
      _proto.identity = function identity() {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.length = function length2() {
        var _x = this._x, _y = this._y, _z = this._z, _w = this._w;
        return Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
      };
      _proto.lengthSquared = function lengthSquared() {
        var _x = this._x, _y = this._y, _z = this._z, _w = this._w;
        return _x * _x + _y * _y + _z * _z + _w * _w;
      };
      _proto.normalize = function normalize() {
        Quaternion2.normalize(this, this);
        return this;
      };
      _proto.toEuler = function toEuler(out) {
        this._toYawPitchRoll(out);
        var t = out._x;
        out._x = out._y;
        out._y = t;
        out._onValueChanged && out._onValueChanged();
        return out;
      };
      _proto.toYawPitchRoll = function toYawPitchRoll(out) {
        this._toYawPitchRoll(out);
        out._onValueChanged && out._onValueChanged();
        return out;
      };
      _proto.rotateX = function rotateX(rad) {
        Quaternion2.rotateX(this, rad, this);
        return this;
      };
      _proto.rotateY = function rotateY(rad) {
        Quaternion2.rotateY(this, rad, this);
        return this;
      };
      _proto.rotateZ = function rotateZ(rad) {
        Quaternion2.rotateZ(this, rad, this);
        return this;
      };
      _proto.rotationAxisAngle = function rotationAxisAngle(axis, rad) {
        Quaternion2.rotationAxisAngle(axis, rad, this);
        return this;
      };
      _proto.multiply = function multiply(quat) {
        Quaternion2.multiply(this, quat, this);
        return this;
      };
      _proto.invert = function invert() {
        Quaternion2.invert(this, this);
        return this;
      };
      _proto.dot = function dot(quat) {
        return Quaternion2.dot(this, quat);
      };
      _proto.lerp = function lerp(quat, t) {
        Quaternion2.lerp(this, quat, t, this);
        return this;
      };
      _proto.rotateAxisAngle = function rotateAxisAngle(axis, rad) {
        Quaternion2._tempQuat1.rotationAxisAngle(axis, rad);
        this.multiply(Quaternion2._tempQuat1);
        return this;
      };
      _proto.clone = function clone() {
        return new Quaternion2(this._x, this._y, this._z, this._w);
      };
      _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._z = source.z;
        this._w = source.w;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) {
          outOffset = 0;
        }
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
        out[outOffset + 2] = this._z;
        out[outOffset + 3] = this._w;
      };
      _proto._toYawPitchRoll = function _toYawPitchRoll(out) {
        var _x = this._x, _y = this._y, _z = this._z, _w = this._w;
        var xx = _x * _x;
        var yy = _y * _y;
        var zz = _z * _z;
        var xy = _x * _y;
        var zw = _z * _w;
        var zx = _z * _x;
        var yw = _y * _w;
        var yz = _y * _z;
        var xw = _x * _w;
        out._y = Math.asin(2 * (xw - yz));
        if (Math.cos(out.y) > MathUtil.zeroTolerance) {
          out._z = Math.atan2(2 * (xy + zw), 1 - 2 * (zz + xx));
          out._x = Math.atan2(2 * (zx + yw), 1 - 2 * (yy + xx));
        } else {
          out._z = Math.atan2(-2 * (xy - zw), 1 - 2 * (yy + zz));
          out._x = 0;
        }
        return out;
      };
      _createClass2(Quaternion2, [{
        key: "x",
        get: function get() {
          return this._x;
        },
        set: function set(value) {
          this._x = value;
          this._onValueChanged && this._onValueChanged();
        }
      }, {
        key: "y",
        get: function get() {
          return this._y;
        },
        set: function set(value) {
          this._y = value;
          this._onValueChanged && this._onValueChanged();
        }
      }, {
        key: "z",
        get: function get() {
          return this._z;
        },
        set: function set(value) {
          this._z = value;
          this._onValueChanged && this._onValueChanged();
        }
      }, {
        key: "normalized",
        get: function get() {
          return Math.abs(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w - 1) < MathUtil.zeroTolerance;
        }
      }, {
        key: "w",
        get: function get() {
          return this._w;
        },
        set: function set(value) {
          this._w = value;
          this._onValueChanged && this._onValueChanged();
        }
      }]);
      return Quaternion2;
    }();
    Quaternion._tempVector3 = new Vector3();
    Quaternion._tempQuat1 = new Quaternion();
    var Matrix = /* @__PURE__ */ function() {
      Matrix2.multiply = function multiply(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        var l11 = le[0], l12 = le[1], l13 = le[2], l14 = le[3];
        var l21 = le[4], l22 = le[5], l23 = le[6], l24 = le[7];
        var l31 = le[8], l32 = le[9], l33 = le[10], l34 = le[11];
        var l41 = le[12], l42 = le[13], l43 = le[14], l44 = le[15];
        var r11 = re[0], r12 = re[1], r13 = re[2], r14 = re[3];
        var r21 = re[4], r22 = re[5], r23 = re[6], r24 = re[7];
        var r31 = re[8], r32 = re[9], r33 = re[10], r34 = re[11];
        var r41 = re[12], r42 = re[13], r43 = re[14], r44 = re[15];
        oe[0] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;
        oe[1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;
        oe[2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;
        oe[3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;
        oe[4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;
        oe[5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;
        oe[6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;
        oe[7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;
        oe[8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;
        oe[9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;
        oe[10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;
        oe[11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;
        oe[12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;
        oe[13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;
        oe[14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;
        oe[15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;
      };
      Matrix2.equals = function equals(left, right) {
        var le = left.elements;
        var re = right.elements;
        return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]) && MathUtil.equals(le[9], re[9]) && MathUtil.equals(le[10], re[10]) && MathUtil.equals(le[11], re[11]) && MathUtil.equals(le[12], re[12]) && MathUtil.equals(le[13], re[13]) && MathUtil.equals(le[14], re[14]) && MathUtil.equals(le[15], re[15]);
      };
      Matrix2.lerp = function lerp(start2, end, t, out) {
        var se = start2.elements;
        var ee = end.elements;
        var oe = out.elements;
        var inv = 1 - t;
        oe[0] = se[0] * inv + ee[0] * t;
        oe[1] = se[1] * inv + ee[1] * t;
        oe[2] = se[2] * inv + ee[2] * t;
        oe[3] = se[3] * inv + ee[3] * t;
        oe[4] = se[4] * inv + ee[4] * t;
        oe[5] = se[5] * inv + ee[5] * t;
        oe[6] = se[6] * inv + ee[6] * t;
        oe[7] = se[7] * inv + ee[7] * t;
        oe[8] = se[8] * inv + ee[8] * t;
        oe[9] = se[9] * inv + ee[9] * t;
        oe[10] = se[10] * inv + ee[10] * t;
        oe[11] = se[11] * inv + ee[11] * t;
        oe[12] = se[12] * inv + ee[12] * t;
        oe[13] = se[13] * inv + ee[13] * t;
        oe[14] = se[14] * inv + ee[14] * t;
        oe[15] = se[15] * inv + ee[15] * t;
      };
      Matrix2.rotationQuaternion = function rotationQuaternion(quaternion, out) {
        var oe = out.elements;
        var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        oe[0] = 1 - yy - zz;
        oe[1] = yx + wz;
        oe[2] = zx - wy;
        oe[3] = 0;
        oe[4] = yx - wz;
        oe[5] = 1 - xx - zz;
        oe[6] = zy + wx;
        oe[7] = 0;
        oe[8] = zx + wy;
        oe[9] = zy - wx;
        oe[10] = 1 - xx - yy;
        oe[11] = 0;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 0;
        oe[15] = 1;
      };
      Matrix2.rotationAxisAngle = function rotationAxisAngle(axis, r, out) {
        var oe = out.elements;
        var x = axis._x, y = axis._y, z = axis._z;
        var len = Math.sqrt(x * x + y * y + z * z);
        var s, c, t;
        if (Math.abs(len) < MathUtil.zeroTolerance) {
          return;
        }
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(r);
        c = Math.cos(r);
        t = 1 - c;
        oe[0] = x * x * t + c;
        oe[1] = y * x * t + z * s;
        oe[2] = z * x * t - y * s;
        oe[3] = 0;
        oe[4] = x * y * t - z * s;
        oe[5] = y * y * t + c;
        oe[6] = z * y * t + x * s;
        oe[7] = 0;
        oe[8] = x * z * t + y * s;
        oe[9] = y * z * t - x * s;
        oe[10] = z * z * t + c;
        oe[11] = 0;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 0;
        oe[15] = 1;
      };
      Matrix2.rotationTranslation = function rotationTranslation(quaternion, translation, out) {
        Matrix2.rotationQuaternion(quaternion, out);
        var oe = out.elements;
        oe[12] = translation._x;
        oe[13] = translation._y;
        oe[14] = translation._z;
      };
      Matrix2.affineTransformation = function affineTransformation(scale, rotation, translation, out) {
        var oe = out.elements;
        var x = rotation._x, y = rotation._y, z = rotation._z, w = rotation._w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var sx = scale._x;
        var sy = scale._y;
        var sz = scale._z;
        oe[0] = (1 - (yy + zz)) * sx;
        oe[1] = (xy + wz) * sx;
        oe[2] = (xz - wy) * sx;
        oe[3] = 0;
        oe[4] = (xy - wz) * sy;
        oe[5] = (1 - (xx + zz)) * sy;
        oe[6] = (yz + wx) * sy;
        oe[7] = 0;
        oe[8] = (xz + wy) * sz;
        oe[9] = (yz - wx) * sz;
        oe[10] = (1 - (xx + yy)) * sz;
        oe[11] = 0;
        oe[12] = translation._x;
        oe[13] = translation._y;
        oe[14] = translation._z;
        oe[15] = 1;
      };
      Matrix2.scaling = function scaling(s, out) {
        var oe = out.elements;
        oe[0] = s._x;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = s._y;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = s._z;
        oe[11] = 0;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 0;
        oe[15] = 1;
      };
      Matrix2.translation = function translation(_translation, out) {
        var oe = out.elements;
        oe[0] = 1;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = 1;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = 1;
        oe[11] = 0;
        oe[12] = _translation._x;
        oe[13] = _translation._y;
        oe[14] = _translation._z;
        oe[15] = 1;
      };
      Matrix2.invert = function invert(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];
        var a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];
        var a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];
        var a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];
        var b00 = a11 * a22 - a12 * a21;
        var b01 = a11 * a23 - a13 * a21;
        var b02 = a11 * a24 - a14 * a21;
        var b03 = a12 * a23 - a13 * a22;
        var b04 = a12 * a24 - a14 * a22;
        var b05 = a13 * a24 - a14 * a23;
        var b06 = a31 * a42 - a32 * a41;
        var b07 = a31 * a43 - a33 * a41;
        var b08 = a31 * a44 - a34 * a41;
        var b09 = a32 * a43 - a33 * a42;
        var b10 = a32 * a44 - a34 * a42;
        var b11 = a33 * a44 - a34 * a43;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) {
          return null;
        }
        det = 1 / det;
        oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
        oe[1] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
        oe[2] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
        oe[3] = (a33 * b04 - a32 * b05 - a34 * b03) * det;
        oe[4] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
        oe[5] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
        oe[6] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
        oe[7] = (a31 * b05 - a33 * b02 + a34 * b01) * det;
        oe[8] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
        oe[9] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
        oe[10] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
        oe[11] = (a32 * b02 - a31 * b04 - a34 * b00) * det;
        oe[12] = (a22 * b07 - a21 * b09 - a23 * b06) * det;
        oe[13] = (a11 * b09 - a12 * b07 + a13 * b06) * det;
        oe[14] = (a42 * b01 - a41 * b03 - a43 * b00) * det;
        oe[15] = (a31 * b03 - a32 * b01 + a33 * b00) * det;
      };
      Matrix2.lookAt = function lookAt(eye, target, up, out) {
        var oe = out.elements;
        var xAxis = Matrix2._tempVec30;
        var yAxis = Matrix2._tempVec31;
        var zAxis = Matrix2._tempVec32;
        Vector3.subtract(eye, target, zAxis);
        zAxis.normalize();
        Vector3.cross(up, zAxis, xAxis);
        xAxis.normalize();
        Vector3.cross(zAxis, xAxis, yAxis);
        oe[0] = xAxis._x;
        oe[1] = yAxis._x;
        oe[2] = zAxis._x;
        oe[3] = 0;
        oe[4] = xAxis._y;
        oe[5] = yAxis._y;
        oe[6] = zAxis._y;
        oe[7] = 0;
        oe[8] = xAxis._z;
        oe[9] = yAxis._z;
        oe[10] = zAxis._z;
        oe[11] = 0;
        oe[12] = -Vector3.dot(xAxis, eye);
        oe[13] = -Vector3.dot(yAxis, eye);
        oe[14] = -Vector3.dot(zAxis, eye);
        oe[15] = 1;
      };
      Matrix2.ortho = function ortho(left, right, bottom, top, near, far, out) {
        var oe = out.elements;
        var lr = 1 / (left - right);
        var bt = 1 / (bottom - top);
        var nf = 1 / (near - far);
        oe[0] = -2 * lr;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = -2 * bt;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = 2 * nf;
        oe[11] = 0;
        oe[12] = (left + right) * lr;
        oe[13] = (top + bottom) * bt;
        oe[14] = (far + near) * nf;
        oe[15] = 1;
      };
      Matrix2.perspective = function perspective(fovY, aspect, near, far, out) {
        var oe = out.elements;
        var f = 1 / Math.tan(fovY / 2);
        var nf = 1 / (near - far);
        oe[0] = f / aspect;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = f;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = (far + near) * nf;
        oe[11] = -1;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 2 * far * near * nf;
        oe[15] = 0;
      };
      Matrix2.rotateAxisAngle = function rotateAxisAngle(m, axis, r, out) {
        var x = axis._x, y = axis._y, z = axis._z;
        var len = Math.sqrt(x * x + y * y + z * z);
        if (Math.abs(len) < MathUtil.zeroTolerance) {
          return;
        }
        var me = m.elements;
        var oe = out.elements;
        var s, c, t;
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(r);
        c = Math.cos(r);
        t = 1 - c;
        var a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
        var a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
        var a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
        var b11 = x * x * t + c;
        var b12 = y * x * t + z * s;
        var b13 = z * x * t - y * s;
        var b21 = x * y * t - z * s;
        var b22 = y * y * t + c;
        var b23 = z * y * t + x * s;
        var b31 = x * z * t + y * s;
        var b32 = y * z * t - x * s;
        var b33 = z * z * t + c;
        oe[0] = a11 * b11 + a21 * b12 + a31 * b13;
        oe[1] = a12 * b11 + a22 * b12 + a32 * b13;
        oe[2] = a13 * b11 + a23 * b12 + a33 * b13;
        oe[3] = a14 * b11 + a24 * b12 + a34 * b13;
        oe[4] = a11 * b21 + a21 * b22 + a31 * b23;
        oe[5] = a12 * b21 + a22 * b22 + a32 * b23;
        oe[6] = a13 * b21 + a23 * b22 + a33 * b23;
        oe[7] = a14 * b21 + a24 * b22 + a34 * b23;
        oe[8] = a11 * b31 + a21 * b32 + a31 * b33;
        oe[9] = a12 * b31 + a22 * b32 + a32 * b33;
        oe[10] = a13 * b31 + a23 * b32 + a33 * b33;
        oe[11] = a14 * b31 + a24 * b32 + a34 * b33;
        if (m !== out) {
          oe[12] = me[12];
          oe[13] = me[13];
          oe[14] = me[14];
          oe[15] = me[15];
        }
      };
      Matrix2.scale = function scale(m, s, out) {
        var me = m.elements;
        var oe = out.elements;
        var x = s._x, y = s._y, z = s._z;
        oe[0] = me[0] * x;
        oe[1] = me[1] * x;
        oe[2] = me[2] * x;
        oe[3] = me[3] * x;
        oe[4] = me[4] * y;
        oe[5] = me[5] * y;
        oe[6] = me[6] * y;
        oe[7] = me[7] * y;
        oe[8] = me[8] * z;
        oe[9] = me[9] * z;
        oe[10] = me[10] * z;
        oe[11] = me[11] * z;
        oe[12] = me[12];
        oe[13] = me[13];
        oe[14] = me[14];
        oe[15] = me[15];
      };
      Matrix2.translate = function translate(m, v, out) {
        var me = m.elements;
        var oe = out.elements;
        var x = v._x, y = v._y, z = v._z;
        if (m === out) {
          oe[12] = me[0] * x + me[4] * y + me[8] * z + me[12];
          oe[13] = me[1] * x + me[5] * y + me[9] * z + me[13];
          oe[14] = me[2] * x + me[6] * y + me[10] * z + me[14];
          oe[15] = me[3] * x + me[7] * y + me[11] * z + me[15];
        } else {
          var a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
          var a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
          var a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
          oe[0] = a11, oe[1] = a12, oe[2] = a13, oe[3] = a14;
          oe[4] = a21, oe[5] = a22, oe[6] = a23, oe[7] = a24;
          oe[8] = a31, oe[9] = a32, oe[10] = a33, oe[11] = a34;
          oe[12] = a11 * x + a21 * y + a31 * z + me[12];
          oe[13] = a12 * x + a22 * y + a32 * z + me[13];
          oe[14] = a13 * x + a23 * y + a33 * z + me[14];
          oe[15] = a14 * x + a24 * y + a34 * z + me[15];
        }
      };
      Matrix2.transpose = function transpose(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        if (out === a) {
          var a12 = ae[1];
          var a13 = ae[2];
          var a14 = ae[3];
          var a23 = ae[6];
          var a24 = ae[7];
          var a34 = ae[11];
          oe[1] = ae[4];
          oe[2] = ae[8];
          oe[3] = ae[12];
          oe[4] = a12;
          oe[6] = ae[9];
          oe[7] = ae[13];
          oe[8] = a13;
          oe[9] = a23;
          oe[11] = ae[14];
          oe[12] = a14;
          oe[13] = a24;
          oe[14] = a34;
        } else {
          oe[0] = ae[0];
          oe[1] = ae[4];
          oe[2] = ae[8];
          oe[3] = ae[12];
          oe[4] = ae[1];
          oe[5] = ae[5];
          oe[6] = ae[9];
          oe[7] = ae[13];
          oe[8] = ae[2];
          oe[9] = ae[6];
          oe[10] = ae[10];
          oe[11] = ae[14];
          oe[12] = ae[3];
          oe[13] = ae[7];
          oe[14] = ae[11];
          oe[15] = ae[15];
        }
      };
      function Matrix2(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        if (m11 === void 0) {
          m11 = 1;
        }
        if (m12 === void 0) {
          m12 = 0;
        }
        if (m13 === void 0) {
          m13 = 0;
        }
        if (m14 === void 0) {
          m14 = 0;
        }
        if (m21 === void 0) {
          m21 = 0;
        }
        if (m22 === void 0) {
          m22 = 1;
        }
        if (m23 === void 0) {
          m23 = 0;
        }
        if (m24 === void 0) {
          m24 = 0;
        }
        if (m31 === void 0) {
          m31 = 0;
        }
        if (m32 === void 0) {
          m32 = 0;
        }
        if (m33 === void 0) {
          m33 = 1;
        }
        if (m34 === void 0) {
          m34 = 0;
        }
        if (m41 === void 0) {
          m41 = 0;
        }
        if (m42 === void 0) {
          m42 = 0;
        }
        if (m43 === void 0) {
          m43 = 0;
        }
        if (m44 === void 0) {
          m44 = 1;
        }
        this.elements = new Float32Array(16);
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m14;
        e[4] = m21;
        e[5] = m22;
        e[6] = m23;
        e[7] = m24;
        e[8] = m31;
        e[9] = m32;
        e[10] = m33;
        e[11] = m34;
        e[12] = m41;
        e[13] = m42;
        e[14] = m43;
        e[15] = m44;
      }
      var _proto = Matrix2.prototype;
      _proto.set = function set(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m14;
        e[4] = m21;
        e[5] = m22;
        e[6] = m23;
        e[7] = m24;
        e[8] = m31;
        e[9] = m32;
        e[10] = m33;
        e[11] = m34;
        e[12] = m41;
        e[13] = m42;
        e[14] = m43;
        e[15] = m44;
        return this;
      };
      _proto.multiply = function multiply(right) {
        Matrix2.multiply(this, right, this);
        return this;
      };
      _proto.determinant = function determinant() {
        var e = this.elements;
        var a11 = e[0], a12 = e[1], a13 = e[2], a14 = e[3];
        var a21 = e[4], a22 = e[5], a23 = e[6], a24 = e[7];
        var a31 = e[8], a32 = e[9], a33 = e[10], a34 = e[11];
        var a41 = e[12], a42 = e[13], a43 = e[14], a44 = e[15];
        var b00 = a11 * a22 - a12 * a21;
        var b01 = a11 * a23 - a13 * a21;
        var b02 = a11 * a24 - a14 * a21;
        var b03 = a12 * a23 - a13 * a22;
        var b04 = a12 * a24 - a14 * a22;
        var b05 = a13 * a24 - a14 * a23;
        var b06 = a31 * a42 - a32 * a41;
        var b07 = a31 * a43 - a33 * a41;
        var b08 = a31 * a44 - a34 * a41;
        var b09 = a32 * a43 - a33 * a42;
        var b10 = a32 * a44 - a34 * a42;
        var b11 = a33 * a44 - a34 * a43;
        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      };
      _proto.decompose = function decompose(translation, rotation, scale) {
        var rm = Matrix2._tempMat30;
        var e = this.elements;
        var rme = rm.elements;
        var m11 = e[0];
        var m12 = e[1];
        var m13 = e[2];
        var m14 = e[3];
        var m21 = e[4];
        var m22 = e[5];
        var m23 = e[6];
        var m24 = e[7];
        var m31 = e[8];
        var m32 = e[9];
        var m33 = e[10];
        var m34 = e[11];
        translation.set(e[12], e[13], e[14]);
        var xs = Math.sign(m11 * m12 * m13 * m14) < 0 ? -1 : 1;
        var ys = Math.sign(m21 * m22 * m23 * m24) < 0 ? -1 : 1;
        var zs = Math.sign(m31 * m32 * m33 * m34) < 0 ? -1 : 1;
        var sx = xs * Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
        var sy = ys * Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
        var sz = zs * Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
        scale.set(sx, sy, sz);
        if (Math.abs(sx) < MathUtil.zeroTolerance || Math.abs(sy) < MathUtil.zeroTolerance || Math.abs(sz) < MathUtil.zeroTolerance) {
          rotation.identity();
          return false;
        } else {
          var invSX = 1 / sx;
          var invSY = 1 / sy;
          var invSZ = 1 / sz;
          rme[0] = m11 * invSX;
          rme[1] = m12 * invSX;
          rme[2] = m13 * invSX;
          rme[3] = m21 * invSY;
          rme[4] = m22 * invSY;
          rme[5] = m23 * invSY;
          rme[6] = m31 * invSZ;
          rme[7] = m32 * invSZ;
          rme[8] = m33 * invSZ;
          Quaternion.rotationMatrix3x3(rm, rotation);
          return true;
        }
      };
      _proto.getRotation = function getRotation(out) {
        var e = this.elements;
        var trace = e[0] + e[5] + e[10];
        if (trace > MathUtil.zeroTolerance) {
          var s = Math.sqrt(trace + 1) * 2;
          out._w = 0.25 * s;
          out._x = (e[6] - e[9]) / s;
          out._y = (e[8] - e[2]) / s;
          out._z = (e[1] - e[4]) / s;
        } else if (e[0] > e[5] && e[0] > e[10]) {
          var _s = Math.sqrt(1 + e[0] - e[5] - e[10]) * 2;
          out._w = (e[6] - e[9]) / _s;
          out._x = 0.25 * _s;
          out._y = (e[1] + e[4]) / _s;
          out._z = (e[8] + e[2]) / _s;
        } else if (e[5] > e[10]) {
          var _s2 = Math.sqrt(1 + e[5] - e[0] - e[10]) * 2;
          out._w = (e[8] - e[2]) / _s2;
          out._x = (e[1] + e[4]) / _s2;
          out._y = 0.25 * _s2;
          out._z = (e[6] + e[9]) / _s2;
        } else {
          var _s3 = Math.sqrt(1 + e[10] - e[0] - e[5]) * 2;
          out._w = (e[1] - e[4]) / _s3;
          out._x = (e[8] + e[2]) / _s3;
          out._y = (e[6] + e[9]) / _s3;
          out._z = 0.25 * _s3;
        }
        out._onValueChanged && out._onValueChanged();
        return out;
      };
      _proto.getScaling = function getScaling(out) {
        var e = this.elements;
        var m11 = e[0], m12 = e[1], m13 = e[2];
        var m21 = e[4], m22 = e[5], m23 = e[6];
        var m31 = e[8], m32 = e[9], m33 = e[10];
        out.set(Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13), Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23), Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33));
        return out;
      };
      _proto.getTranslation = function getTranslation(out) {
        var e = this.elements;
        out.set(e[12], e[13], e[14]);
        return out;
      };
      _proto.identity = function identity() {
        var e = this.elements;
        e[0] = 1;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 0;
        e[5] = 1;
        e[6] = 0;
        e[7] = 0;
        e[8] = 0;
        e[9] = 0;
        e[10] = 1;
        e[11] = 0;
        e[12] = 0;
        e[13] = 0;
        e[14] = 0;
        e[15] = 1;
        return this;
      };
      _proto.invert = function invert() {
        Matrix2.invert(this, this);
        return this;
      };
      _proto.rotateAxisAngle = function rotateAxisAngle(axis, r) {
        Matrix2.rotateAxisAngle(this, axis, r, this);
        return this;
      };
      _proto.scale = function scale(s) {
        Matrix2.scale(this, s, this);
        return this;
      };
      _proto.translate = function translate(v) {
        Matrix2.translate(this, v, this);
        return this;
      };
      _proto.transpose = function transpose() {
        Matrix2.transpose(this, this);
        return this;
      };
      _proto.clone = function clone() {
        var e = this.elements;
        var ret = new Matrix2(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
        return ret;
      };
      _proto.copyFrom = function copyFrom(source) {
        var e = this.elements;
        var se = source.elements;
        e[0] = se[0];
        e[1] = se[1];
        e[2] = se[2];
        e[3] = se[3];
        e[4] = se[4];
        e[5] = se[5];
        e[6] = se[6];
        e[7] = se[7];
        e[8] = se[8];
        e[9] = se[9];
        e[10] = se[10];
        e[11] = se[11];
        e[12] = se[12];
        e[13] = se[13];
        e[14] = se[14];
        e[15] = se[15];
        return this;
      };
      _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var srce = this.elements;
        for (var i = 0; i < 16; i++) {
          srce[i] = array[i + offset];
        }
        return this;
      };
      _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) {
          outOffset = 0;
        }
        var e = this.elements;
        out[outOffset] = e[0];
        out[outOffset + 1] = e[1];
        out[outOffset + 2] = e[2];
        out[outOffset + 3] = e[3];
        out[outOffset + 4] = e[4];
        out[outOffset + 5] = e[5];
        out[outOffset + 6] = e[6];
        out[outOffset + 7] = e[7];
        out[outOffset + 8] = e[8];
        out[outOffset + 9] = e[9];
        out[outOffset + 10] = e[10];
        out[outOffset + 11] = e[11];
        out[outOffset + 12] = e[12];
        out[outOffset + 13] = e[13];
        out[outOffset + 14] = e[14];
        out[outOffset + 15] = e[15];
      };
      return Matrix2;
    }();
    Matrix._tempVec30 = new Vector3();
    Matrix._tempVec31 = new Vector3();
    Matrix._tempVec32 = new Vector3();
    Matrix._tempMat30 = new Matrix3x3();
    Matrix._identity = new Matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    var Ray = /* @__PURE__ */ function() {
      function Ray2(origin, direction) {
        if (origin === void 0) {
          origin = null;
        }
        if (direction === void 0) {
          direction = null;
        }
        this.origin = new Vector3();
        this.direction = new Vector3();
        origin && this.origin.copyFrom(origin);
        direction && this.direction.copyFrom(direction);
      }
      var _proto = Ray2.prototype;
      _proto.intersectPlane = function intersectPlane(plane) {
        return CollisionUtil.intersectsRayAndPlane(this, plane);
      };
      _proto.intersectSphere = function intersectSphere(sphere) {
        return CollisionUtil.intersectsRayAndSphere(this, sphere);
      };
      _proto.intersectBox = function intersectBox(box) {
        return CollisionUtil.intersectsRayAndBox(this, box);
      };
      _proto.getPoint = function getPoint(distance, out) {
        Vector3.scale(this.direction, distance, out);
        return out.add(this.origin);
      };
      return Ray2;
    }();
    var Vector2 = /* @__PURE__ */ function() {
      Vector22.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._onValueChanged && out._onValueChanged();
      };
      Vector22.subtract = function subtract(left, right, out) {
        out._x = left._x - right._x;
        out._y = left._y - right._y;
        out._onValueChanged && out._onValueChanged();
      };
      Vector22.multiply = function multiply(left, right, out) {
        out._x = left._x * right._x;
        out._y = left._y * right._y;
        out._onValueChanged && out._onValueChanged();
      };
      Vector22.divide = function divide(left, right, out) {
        out._x = left._x / right._x;
        out._y = left._y / right._y;
        out._onValueChanged && out._onValueChanged();
      };
      Vector22.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y;
      };
      Vector22.distance = function distance(left, right) {
        var x = right._x - left._x;
        var y = right._y - left._y;
        return Math.sqrt(x * x + y * y);
      };
      Vector22.distanceSquared = function distanceSquared(left, right) {
        var x = right._x - left._x;
        var y = right._y - left._y;
        return x * x + y * y;
      };
      Vector22.equals = function equals(left, right) {
        return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y);
      };
      Vector22.lerp = function lerp(left, right, t, out) {
        var _x = left._x, _y = left._y;
        out._x = _x + (right._x - _x) * t;
        out._y = _y + (right._y - _y) * t;
        out._onValueChanged && out._onValueChanged();
      };
      Vector22.max = function max(left, right, out) {
        out._x = Math.max(left._x, right._x);
        out._y = Math.max(left._y, right._y);
        out._onValueChanged && out._onValueChanged();
      };
      Vector22.min = function min(left, right, out) {
        out._x = Math.min(left._x, right._x);
        out._y = Math.min(left._y, right._y);
        out._onValueChanged && out._onValueChanged();
      };
      Vector22.negate = function negate(left, out) {
        out._x = -left._x;
        out._y = -left._y;
        out._onValueChanged && out._onValueChanged();
      };
      Vector22.normalize = function normalize(left, out) {
        var _x = left._x, _y = left._y;
        var len = Math.sqrt(_x * _x + _y * _y);
        if (len > MathUtil.zeroTolerance) {
          len = 1 / len;
          out._x = _x * len;
          out._y = _y * len;
          out._onValueChanged && out._onValueChanged();
        }
      };
      Vector22.scale = function scale(left, s, out) {
        out._x = left._x * s;
        out._y = left._y * s;
        out._onValueChanged && out._onValueChanged();
      };
      function Vector22(x, y) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        this._x = void 0;
        this._y = void 0;
        this._onValueChanged = null;
        this._x = x;
        this._y = y;
      }
      var _proto = Vector22.prototype;
      _proto.set = function set(x, y) {
        this._x = x;
        this._y = y;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.add = function add(right) {
        this._x += right._x;
        this._y += right._y;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.subtract = function subtract(right) {
        this._x -= right._x;
        this._y -= right._y;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.multiply = function multiply(right) {
        this._x *= right._x;
        this._y *= right._y;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.divide = function divide(right) {
        this._x /= right._x;
        this._y /= right._y;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.length = function length2() {
        var _x = this._x, _y = this._y;
        return Math.sqrt(_x * _x + _y * _y);
      };
      _proto.lengthSquared = function lengthSquared() {
        var _x = this._x, _y = this._y;
        return _x * _x + _y * _y;
      };
      _proto.negate = function negate() {
        this._x = -this._x;
        this._y = -this._y;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.normalize = function normalize() {
        Vector22.normalize(this, this);
        return this;
      };
      _proto.scale = function scale(s) {
        this._x *= s;
        this._y *= s;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.clone = function clone() {
        return new Vector22(this._x, this._y);
      };
      _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        this._x = array[offset];
        this._y = array[offset + 1];
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) {
          outOffset = 0;
        }
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
      };
      _createClass2(Vector22, [{
        key: "x",
        get: function get() {
          return this._x;
        },
        set: function set(value) {
          this._x = value;
          this._onValueChanged && this._onValueChanged();
        }
      }, {
        key: "y",
        get: function get() {
          return this._y;
        },
        set: function set(value) {
          this._y = value;
          this._onValueChanged && this._onValueChanged();
        }
      }]);
      return Vector22;
    }();
    Vector2._zero = new Vector2(0, 0);
    Vector2._one = new Vector2(1, 1);
    var Vector4 = /* @__PURE__ */ function() {
      Vector42.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._z = left._z + right._z;
        out._w = left._w + right._w;
        out._onValueChanged && out._onValueChanged();
      };
      Vector42.subtract = function subtract(left, right, out) {
        out._x = left._x - right._x;
        out._y = left._y - right._y;
        out._z = left._z - right._z;
        out._w = left._w - right._w;
        out._onValueChanged && out._onValueChanged();
      };
      Vector42.multiply = function multiply(left, right, out) {
        out._x = left._x * right._x;
        out._y = left._y * right._y;
        out._z = left._z * right._z;
        out._w = left._w * right._w;
        out._onValueChanged && out._onValueChanged();
      };
      Vector42.divide = function divide(left, right, out) {
        out._x = left._x / right._x;
        out._y = left._y / right._y;
        out._z = left._z / right._z;
        out._w = left._w / right._w;
        out._onValueChanged && out._onValueChanged();
      };
      Vector42.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
      };
      Vector42.distance = function distance(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        var w = b._w - a._w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
      };
      Vector42.distanceSquared = function distanceSquared(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        var w = b._w - a._w;
        return x * x + y * y + z * z + w * w;
      };
      Vector42.equals = function equals(left, right) {
        return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y) && MathUtil.equals(left._z, right._z) && MathUtil.equals(left._w, right._w);
      };
      Vector42.lerp = function lerp(start2, end, t, out) {
        var _x = start2._x, _y = start2._y, _z = start2._z, _w = start2._w;
        out._x = _x + (end._x - _x) * t;
        out._y = _y + (end._y - _y) * t;
        out._z = _z + (end._z - _z) * t;
        out._w = _w + (end._w - _w) * t;
        out._onValueChanged && out._onValueChanged();
      };
      Vector42.max = function max(left, right, out) {
        out._x = Math.max(left._x, right._x);
        out._y = Math.max(left._y, right._y);
        out._z = Math.max(left._z, right._z);
        out._w = Math.max(left._w, right._w);
        out._onValueChanged && out._onValueChanged();
      };
      Vector42.min = function min(left, right, out) {
        out._x = Math.min(left._x, right._x);
        out._y = Math.min(left._y, right._y);
        out._z = Math.min(left._z, right._z);
        out._w = Math.min(left._w, right._w);
        out._onValueChanged && out._onValueChanged();
      };
      Vector42.negate = function negate(a, out) {
        out._x = -a._x;
        out._y = -a._y;
        out._z = -a._z;
        out._w = -a._w;
        out._onValueChanged && out._onValueChanged();
      };
      Vector42.normalize = function normalize(a, out) {
        var _x = a._x, _y = a._y, _z = a._z, _w = a._w;
        var len = Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
        if (len > MathUtil.zeroTolerance) {
          len = 1 / len;
          out._x = _x * len;
          out._y = _y * len;
          out._z = _z * len;
          out._w = _w * len;
          out._onValueChanged && out._onValueChanged();
        }
      };
      Vector42.scale = function scale(a, s, out) {
        out._x = a._x * s;
        out._y = a._y * s;
        out._z = a._z * s;
        out._w = a._w * s;
        out._onValueChanged && out._onValueChanged();
      };
      Vector42.transform = function transform(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z, _w = v._w;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8] + _w * e[12];
        out._y = _x * e[1] + _y * e[5] + _z * e[9] + _w * e[13];
        out._z = _x * e[2] + _y * e[6] + _z * e[10] + _w * e[14];
        out._w = _x * e[3] + _y * e[7] + _z * e[11] + _w * e[15];
        out._onValueChanged && out._onValueChanged();
      };
      Vector42.transformByQuat = function transformByQuat(v, q, out) {
        var x = v._x, y = v._y, z = v._z, w = v._w;
        var qx = q._x;
        var qy = q._y;
        var qz = q._z;
        var qw = q._w;
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        out._x = ix * qw - iw * qx - iy * qz + iz * qy;
        out._y = iy * qw - iw * qy - iz * qx + ix * qz;
        out._z = iz * qw - iw * qz - ix * qy + iy * qx;
        out._w = w;
        out._onValueChanged && out._onValueChanged();
      };
      function Vector42(x, y, z, w) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (w === void 0) {
          w = 0;
        }
        this._x = void 0;
        this._y = void 0;
        this._z = void 0;
        this._w = void 0;
        this._onValueChanged = null;
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
      }
      var _proto = Vector42.prototype;
      _proto.set = function set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.add = function add(right) {
        this._x += right._x;
        this._y += right._y;
        this._z += right._z;
        this._w += right._w;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.subtract = function subtract(right) {
        this._x -= right._x;
        this._y -= right._y;
        this._z -= right._z;
        this._w -= right._w;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.multiply = function multiply(right) {
        this._x *= right._x;
        this._y *= right._y;
        this._z *= right._z;
        this._w *= right._w;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.divide = function divide(right) {
        this._x /= right._x;
        this._y /= right._y;
        this._z /= right._z;
        this._w /= right._w;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.length = function length2() {
        var _x = this._x, _y = this._y, _z = this._z, _w = this._w;
        return Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
      };
      _proto.lengthSquared = function lengthSquared() {
        var _x = this._x, _y = this._y, _z = this._z, _w = this._w;
        return _x * _x + _y * _y + _z * _z + _w * _w;
      };
      _proto.negate = function negate() {
        this._x = -this._x;
        this._y = -this._y;
        this._z = -this._z;
        this._w = -this._w;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.normalize = function normalize() {
        Vector42.normalize(this, this);
        return this;
      };
      _proto.scale = function scale(s) {
        this._x *= s;
        this._y *= s;
        this._z *= s;
        this._w *= s;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.clone = function clone() {
        var ret = new Vector42(this._x, this._y, this._z, this._w);
        return ret;
      };
      _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._z = source.z;
        this._w = source.w;
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onValueChanged && this._onValueChanged();
        return this;
      };
      _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) {
          outOffset = 0;
        }
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
        out[outOffset + 2] = this._z;
        out[outOffset + 3] = this._w;
      };
      _createClass2(Vector42, [{
        key: "x",
        get: function get() {
          return this._x;
        },
        set: function set(value) {
          this._x = value;
          this._onValueChanged && this._onValueChanged();
        }
      }, {
        key: "y",
        get: function get() {
          return this._y;
        },
        set: function set(value) {
          this._y = value;
          this._onValueChanged && this._onValueChanged();
        }
      }, {
        key: "z",
        get: function get() {
          return this._z;
        },
        set: function set(value) {
          this._z = value;
          this._onValueChanged && this._onValueChanged();
        }
      }, {
        key: "w",
        get: function get() {
          return this._w;
        },
        set: function set(value) {
          this._w = value;
          this._onValueChanged && this._onValueChanged();
        }
      }]);
      return Vector42;
    }();
    Vector4._zero = new Vector4(0, 0, 0, 0);
    Vector4._one = new Vector4(1, 1, 1, 1);
    var Color = /* @__PURE__ */ function() {
      Color2.gammaToLinearSpace = function gammaToLinearSpace(value) {
        if (value <= 0)
          return 0;
        else if (value <= 0.04045)
          return value / 12.92;
        else if (value < 1)
          return Math.pow((value + 0.055) / 1.055, 2.4);
        else
          return Math.pow(value, 2.4);
      };
      Color2.linearToGammaSpace = function linearToGammaSpace(value) {
        if (value <= 0)
          return 0;
        else if (value < 31308e-7)
          return 12.92 * value;
        else if (value < 1)
          return 1.055 * Math.pow(value, 0.41666) - 0.055;
        else
          return Math.pow(value, 0.41666);
      };
      Color2.equals = function equals(left, right) {
        return MathUtil.equals(left.r, right.r) && MathUtil.equals(left.g, right.g) && MathUtil.equals(left.b, right.b) && MathUtil.equals(left.a, right.a);
      };
      Color2.add = function add(left, right, out) {
        out.r = left.r + right.r;
        out.g = left.g + right.g;
        out.b = left.b + right.b;
        out.a = left.a + right.a;
        return out;
      };
      Color2.scale = function scale(left, s, out) {
        out.r = left.r * s;
        out.g = left.g * s;
        out.b = left.b * s;
        out.a = left.a * s;
        return out;
      };
      function Color2(r, g, b, a) {
        if (r === void 0) {
          r = 1;
        }
        if (g === void 0) {
          g = 1;
        }
        if (b === void 0) {
          b = 1;
        }
        if (a === void 0) {
          a = 1;
        }
        this.r = void 0;
        this.g = void 0;
        this.b = void 0;
        this.a = void 0;
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
      }
      var _proto = Color2.prototype;
      _proto.set = function set(r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
        return this;
      };
      _proto.add = function add(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        this.a += color.a;
        return this;
      };
      _proto.scale = function scale(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        this.a *= s;
        return this;
      };
      _proto.clone = function clone() {
        var ret = new Color2(this.r, this.g, this.b, this.a);
        return ret;
      };
      _proto.copyFrom = function copyFrom(source) {
        this.r = source.r;
        this.g = source.g;
        this.b = source.b;
        this.a = source.a;
        return this;
      };
      _proto.toLinear = function toLinear(out) {
        out.r = Color2.gammaToLinearSpace(this.r);
        out.g = Color2.gammaToLinearSpace(this.g);
        out.b = Color2.gammaToLinearSpace(this.b);
        return out;
      };
      _proto.toGamma = function toGamma(out) {
        out.r = Color2.linearToGammaSpace(this.r);
        out.g = Color2.linearToGammaSpace(this.g);
        out.b = Color2.linearToGammaSpace(this.b);
        return out;
      };
      return Color2;
    }();
    var Rect = /* @__PURE__ */ function() {
      function Rect2(x, y, width, height) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (width === void 0) {
          width = 0;
        }
        if (height === void 0) {
          height = 0;
        }
        this.x = void 0;
        this.y = void 0;
        this.width = void 0;
        this.height = void 0;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }
      var _proto = Rect2.prototype;
      _proto.set = function set(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        return this;
      };
      _proto.clone = function clone() {
        return new Rect2(this.x, this.y, this.width, this.height);
      };
      _proto.copyFrom = function copyFrom(source) {
        this.x = source.x;
        this.y = source.y;
        this.width = source.width;
        this.height = source.height;
        return this;
      };
      return Rect2;
    }();
    var SphericalHarmonics3 = /* @__PURE__ */ function() {
      function SphericalHarmonics32() {
        this.coefficients = new Float32Array(27);
      }
      var _proto = SphericalHarmonics32.prototype;
      _proto.addLight = function addLight(direction, color, deltaSolidAngle) {
        color.scale(deltaSolidAngle);
        var coe = this.coefficients;
        var x = direction._x, y = direction._y, z = direction._z;
        var r = color.r, g = color.g, b = color.b;
        var bv0 = 0.282095;
        var bv1 = -0.488603 * y;
        var bv2 = 0.488603 * z;
        var bv3 = -0.488603 * x;
        var bv4 = 1.092548 * (x * y);
        var bv5 = -1.092548 * (y * z);
        var bv6 = 0.315392 * (3 * z * z - 1);
        var bv7 = -1.092548 * (x * z);
        var bv8 = 0.546274 * (x * x - y * y);
        coe[0] += r * bv0, coe[1] += g * bv0, coe[2] += b * bv0;
        coe[3] += r * bv1, coe[4] += g * bv1, coe[5] += b * bv1;
        coe[6] += r * bv2, coe[7] += g * bv2, coe[8] += b * bv2;
        coe[9] += r * bv3, coe[10] += g * bv3, coe[11] += b * bv3;
        coe[12] += r * bv4, coe[13] += g * bv4, coe[14] += b * bv4;
        coe[15] += r * bv5, coe[16] += g * bv5, coe[17] += b * bv5;
        coe[18] += r * bv6, coe[19] += g * bv6, coe[20] += b * bv6;
        coe[21] += r * bv7, coe[22] += g * bv7, coe[23] += b * bv7;
        coe[24] += r * bv8, coe[25] += g * bv8, coe[26] += b * bv8;
      };
      _proto.evaluate = function evaluate(direction, out) {
        var coe = this.coefficients;
        var x = direction._x, y = direction._y, z = direction._z;
        var bv0 = 0.886227;
        var bv1 = -1.023327 * y;
        var bv2 = 1.023327 * z;
        var bv3 = -1.023327 * x;
        var bv4 = 0.858086 * y * x;
        var bv5 = -0.858086 * y * z;
        var bv6 = 0.247708 * (3 * z * z - 1);
        var bv7 = -0.858086 * z * x;
        var bv8 = 0.429042 * (x * x - y * y);
        var r = coe[0] * bv0;
        var g = coe[1] * bv0;
        var b = coe[2] * bv0;
        r += coe[3] * bv1 + coe[6] * bv2 + coe[9] * bv3;
        g += coe[4] * bv1 + coe[7] * bv2 + coe[10] * bv3;
        b += coe[5] * bv1 + coe[8] * bv2 + coe[11] * bv3;
        r += coe[12] * bv4 + coe[15] * bv5 + coe[18] * bv6 + coe[21] * bv7 + coe[24] * bv8;
        g += coe[13] * bv4 + coe[16] * bv5 + coe[19] * bv6 + coe[22] * bv7 + coe[25] * bv8;
        b += coe[14] * bv4 + coe[17] * bv5 + coe[20] * bv6 + coe[23] * bv7 + coe[26] * bv8;
        out.set(r, g, b, 1);
        return out;
      };
      _proto.scale = function scale(s) {
        var src = this.coefficients;
        src[0] *= s, src[1] *= s, src[2] *= s;
        src[3] *= s, src[4] *= s, src[5] *= s;
        src[6] *= s, src[7] *= s, src[8] *= s;
        src[9] *= s, src[10] *= s, src[11] *= s;
        src[12] *= s, src[13] *= s, src[14] *= s;
        src[15] *= s, src[16] *= s, src[17] *= s;
        src[18] *= s, src[19] *= s, src[20] *= s;
        src[21] *= s, src[22] *= s, src[23] *= s;
        src[24] *= s, src[25] *= s, src[26] *= s;
      };
      _proto.clone = function clone() {
        var sh = new SphericalHarmonics32();
        sh.copyFrom(this);
        return sh;
      };
      _proto.copyFrom = function copyFrom(source) {
        source.copyToArray(this.coefficients);
        return this;
      };
      _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var s = this.coefficients;
        s[0] = array[offset], s[1] = array[1 + offset], s[2] = array[2 + offset];
        s[3] = array[3 + offset], s[4] = array[4 + offset], s[5] = array[5 + offset];
        s[6] = array[6 + offset], s[7] = array[7 + offset], s[8] = array[8 + offset];
        s[9] = array[9 + offset], s[10] = array[10 + offset], s[11] = array[11 + offset];
        s[12] = array[12 + offset], s[13] = array[13 + offset], s[14] = array[14 + offset];
        s[15] = array[15 + offset], s[16] = array[16 + offset], s[17] = array[17 + offset];
        s[18] = array[18 + offset], s[19] = array[19 + offset], s[20] = array[20 + offset];
        s[21] = array[21 + offset], s[22] = array[22 + offset], s[23] = array[23 + offset];
        s[24] = array[24 + offset], s[25] = array[25 + offset], s[26] = array[26 + offset];
      };
      _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) {
          outOffset = 0;
        }
        var s = this.coefficients;
        out[0 + outOffset] = s[0], out[1 + outOffset] = s[1], out[2 + outOffset] = s[2];
        out[3 + outOffset] = s[3], out[4 + outOffset] = s[4], out[5 + outOffset] = s[5];
        out[6 + outOffset] = s[6], out[7 + outOffset] = s[7], out[8 + outOffset] = s[8];
        out[9 + outOffset] = s[9], out[10 + outOffset] = s[10], out[11 + outOffset] = s[11];
        out[12 + outOffset] = s[12], out[13 + outOffset] = s[13], out[14 + outOffset] = s[14];
        out[15 + outOffset] = s[15], out[16 + outOffset] = s[16], out[17 + outOffset] = s[17];
        out[18 + outOffset] = s[18], out[19 + outOffset] = s[19], out[20 + outOffset] = s[20];
        out[21 + outOffset] = s[21], out[22 + outOffset] = s[22], out[23 + outOffset] = s[23];
        out[24 + outOffset] = s[24], out[25 + outOffset] = s[25], out[26 + outOffset] = s[26];
      };
      return SphericalHarmonics32;
    }();
    exports3.BoundingBox = BoundingBox;
    exports3.BoundingFrustum = BoundingFrustum;
    exports3.BoundingSphere = BoundingSphere;
    exports3.CollisionUtil = CollisionUtil;
    exports3.Color = Color;
    exports3.MathUtil = MathUtil;
    exports3.Matrix = Matrix;
    exports3.Matrix3x3 = Matrix3x3;
    exports3.Plane = Plane;
    exports3.Quaternion = Quaternion;
    exports3.Ray = Ray;
    exports3.Rect = Rect;
    exports3.SphericalHarmonics3 = SphericalHarmonics3;
    exports3.Vector2 = Vector2;
    exports3.Vector3 = Vector3;
    exports3.Vector4 = Vector4;
  })(miniprogram$8);
  (function(exports3) {
    Object.defineProperty(exports3, "__esModule", { value: true });
    var miniprogramAdapter2 = require$$0__default.default;
    var miniprogram2 = miniprogram$8;
    function ownKeys2(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread22(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
          _defineProperty2(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperties2(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties2(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose2(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf2(o, p) {
      _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf2(o, p);
    }
    function _isNativeReflectConstruct2() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct2(Parent, args, Class) {
      if (_isNativeReflectConstruct2()) {
        _construct2 = Reflect.construct.bind();
      } else {
        _construct2 = function _construct3(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf2(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct2.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct2(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf2(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _unsupportedIterableToArray2(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray2(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray2(o, minLen);
    }
    function _arrayLikeToArray2(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _createForOfIteratorHelperLoose2(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it)
        return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        return function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor)
        return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach(function(key) {
        desc[key] = descriptor[key];
      });
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      if ("value" in desc || desc.initializer) {
        desc.writable = true;
      }
      desc = decorators.slice().reverse().reduce(function(desc2, decorator) {
        return decorator(target, property, desc2) || desc2;
      }, desc);
      if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (desc.initializer === void 0) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    var Util = {
      isArray: "isArray" in Array ? Array.isArray : function(value) {
        return toString.call(value) === "[object Array]";
      },
      isArrayLike: function isArrayLike(x) {
        return !!x && typeof x.length === "number" && typeof x !== "function";
      },
      clone: function clone(obj) {
        if (typeof obj !== "object" || obj === null) {
          return obj;
        }
        var rst;
        if (Util.isArrayLike(obj)) {
          rst = obj.slice();
          for (var i = 0, l = obj.length; i < l; i++) {
            rst[i] = Util.clone(obj[i]);
          }
        } else {
          rst = {};
          for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
              rst[k] = Util.clone(obj[k]);
            }
          }
        }
        return rst;
      },
      downloadBlob: function downloadBlob(blob, fileName) {
        if (fileName === void 0) {
          fileName = "";
        }
        var url = miniprogramAdapter2.window.URL.createObjectURL(blob);
        var a = miniprogramAdapter2.document.createElement("a");
        miniprogramAdapter2.document.body.appendChild(a);
        a.style.display = "none";
        a.href = url;
        a.download = fileName;
        a.addEventListener("click", function() {
          if (a.parentElement) {
            a.parentElement.removeChild(a);
          }
        });
        a.click();
        miniprogramAdapter2.window.URL.revokeObjectURL(url);
      }
    };
    function removeFromArray2(array, item) {
      var index = array.indexOf(item);
      if (index < 0) {
        return false;
      }
      var last = array.length - 1;
      if (index !== last) {
        var end = array[last];
        array[index] = end;
      }
      array.length--;
      return true;
    }
    function ObjectValues(obj) {
      return Object.keys(obj).map(function(key) {
        return obj[key];
      });
    }
    var Utils = /* @__PURE__ */ function() {
      function Utils2() {
      }
      Utils2._reflectGet = function _reflectGet(target, path) {
        var pathArr = this._stringToPath(path);
        var object = target;
        var index = 0;
        var length2 = pathArr.length;
        while (object != null && index < length2) {
          object = object[pathArr[index++]];
        }
        return index && index == length2 ? object : void 0;
      };
      Utils2._stringToPath = function _stringToPath(string) {
        var result = [];
        if (string.charCodeAt(0) === charCodeOfDot) {
          result.push("");
        }
        string.replace(rePropName, function(match, expression, quote, subString) {
          var key = match;
          if (quote) {
            key = subString.replace(reEscapeChar, "$1");
          } else if (expression) {
            key = expression.trim();
          }
          result.push(key);
        });
        return result;
      };
      return Utils2;
    }();
    var charCodeOfDot = ".".charCodeAt(0);
    var reEscapeChar = /\\(\\)?/g;
    var rePropName = RegExp(
      `[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`,
      "g"
    );
    exports3.AssetPromiseStatus = void 0;
    (function(AssetPromiseStatus) {
      AssetPromiseStatus[AssetPromiseStatus["Success"] = 0] = "Success";
      AssetPromiseStatus[AssetPromiseStatus["Pending"] = 1] = "Pending";
      AssetPromiseStatus[AssetPromiseStatus["Failed"] = 2] = "Failed";
    })(exports3.AssetPromiseStatus || (exports3.AssetPromiseStatus = {}));
    var AssetPromise = /* @__PURE__ */ function(_Promise) {
      _inheritsLoose2(AssetPromise2, _Promise);
      AssetPromise2.all = function all(promises) {
        return new AssetPromise2(function(resolve, reject, setProgress) {
          if (!Array.isArray(promises)) {
            return resolve([promises]);
          }
          var completed = 0;
          var total = promises.length;
          var results = new Array(total);
          promises.forEach(function(value, index) {
            Promise.resolve(value).then(function(result) {
              results[index] = result;
              completed += 1;
              setProgress(completed / total);
              if (completed == total) {
                resolve(results);
              }
            }).catch(function(err) {
              return reject(err);
            });
          });
        });
      };
      var _proto = AssetPromise2.prototype;
      _proto.onProgress = function onProgress(callback) {
        this._listeners.add(callback);
        return this;
      };
      _proto.cancel = function cancel() {
        if (this._status !== exports3.AssetPromiseStatus.Pending) {
          return this;
        }
        this._reject("Promise Canceled");
        return this;
      };
      function AssetPromise2(executor) {
        var _this;
        var newReject;
        var setProgress = function setProgress2(progress) {
          if (progress <= _this._progress) {
            return;
          }
          _this._progress = progress;
          for (var _iterator = _createForOfIteratorHelperLoose2(_this._listeners), _step; !(_step = _iterator()).done; ) {
            var listener = _step.value;
            listener(progress);
          }
        };
        _this = _Promise.call(this, function(resolve, reject) {
          newReject = function newReject2(reason) {
            Promise.resolve().then(function() {
              _this._status = exports3.AssetPromiseStatus.Failed;
              reject(reason);
            });
          };
          executor(function(value) {
            Promise.resolve().then(function() {
              setProgress(1);
              _this._status = exports3.AssetPromiseStatus.Success;
              resolve(value);
            });
          }, newReject, function(progress) {
            Promise.resolve().then(function() {
              setProgress(progress);
            });
          });
        }) || this;
        _this._status = void 0;
        _this._progress = void 0;
        _this._reject = void 0;
        _this._listeners = void 0;
        _this._reject = newReject;
        _this._listeners = /* @__PURE__ */ new Set();
        _this._progress = 0;
        _this._status = exports3.AssetPromiseStatus.Pending;
        return _this;
      }
      _createClass2(AssetPromise2, [{
        key: "status",
        get: function get() {
          return this._status;
        }
      }, {
        key: "progress",
        get: function get() {
          return this._progress;
        }
      }]);
      return AssetPromise2;
    }(/* @__PURE__ */ _wrapNativeSuper(Promise));
    var ResourceManager = /* @__PURE__ */ function() {
      ResourceManager2._addLoader = function _addLoader(type, loader, extNames) {
        this._loaders[type] = loader;
        for (var i = 0, len = extNames.length; i < len; i++) {
          this._extTypeMapping[extNames[i]] = type;
        }
      };
      ResourceManager2._getTypeByUrl = function _getTypeByUrl(url) {
        var path = url.split("?")[0];
        return this._extTypeMapping[path.substring(path.lastIndexOf(".") + 1)];
      };
      function ResourceManager2(engine) {
        this.engine = engine;
        this.retryCount = 1;
        this.retryInterval = 0;
        this.timeout = Infinity;
        this._objectPool = /* @__PURE__ */ Object.create(null);
        this._editorResourceConfig = /* @__PURE__ */ Object.create(null);
        this._virtualPathMap = /* @__PURE__ */ Object.create(null);
        this._assetPool = /* @__PURE__ */ Object.create(null);
        this._assetUrlPool = /* @__PURE__ */ Object.create(null);
        this._refObjectPool = /* @__PURE__ */ Object.create(null);
        this._loadingPromises = {};
      }
      var _proto = ResourceManager2.prototype;
      _proto.load = function load(assetInfo) {
        var _this = this;
        if (!Array.isArray(assetInfo)) {
          return this._loadSingleItem(assetInfo);
        }
        var promises = assetInfo.map(function(item) {
          return _this._loadSingleItem(item);
        });
        return AssetPromise.all(promises);
      };
      _proto.cancelNotLoaded = function cancelNotLoaded(url) {
        var _this2 = this;
        if (!url) {
          ObjectValues(this._loadingPromises).forEach(function(promise) {
            promise.cancel();
          });
        } else if (typeof url === "string") {
          var _this$_loadingPromise;
          (_this$_loadingPromise = this._loadingPromises[url]) === null || _this$_loadingPromise === void 0 ? void 0 : _this$_loadingPromise.cancel();
        } else {
          url.forEach(function(p) {
            var _this2$_loadingPromis;
            (_this2$_loadingPromis = _this2._loadingPromises[p]) === null || _this2$_loadingPromis === void 0 ? void 0 : _this2$_loadingPromis.cancel();
          });
        }
      };
      _proto.gc = function gc() {
        this._gc(false);
      };
      _proto.getAssetPath = function getAssetPath(instanceId) {
        return this._assetPool[instanceId];
      };
      _proto.getResourceByRef = function getResourceByRef(ref) {
        var refId = ref.refId, key = ref.key, isClone = ref.isClone;
        var obj = this._objectPool[refId];
        var promise = obj ? Promise.resolve(obj) : this.load({
          type: this._editorResourceConfig[refId].type,
          url: this._editorResourceConfig[refId].path
        });
        return promise.then(function(res) {
          return key ? Utils._reflectGet(res, key) : res;
        }).then(function(item) {
          return isClone ? item.clone() : item;
        });
      };
      _proto.initVirtualResources = function initVirtualResources(config) {
        var _this3 = this;
        config.forEach(function(element) {
          _this3._virtualPathMap[element.virtualPath] = element.path;
          _this3._editorResourceConfig[element.id] = element;
        });
      };
      _proto._addAsset = function _addAsset(path, asset) {
        this._assetPool[asset.instanceId] = path;
        this._assetUrlPool[path] = asset;
      };
      _proto._deleteAsset = function _deleteAsset(asset) {
        var id = asset.instanceId;
        var path = this._assetPool[id];
        if (path) {
          delete this._assetPool[id];
          delete this._assetUrlPool[path];
        }
      };
      _proto._addRefObject = function _addRefObject(id, asset) {
        this._refObjectPool[id] = asset;
      };
      _proto._deleteRefObject = function _deleteRefObject(id) {
        delete this._refObjectPool[id];
      };
      _proto._destroy = function _destroy() {
        this.cancelNotLoaded();
        this._gc(true);
        this._assetPool = null;
        this._assetUrlPool = null;
        this._refObjectPool = null;
        this._loadingPromises = null;
      };
      _proto._assignDefaultOptions = function _assignDefaultOptions(assetInfo) {
        var _assetInfo$type, _assetInfo$retryCount, _assetInfo$timeout, _assetInfo$retryInter, _assetInfo$url;
        assetInfo.type = (_assetInfo$type = assetInfo.type) != null ? _assetInfo$type : ResourceManager2._getTypeByUrl(assetInfo.url);
        if (assetInfo.type === void 0) {
          throw "asset type should be specified: " + assetInfo.url;
        }
        assetInfo.retryCount = (_assetInfo$retryCount = assetInfo.retryCount) != null ? _assetInfo$retryCount : this.retryCount;
        assetInfo.timeout = (_assetInfo$timeout = assetInfo.timeout) != null ? _assetInfo$timeout : this.timeout;
        assetInfo.retryInterval = (_assetInfo$retryInter = assetInfo.retryInterval) != null ? _assetInfo$retryInter : this.retryInterval;
        assetInfo.url = (_assetInfo$url = assetInfo.url) != null ? _assetInfo$url : assetInfo.urls.join(",");
        return assetInfo;
      };
      _proto._loadSingleItem = function _loadSingleItem(item) {
        var _this4 = this;
        var info2 = this._assignDefaultOptions(typeof item === "string" ? {
          url: item
        } : item);
        var infoUrl = info2.url;
        var url = this._virtualPathMap[infoUrl] ? this._virtualPathMap[infoUrl] : infoUrl;
        if (this._assetUrlPool[url]) {
          return new AssetPromise(function(resolve) {
            resolve(_this4._assetUrlPool[url]);
          });
        }
        if (this._loadingPromises[url]) {
          return this._loadingPromises[info2.url];
        }
        var loader = ResourceManager2._loaders[info2.type];
        if (!loader) {
          throw "loader not found: " + info2.type;
        }
        info2.url = url;
        var promise = loader.load(info2, this);
        this._loadingPromises[url] = promise;
        promise.then(function(res) {
          if (loader.useCache)
            _this4._addAsset(url, res);
          if (_this4._loadingPromises) {
            delete _this4._loadingPromises[url];
          }
        }).catch(function(err) {
          if (_this4._loadingPromises) {
            delete _this4._loadingPromises[url];
          }
          return Promise.reject(err);
        });
        return promise;
      };
      _proto._gc = function _gc(forceDestroy) {
        var objects = ObjectValues(this._refObjectPool);
        for (var i = 0, len = objects.length; i < len; i++) {
          if (!objects[i].isGCIgnored || forceDestroy) {
            objects[i].destroy();
          }
        }
      };
      return ResourceManager2;
    }();
    ResourceManager._loaders = {};
    ResourceManager._extTypeMapping = {};
    function resourceLoader(assetType, extnames, useCache) {
      if (useCache === void 0) {
        useCache = true;
      }
      return function(Target) {
        var loader = new Target(useCache);
        ResourceManager._addLoader(assetType, loader, extnames);
      };
    }
    var Event = /* @__PURE__ */ function() {
      function Event2(type, target, data, bubbles) {
        if (target === void 0) {
          target = null;
        }
        if (data === void 0) {
          data = {};
        }
        if (bubbles === void 0) {
          bubbles = true;
        }
        this.data = void 0;
        this._timeStamp = void 0;
        this._target = void 0;
        this._currentTarget = void 0;
        this._bubbles = void 0;
        this._propagationStopped = void 0;
        this._type = void 0;
        this._timeStamp = new Date().getTime();
        this._target = target;
        this.data = data;
        this._currentTarget = null;
        this._bubbles = bubbles;
        this._propagationStopped = false;
        this._type = type;
      }
      var _proto = Event2.prototype;
      _proto.stopPropagation = function stopPropagation() {
        this._propagationStopped = true;
      };
      _createClass2(Event2, [{
        key: "propagationStopped",
        get: function get() {
          return this._propagationStopped;
        }
      }, {
        key: "target",
        get: function get() {
          return this._target;
        },
        set: function set(t) {
          this._target = t;
        }
      }, {
        key: "timeStamp",
        get: function get() {
          return this._timeStamp;
        }
      }, {
        key: "currentTarget",
        get: function get() {
          return this._currentTarget;
        },
        set: function set(t) {
          this._currentTarget = t;
        }
      }, {
        key: "bubbles",
        get: function get() {
          return this._bubbles;
        }
      }, {
        key: "type",
        get: function get() {
          return this._type;
        }
      }]);
      return Event2;
    }();
    var CloneMode;
    (function(CloneMode2) {
      CloneMode2[CloneMode2["Ignore"] = 0] = "Ignore";
      CloneMode2[CloneMode2["Assignment"] = 1] = "Assignment";
      CloneMode2[CloneMode2["Shallow"] = 2] = "Shallow";
      CloneMode2[CloneMode2["Deep"] = 3] = "Deep";
    })(CloneMode || (CloneMode = {}));
    function ignoreClone(target, propertyKey) {
      CloneManager.registerCloneMode(target, propertyKey, CloneMode.Ignore);
    }
    function assignmentClone(target, propertyKey) {
      CloneManager.registerCloneMode(target, propertyKey, CloneMode.Assignment);
    }
    function shallowClone(target, propertyKey) {
      CloneManager.registerCloneMode(target, propertyKey, CloneMode.Shallow);
    }
    function deepClone(target, propertyKey) {
      CloneManager.registerCloneMode(target, propertyKey, CloneMode.Deep);
    }
    var CloneManager = /* @__PURE__ */ function() {
      function CloneManager2() {
      }
      CloneManager2.registerCloneMode = function registerCloneMode(target, propertyKey, mode) {
        var targetMap = CloneManager2._subCloneModeMap.get(target.constructor);
        if (!targetMap) {
          targetMap = /* @__PURE__ */ Object.create(null);
          CloneManager2._subCloneModeMap.set(target.constructor, targetMap);
        }
        targetMap[propertyKey] = mode;
      };
      CloneManager2.getCloneMode = function getCloneMode(type) {
        var cloneModes = CloneManager2._cloneModeMap.get(type);
        if (!cloneModes) {
          cloneModes = /* @__PURE__ */ Object.create(null);
          CloneManager2._cloneModeMap.set(type, cloneModes);
          var objectType = CloneManager2._objectType;
          var cloneModeMap = CloneManager2._subCloneModeMap;
          while (type !== objectType) {
            var subCloneModes = cloneModeMap.get(type);
            if (subCloneModes) {
              _extends(cloneModes, subCloneModes);
            }
            type = Object.getPrototypeOf(type);
          }
        }
        return cloneModes;
      };
      CloneManager2.deepCloneObject = function deepCloneObject(source, target) {
        var type = source.constructor;
        switch (type) {
          case Uint8Array:
          case Uint16Array:
          case Uint32Array:
          case Int8Array:
          case Int16Array:
          case Int32Array:
          case Float32Array:
          case Float64Array:
            target.set(source);
            break;
          case Array:
            for (var i = 0, n = source.length; i < n; i++) {
              CloneManager2._deepCloneObjectItem(source, target, i);
            }
            break;
          default:
            var customSource = source;
            if (customSource.clone && customSource.cloneTo) {
              customSource.cloneTo(target);
            } else {
              var keys = Object.keys(source);
              for (var _i = 0, _n = keys.length; _i < _n; _i++) {
                CloneManager2._deepCloneObjectItem(source, target, keys[_i]);
              }
            }
        }
      };
      CloneManager2._deepCloneObjectItem = function _deepCloneObjectItem(source, target, k) {
        var sourceItem = source[k];
        if (sourceItem instanceof Object) {
          var itemType = sourceItem.constructor;
          switch (itemType) {
            case Uint8Array:
            case Uint16Array:
            case Uint32Array:
            case Int8Array:
            case Int16Array:
            case Int32Array:
            case Float32Array:
            case Float64Array:
              var sourceTypeArrayItem = sourceItem;
              var targetTypeArrayItem = target[k];
              if (targetTypeArrayItem == null) {
                target[k] = sourceTypeArrayItem.slice();
              } else {
                targetTypeArrayItem.set(sourceTypeArrayItem);
              }
              break;
            case Array:
              var sourceArrayItem = sourceItem;
              var targetArrayItem = target[k];
              if (targetArrayItem == null) {
                target[k] = new Array(sourceArrayItem.length);
              } else {
                targetArrayItem.length = sourceArrayItem.length;
              }
              CloneManager2.deepCloneObject(sourceArrayItem, targetArrayItem);
              break;
            default:
              if (sourceItem.clone && sourceItem.cloneTo) {
                var sourceCustomItem = sourceItem;
                var targetCustomItem = target[k];
                if (targetCustomItem) {
                  sourceCustomItem.cloneTo(targetCustomItem);
                } else {
                  target[k] = sourceCustomItem.clone();
                }
              } else {
                var targetItem = target[k];
                targetItem == null && (target[k] = targetItem = new sourceItem.constructor());
                CloneManager2.deepCloneObject(sourceItem, targetItem);
                break;
              }
          }
        } else {
          target[k] = sourceItem;
        }
      };
      return CloneManager2;
    }();
    CloneManager._subCloneModeMap = /* @__PURE__ */ new Map();
    CloneManager._cloneModeMap = /* @__PURE__ */ new Map();
    CloneManager._objectType = Object.getPrototypeOf(Object);
    var _class$g2, _descriptor$d;
    var EventDispatcher = (_class$g2 = /* @__PURE__ */ function() {
      function EventDispatcher2() {
        _initializerDefineProperty(this, "_evts", _descriptor$d, this);
        this._evtCount = 0;
      }
      var _proto = EventDispatcher2.prototype;
      _proto.hasEvent = function hasEvent(event) {
        return this._evts[event] != null;
      };
      _proto.eventNames = function eventNames() {
        if (this._evtCount === 0)
          return [];
        return Object.keys(this._evts);
      };
      _proto.listenerCount = function listenerCount(event) {
        var listeners = this._evts[event];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      _proto.dispatch = function dispatch(event, data) {
        if (!this._evts[event]) {
          return false;
        }
        var listeners = this._evts[event];
        if (listeners.fn) {
          if (listeners.once)
            this.removeEventListener(event, listeners.fn);
          listeners.fn(data);
        } else {
          var l = listeners.length;
          for (var i = 0; i < l; i++) {
            if (listeners[i].once)
              this.removeEventListener(event, listeners[i].fn);
            listeners[i].fn(data);
          }
        }
        return true;
      };
      _proto.on = function on(event, fn) {
        return this.addEventListener(event, fn);
      };
      _proto.once = function once(event, fn) {
        return this.addEventListener(event, fn, true);
      };
      _proto.addEventListener = function addEventListener(event, fn, once) {
        var listener = {
          fn,
          once
        };
        var events = this._evts;
        if (!events[event]) {
          events[event] = listener;
          this._evtCount++;
        } else if (!events[event].fn) {
          events[event].push(listener);
        } else {
          events[event] = [events[event], listener];
        }
        return this;
      };
      _proto.off = function off(event, fn) {
        if (!this._evts[event])
          return this;
        if (!fn) {
          this._clearEvent(event);
          return this;
        }
        var listeners = this._evts[event];
        if (listeners.fn && listeners.fn === fn) {
          this._clearEvent(event);
        } else {
          var index = listeners.indexOf(fn);
          if (index > -1) {
            var temp = listeners[listeners.length - 1];
            listeners[index] = temp;
            listeners.length--;
            if (listeners.length === 1) {
              this._evts[event] = listeners[0];
            }
          }
        }
        return this;
      };
      _proto.removeEventListener = function removeEventListener(event, fn) {
        return this.off(event, fn);
      };
      _proto.removeAllEventListeners = function removeAllEventListeners(event) {
        if (event) {
          if (this._evts[event])
            this._clearEvent(event);
        } else {
          this._evts = /* @__PURE__ */ Object.create(null);
          this._evtCount = 0;
        }
      };
      _proto.trigger = function trigger(e) {
        this.dispatch(e.type, e.data);
      };
      _proto._clearEvent = function _clearEvent(event) {
        if (--this._evtCount === 0) {
          this._evts = /* @__PURE__ */ Object.create(null);
        } else {
          delete this._evts[event];
        }
      };
      return EventDispatcher2;
    }(), _descriptor$d = _applyDecoratedDescriptor(_class$g2.prototype, "_evts", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return /* @__PURE__ */ Object.create(null);
      }
    }), _class$g2);
    var noop = function noop2(message) {
    };
    var debug = console.log.bind(console);
    var info = console.info.bind(console);
    var warn = console.warn.bind(console);
    var error = console.error.bind(console);
    var Logger = {
      debug: noop,
      info: noop,
      warn: noop,
      error: noop,
      isEnabled: false,
      enable: function enable() {
        this.debug = debug;
        this.info = info;
        this.warn = warn;
        this.error = error;
        this.isEnabled = true;
      },
      disable: function disable() {
        this.debug = noop;
        this.info = noop;
        this.warn = noop;
        this.error = noop;
        this.isEnabled = false;
      }
    };
    var Time = /* @__PURE__ */ function() {
      function Time2() {
        this._clock = void 0;
        this._timeScale = void 0;
        this._deltaTime = void 0;
        this._startTime = void 0;
        this._lastTickTime = void 0;
        this._clock = miniprogramAdapter2.performance ? miniprogramAdapter2.performance : Date;
        this._timeScale = 1;
        this._deltaTime = 1e-4;
        var now = this._clock.now();
        this._startTime = now;
        this._lastTickTime = now;
      }
      var _proto = Time2.prototype;
      _proto.reset = function reset() {
        this._lastTickTime = this._clock.now();
      };
      _proto.tick = function tick() {
        var now = this.nowTime;
        this._deltaTime = (now - this._lastTickTime) * this._timeScale;
        this._lastTickTime = now;
      };
      _createClass2(Time2, [{
        key: "nowTime",
        get: function get() {
          return this._clock.now();
        }
      }, {
        key: "deltaTime",
        get: function get() {
          return this._deltaTime;
        }
      }, {
        key: "timeScale",
        get: function get() {
          return this._timeScale;
        },
        set: function set(s) {
          this._timeScale = s;
        }
      }, {
        key: "unscaledDeltaTime",
        get: function get() {
          return this._deltaTime / this._timeScale;
        }
      }, {
        key: "timeSinceStartup",
        get: function get() {
          return this.nowTime - this._startTime;
        }
      }]);
      return Time2;
    }();
    var _class$f2, _descriptor$c, _descriptor2$b, _class2$c;
    var EngineObject = (_class$f2 = (_class2$c = /* @__PURE__ */ function() {
      function EngineObject2(engine) {
        _initializerDefineProperty(this, "instanceId", _descriptor$c, this);
        _initializerDefineProperty(this, "_engine", _descriptor2$b, this);
        this._destroyed = false;
        this._engine = engine;
      }
      var _proto = EngineObject2.prototype;
      _proto.destroy = function destroy() {
        var _this$_engine$resourc;
        if (this._destroyed)
          return;
        (_this$_engine$resourc = this._engine.resourceManager) === null || _this$_engine$resourc === void 0 ? void 0 : _this$_engine$resourc._deleteAsset(this);
        this._destroyed = true;
      };
      _createClass2(EngineObject2, [{
        key: "engine",
        get: function get() {
          return this._engine;
        }
      }, {
        key: "destroyed",
        get: function get() {
          return this._destroyed;
        }
      }]);
      return EngineObject2;
    }(), _class2$c._instanceIdCounter = 0, _class2$c), _descriptor$c = _applyDecoratedDescriptor(_class$f2.prototype, "instanceId", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return ++EngineObject._instanceIdCounter;
      }
    }), _descriptor2$b = _applyDecoratedDescriptor(_class$f2.prototype, "_engine", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class$f2);
    exports3.DataType = void 0;
    (function(DataType) {
      DataType[DataType["FLOAT"] = 5126] = "FLOAT";
      DataType[DataType["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
      DataType[DataType["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
      DataType[DataType["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
      DataType[DataType["INT"] = 5124] = "INT";
      DataType[DataType["INT_VEC2"] = 35667] = "INT_VEC2";
      DataType[DataType["INT_VEC3"] = 35668] = "INT_VEC3";
      DataType[DataType["INT_VEC4"] = 35669] = "INT_VEC4";
      DataType[DataType["BOOL"] = 35670] = "BOOL";
      DataType[DataType["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
      DataType[DataType["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
      DataType[DataType["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
      DataType[DataType["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
      DataType[DataType["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
      DataType[DataType["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
      DataType[DataType["FLOAT_ARRAY"] = 35677] = "FLOAT_ARRAY";
      DataType[DataType["FLOAT_VEC2_ARRAY"] = 1e5] = "FLOAT_VEC2_ARRAY";
      DataType[DataType["FLOAT_VEC3_ARRAY"] = 100001] = "FLOAT_VEC3_ARRAY";
      DataType[DataType["FLOAT_VEC4_ARRAY"] = 100002] = "FLOAT_VEC4_ARRAY";
      DataType[DataType["INT_ARRAY"] = 100003] = "INT_ARRAY";
      DataType[DataType["INT_VEC2_ARRAY"] = 100004] = "INT_VEC2_ARRAY";
      DataType[DataType["INT_VEC3_ARRAY"] = 100005] = "INT_VEC3_ARRAY";
      DataType[DataType["INT_VEC4_ARRAY"] = 100006] = "INT_VEC4_ARRAY";
      DataType[DataType["FLOAT_MAT2_ARRAY"] = 100007] = "FLOAT_MAT2_ARRAY";
      DataType[DataType["FLOAT_MAT3_ARRAY"] = 100008] = "FLOAT_MAT3_ARRAY";
      DataType[DataType["FLOAT_MAT4_ARRAY"] = 100009] = "FLOAT_MAT4_ARRAY";
      DataType[DataType["SAMPLER_2D_ARRAY"] = 100010] = "SAMPLER_2D_ARRAY";
      DataType[DataType["SAMPLER_CUBE_ARRAY"] = 100011] = "SAMPLER_CUBE_ARRAY";
      DataType[DataType["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
      DataType[DataType["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
      DataType[DataType["BYTE"] = 5120] = "BYTE";
      DataType[DataType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      DataType[DataType["SHORT"] = 5122] = "SHORT";
      DataType[DataType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      DataType[DataType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    })(exports3.DataType || (exports3.DataType = {}));
    exports3.GLCapabilityType = void 0;
    (function(GLCapabilityType) {
      GLCapabilityType["shaderVertexID"] = "shaderVertexID";
      GLCapabilityType["standardDerivatives"] = "OES_standard_derivatives";
      GLCapabilityType["shaderTextureLod"] = "EXT_shader_texture_lod";
      GLCapabilityType["elementIndexUint"] = "OES_element_index_uint";
      GLCapabilityType["depthTexture"] = "WEBGL_depth_texture";
      GLCapabilityType["drawBuffers"] = "WEBGL_draw_buffers";
      GLCapabilityType["vertexArrayObject"] = "OES_vertex_array_object";
      GLCapabilityType["instancedArrays"] = "ANGLE_instanced_arrays";
      GLCapabilityType["multipleSample"] = "multipleSampleOnlySupportedInWebGL2";
      GLCapabilityType["textureFloat"] = "OES_texture_float";
      GLCapabilityType["textureFloatLinear"] = "OES_texture_float_linear";
      GLCapabilityType["textureHalfFloat"] = "OES_texture_half_float";
      GLCapabilityType["textureHalfFloatLinear"] = "OES_texture_half_float_linear";
      GLCapabilityType["WEBGL_colorBufferFloat"] = "WEBGL_color_buffer_float";
      GLCapabilityType["colorBufferFloat"] = "EXT_color_buffer_float";
      GLCapabilityType["colorBufferHalfFloat"] = "EXT_color_buffer_half_float";
      GLCapabilityType["textureFilterAnisotropic"] = "EXT_texture_filter_anisotropic";
      GLCapabilityType["blendMinMax"] = "EXT_blend_minmax";
      GLCapabilityType["astc"] = "WEBGL_compressed_texture_astc";
      GLCapabilityType["astc_webkit"] = "WEBKIT_WEBGL_compressed_texture_astc";
      GLCapabilityType["etc"] = "WEBGL_compressed_texture_etc";
      GLCapabilityType["etc_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc";
      GLCapabilityType["etc1"] = "WEBGL_compressed_texture_etc1";
      GLCapabilityType["etc1_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc1";
      GLCapabilityType["pvrtc"] = "WEBGL_compressed_texture_pvrtc";
      GLCapabilityType["pvrtc_webkit"] = "WEBKIT_WEBGL_compressed_texture_pvrtc";
      GLCapabilityType["s3tc"] = "WEBGL_compressed_texture_s3tc";
      GLCapabilityType["s3tc_webkit"] = "WEBKIT_WEBGL_compressed_texture_s3tc";
    })(exports3.GLCapabilityType || (exports3.GLCapabilityType = {}));
    var DisorderedArray2 = /* @__PURE__ */ function() {
      function DisorderedArray3(count) {
        if (count === void 0) {
          count = 0;
        }
        this._elements = void 0;
        this.length = 0;
        this._elements = new Array(count);
      }
      var _proto = DisorderedArray3.prototype;
      _proto.add = function add(element) {
        if (this.length === this._elements.length)
          this._elements.push(element);
        else
          this._elements[this.length] = element;
        this.length++;
      };
      _proto.delete = function _delete(element) {
        var index = this._elements.indexOf(element);
        this.deleteByIndex(index);
      };
      _proto.get = function get(index) {
        if (index >= this.length) {
          throw "Index is out of range.";
        }
        return this._elements[index];
      };
      _proto.deleteByIndex = function deleteByIndex(index) {
        var elements = this._elements;
        var end = null;
        var lastIndex = this.length - 1;
        if (index !== lastIndex) {
          end = elements[lastIndex];
          elements[index] = end;
        }
        this.length--;
        return end;
      };
      _proto.garbageCollection = function garbageCollection() {
        this._elements.length = this.length;
      };
      return DisorderedArray3;
    }();
    var ShaderMacroCollection = /* @__PURE__ */ function() {
      function ShaderMacroCollection2() {
        this._mask = [];
        this._length = 0;
      }
      ShaderMacroCollection2.unionCollection = function unionCollection(left, right, out) {
        var outMask = out._mask;
        var minSize, maxSize;
        var minMask, maxMask;
        if (left._length < right._length) {
          minSize = left._length;
          maxSize = right._length;
          minMask = left._mask;
          maxMask = right._mask;
        } else {
          minSize = right._length;
          maxSize = left._length;
          minMask = right._mask;
          maxMask = left._mask;
        }
        var i = 0;
        outMask.length < maxSize && (outMask.length = maxSize);
        for (; i < minSize; i++) {
          outMask[i] = minMask[i] | maxMask[i];
        }
        for (; i < maxSize; i++) {
          outMask[i] = maxMask[i];
        }
        out._length = maxSize;
      };
      var _proto = ShaderMacroCollection2.prototype;
      _proto.enable = function enable(macro) {
        var index = macro._maskIndex;
        var size = index + 1;
        var mask = this._mask;
        var maskStart = this._length;
        if (maskStart < size) {
          mask.length < size && (mask.length = size);
          for (; maskStart < index; maskStart++) {
            mask[maskStart] = 0;
          }
          mask[index] = macro._maskValue;
          this._length = size;
        } else {
          mask[index] |= macro._maskValue;
        }
      };
      _proto.disable = function disable(macro) {
        var index = macro._maskIndex;
        var mask = this._mask;
        var endIndex = this._length - 1;
        if (index > endIndex) {
          return;
        }
        var newValue = mask[index] & ~macro._maskValue;
        if (index == endIndex && newValue === 0) {
          this._length--;
        } else {
          mask[index] = newValue;
        }
      };
      _proto.unionCollection = function unionCollection(macroCollection) {
        var addMask = macroCollection._mask;
        var addSize = macroCollection._length;
        var mask = this._mask;
        var maskSize = this._length;
        if (maskSize < addSize) {
          mask.length < addSize && (mask.length = addSize);
          var i = 0;
          for (; i < maskSize; i++) {
            mask[i] |= addMask[i];
          }
          for (; i < addSize; i++) {
            mask[i] = addMask[i];
          }
          this._length = addSize;
        } else {
          for (var _i = 0; _i < addSize; _i++) {
            mask[_i] |= addMask[_i];
          }
        }
      };
      _proto.complementaryCollection = function complementaryCollection(macroCollection) {
        var removeMask = macroCollection._mask;
        var mask = this._mask;
        var endIndex = this._length - 1;
        var i = Math.min(macroCollection._length - 1, endIndex);
        for (; i >= 0; i--) {
          var newValue = mask[i] & ~removeMask[i];
          if (i == endIndex && newValue === 0) {
            endIndex--;
            this._length--;
          } else {
            mask[i] = newValue;
          }
        }
      };
      _proto.intersectionCollection = function intersectionCollection(macroCollection) {
        var unionMask = macroCollection._mask;
        var mask = this._mask;
        for (var i = this._length - 1; i >= 0; i--) {
          var value = mask[i] & unionMask[i];
          if (value == 0 && i == this._length - 1) {
            this._length--;
          } else {
            mask[i] = value;
          }
        }
      };
      _proto.isEnable = function isEnable(macro) {
        var index = macro._maskIndex;
        if (index >= this._length) {
          return false;
        }
        return (this._mask[index] & macro._maskValue) !== 0;
      };
      _proto.clear = function clear() {
        this._length = 0;
      };
      return ShaderMacroCollection2;
    }();
    var ComponentsManager = /* @__PURE__ */ function() {
      function ComponentsManager2() {
        this._onStartScripts = new DisorderedArray2();
        this._onUpdateScripts = new DisorderedArray2();
        this._onLateUpdateScripts = new DisorderedArray2();
        this._onPhysicsUpdateScripts = new DisorderedArray2();
        this._disableScripts = [];
        this._destroyScripts = [];
        this._onUpdateAnimations = new DisorderedArray2();
        this._renderers = new DisorderedArray2();
        this._onUpdateRenderers = new DisorderedArray2();
        this._componentsContainerPool = [];
      }
      var _proto = ComponentsManager2.prototype;
      _proto.addRenderer = function addRenderer(renderer) {
        renderer._rendererIndex = this._renderers.length;
        this._renderers.add(renderer);
      };
      _proto.removeRenderer = function removeRenderer(renderer) {
        var replaced = this._renderers.deleteByIndex(renderer._rendererIndex);
        replaced && (replaced._rendererIndex = renderer._rendererIndex);
        renderer._rendererIndex = -1;
      };
      _proto.addOnStartScript = function addOnStartScript(script) {
        script._onStartIndex = this._onStartScripts.length;
        this._onStartScripts.add(script);
      };
      _proto.removeOnStartScript = function removeOnStartScript(script) {
        var replaced = this._onStartScripts.deleteByIndex(script._onStartIndex);
        replaced && (replaced._onStartIndex = script._onStartIndex);
        script._onStartIndex = -1;
      };
      _proto.addOnUpdateScript = function addOnUpdateScript(script) {
        script._onUpdateIndex = this._onUpdateScripts.length;
        this._onUpdateScripts.add(script);
      };
      _proto.removeOnUpdateScript = function removeOnUpdateScript(script) {
        var replaced = this._onUpdateScripts.deleteByIndex(script._onUpdateIndex);
        replaced && (replaced._onUpdateIndex = script._onUpdateIndex);
        script._onUpdateIndex = -1;
      };
      _proto.addOnLateUpdateScript = function addOnLateUpdateScript(script) {
        script._onLateUpdateIndex = this._onLateUpdateScripts.length;
        this._onLateUpdateScripts.add(script);
      };
      _proto.removeOnLateUpdateScript = function removeOnLateUpdateScript(script) {
        var replaced = this._onLateUpdateScripts.deleteByIndex(script._onLateUpdateIndex);
        replaced && (replaced._onLateUpdateIndex = script._onLateUpdateIndex);
        script._onLateUpdateIndex = -1;
      };
      _proto.addOnPhysicsUpdateScript = function addOnPhysicsUpdateScript(script) {
        script._onPhysicsUpdateIndex = this._onPhysicsUpdateScripts.length;
        this._onPhysicsUpdateScripts.add(script);
      };
      _proto.removeOnPhysicsUpdateScript = function removeOnPhysicsUpdateScript(script) {
        var replaced = this._onPhysicsUpdateScripts.deleteByIndex(script._onPhysicsUpdateIndex);
        replaced && (replaced._onPhysicsUpdateIndex = script._onPhysicsUpdateIndex);
        script._onPhysicsUpdateIndex = -1;
      };
      _proto.addOnUpdateAnimations = function addOnUpdateAnimations(animation) {
        animation._onUpdateIndex = this._onUpdateAnimations.length;
        this._onUpdateAnimations.add(animation);
      };
      _proto.removeOnUpdateAnimations = function removeOnUpdateAnimations(animation) {
        var replaced = this._onUpdateAnimations.deleteByIndex(animation._onUpdateIndex);
        replaced && (replaced._onUpdateIndex = animation._onUpdateIndex);
        animation._onUpdateIndex = -1;
      };
      _proto.addOnUpdateRenderers = function addOnUpdateRenderers(renderer) {
        renderer._onUpdateIndex = this._onUpdateRenderers.length;
        this._onUpdateRenderers.add(renderer);
      };
      _proto.removeOnUpdateRenderers = function removeOnUpdateRenderers(renderer) {
        var replaced = this._onUpdateRenderers.deleteByIndex(renderer._onUpdateIndex);
        replaced && (replaced._onUpdateIndex = renderer._onUpdateIndex);
        renderer._onUpdateIndex = -1;
      };
      _proto.addDisableScript = function addDisableScript(component) {
        this._disableScripts.push(component);
      };
      _proto.addDestroyScript = function addDestroyScript(component) {
        this._destroyScripts.push(component);
      };
      _proto.callScriptOnStart = function callScriptOnStart() {
        var onStartScripts = this._onStartScripts;
        if (onStartScripts.length > 0) {
          var elements = onStartScripts._elements;
          for (var i = 0; i < onStartScripts.length; i++) {
            var script = elements[i];
            if (!script._waitHandlingInValid) {
              script._started = true;
              script._onStartIndex = -1;
              script.onStart();
            }
          }
          onStartScripts.length = 0;
        }
      };
      _proto.callScriptOnUpdate = function callScriptOnUpdate(deltaTime) {
        var elements = this._onUpdateScripts._elements;
        for (var i = this._onUpdateScripts.length - 1; i >= 0; --i) {
          var element = elements[i];
          if (!element._waitHandlingInValid && element._started) {
            element.onUpdate(deltaTime);
          }
        }
      };
      _proto.callScriptOnLateUpdate = function callScriptOnLateUpdate(deltaTime) {
        var elements = this._onLateUpdateScripts._elements;
        for (var i = this._onLateUpdateScripts.length - 1; i >= 0; --i) {
          var element = elements[i];
          if (!element._waitHandlingInValid && element._started) {
            element.onLateUpdate(deltaTime);
          }
        }
      };
      _proto.callScriptOnPhysicsUpdate = function callScriptOnPhysicsUpdate() {
        var elements = this._onPhysicsUpdateScripts._elements;
        for (var i = this._onPhysicsUpdateScripts.length - 1; i >= 0; --i) {
          var element = elements[i];
          if (!element._waitHandlingInValid && element._started) {
            element.onPhysicsUpdate();
          }
        }
      };
      _proto.callAnimationUpdate = function callAnimationUpdate(deltaTime) {
        var elements = this._onUpdateAnimations._elements;
        for (var i = this._onUpdateAnimations.length - 1; i >= 0; --i) {
          elements[i].update(deltaTime);
        }
      };
      _proto.callRendererOnUpdate = function callRendererOnUpdate(deltaTime) {
        var elements = this._onUpdateRenderers._elements;
        for (var i = this._onUpdateRenderers.length - 1; i >= 0; --i) {
          elements[i].update(deltaTime);
        }
      };
      _proto.callRender = function callRender(context) {
        var camera = context._camera;
        var elements = this._renderers._elements;
        for (var i = this._renderers.length - 1; i >= 0; --i) {
          var element = elements[i];
          if (!(camera.cullingMask & element._entity.layer)) {
            continue;
          }
          if (camera.enableFrustumCulling) {
            element.isCulled = !camera._frustum.intersectsBox(element.bounds);
            if (element.isCulled) {
              continue;
            }
          }
          var transform = camera.entity.transform;
          var position = transform.worldPosition;
          var center = element.bounds.getCenter(ComponentsManager2._tempVector0);
          if (camera.isOrthographic) {
            var forward = transform.getWorldForward(ComponentsManager2._tempVector1);
            miniprogram2.Vector3.subtract(center, position, center);
            element._distanceForSort = miniprogram2.Vector3.dot(center, forward);
          } else {
            element._distanceForSort = miniprogram2.Vector3.distanceSquared(center, position);
          }
          element._updateShaderData(context);
          element._render(camera);
          ShaderMacroCollection.unionCollection(camera._globalShaderMacro, element.shaderData._macroCollection, element._globalShaderMacro);
        }
      };
      _proto.handlingInvalidScripts = function handlingInvalidScripts() {
        var disableScripts = this._disableScripts, destroyScripts = this._destroyScripts;
        var length2 = disableScripts.length;
        if (length2 > 0) {
          for (var i = length2 - 1; i >= 0; i--) {
            var disableScript = disableScripts[i];
            disableScript._waitHandlingInValid && disableScript._handlingInValid();
          }
          disableScripts.length = 0;
        }
        length2 = destroyScripts.length;
        if (length2 > 0) {
          for (var _i = length2 - 1; _i >= 0; _i--) {
            destroyScripts[_i].onDestroy();
          }
          destroyScripts.length = 0;
        }
      };
      _proto.callCameraOnBeginRender = function callCameraOnBeginRender(camera) {
        var scripts = camera.entity._scripts;
        for (var i = scripts.length - 1; i >= 0; --i) {
          var script = scripts.get(i);
          script._waitHandlingInValid || script.onBeginRender(camera);
        }
      };
      _proto.callCameraOnEndRender = function callCameraOnEndRender(camera) {
        var scripts = camera.entity._scripts;
        for (var i = scripts.length - 1; i >= 0; --i) {
          var script = scripts.get(i);
          script._waitHandlingInValid || script.onEndRender(camera);
        }
      };
      _proto.getActiveChangedTempList = function getActiveChangedTempList() {
        return this._componentsContainerPool.length ? this._componentsContainerPool.pop() : [];
      };
      _proto.putActiveChangedTempList = function putActiveChangedTempList(componentContainer) {
        componentContainer.length = 0;
        this._componentsContainerPool.push(componentContainer);
      };
      return ComponentsManager2;
    }();
    ComponentsManager._tempVector0 = new miniprogram2.Vector3();
    ComponentsManager._tempVector1 = new miniprogram2.Vector3();
    var ComponentCloner = /* @__PURE__ */ function() {
      function ComponentCloner2() {
      }
      ComponentCloner2.cloneComponent = function cloneComponent(source, target) {
        var cloneModes = CloneManager.getCloneMode(source.constructor);
        var keys = Object.keys(source);
        for (var i = 0, n = keys.length; i < n; i++) {
          var k = keys[i];
          var cloneMode = cloneModes[k];
          switch (cloneMode) {
            case void 0:
            case CloneMode.Assignment:
              target[k] = source[k];
              break;
            case CloneMode.Shallow:
              var sourcePropS = source[k];
              if (sourcePropS instanceof Object) {
                var tarProp = target[k];
                tarProp == null && (tarProp = target[k] = sourcePropS.constructor());
                _extends(tarProp, sourcePropS);
              } else {
                target[k] = sourcePropS;
              }
              break;
            case CloneMode.Deep:
              var sourcePropD = source[k];
              if (sourcePropD instanceof Object) {
                var _tarProp = target[k];
                _tarProp == null && (_tarProp = target[k] = sourcePropD.constructor());
                CloneManager.deepCloneObject(sourcePropD, _tarProp);
              } else {
                target[k] = sourcePropD;
              }
              break;
          }
        }
        if (source._cloneTo) {
          source._cloneTo(target);
        }
      };
      return ComponentCloner2;
    }();
    var ComponentsDependencies = /* @__PURE__ */ function() {
      ComponentsDependencies2._register = function _register(currentComponent, dependentComponent) {
        this._addDependency(currentComponent, dependentComponent, this._dependenciesMap);
        this._addDependency(dependentComponent, currentComponent, this._invDependenciesMap);
      };
      ComponentsDependencies2._addCheck = function _addCheck(entity, type) {
        var dependentComponents2 = ComponentsDependencies2._dependenciesMap.get(type);
        if (dependentComponents2) {
          for (var i = 0, n = dependentComponents2.length; i < n; i++) {
            var dependentComponent = dependentComponents2[i];
            if (!entity.getComponent(dependentComponent)) {
              entity.addComponent(dependentComponent);
            }
          }
        }
      };
      ComponentsDependencies2._removeCheck = function _removeCheck(entity, type) {
        var invDependencies = ComponentsDependencies2._invDependenciesMap.get(type);
        if (invDependencies) {
          for (var i = 0, len = invDependencies.length; i < len; i++) {
            if (entity.getComponent(invDependencies[i])) {
              throw "you should remove " + invDependencies[i] + " before adding " + type;
            }
          }
        }
      };
      ComponentsDependencies2._addDependency = function _addDependency(currentComponent, dependentComponent, map) {
        var components = map.get(currentComponent);
        if (!components) {
          components = [];
          map.set(currentComponent, components);
        }
        if (components.indexOf(dependentComponent) === -1) {
          components.push(dependentComponent);
        }
      };
      function ComponentsDependencies2() {
      }
      return ComponentsDependencies2;
    }();
    ComponentsDependencies._dependenciesMap = /* @__PURE__ */ new Map();
    ComponentsDependencies._invDependenciesMap = /* @__PURE__ */ new Map();
    function dependentComponents() {
      for (var _len = arguments.length, components = new Array(_len), _key = 0; _key < _len; _key++) {
        components[_key] = arguments[_key];
      }
      return function(target) {
        components.forEach(function(component) {
          return ComponentsDependencies._register(target, component);
        });
      };
    }
    exports3.Layer = void 0;
    (function(Layer) {
      Layer[Layer["Layer0"] = 1] = "Layer0";
      Layer[Layer["Layer1"] = 2] = "Layer1";
      Layer[Layer["Layer2"] = 4] = "Layer2";
      Layer[Layer["Layer3"] = 8] = "Layer3";
      Layer[Layer["Layer4"] = 16] = "Layer4";
      Layer[Layer["Layer5"] = 32] = "Layer5";
      Layer[Layer["Layer6"] = 64] = "Layer6";
      Layer[Layer["Layer7"] = 128] = "Layer7";
      Layer[Layer["Layer8"] = 256] = "Layer8";
      Layer[Layer["Layer9"] = 512] = "Layer9";
      Layer[Layer["Layer10"] = 1024] = "Layer10";
      Layer[Layer["Layer11"] = 2048] = "Layer11";
      Layer[Layer["Layer12"] = 4096] = "Layer12";
      Layer[Layer["Layer13"] = 8192] = "Layer13";
      Layer[Layer["Layer14"] = 16384] = "Layer14";
      Layer[Layer["Layer15"] = 32768] = "Layer15";
      Layer[Layer["Layer16"] = 65536] = "Layer16";
      Layer[Layer["Layer17"] = 131072] = "Layer17";
      Layer[Layer["Layer18"] = 262144] = "Layer18";
      Layer[Layer["Layer19"] = 524288] = "Layer19";
      Layer[Layer["Layer20"] = 1048576] = "Layer20";
      Layer[Layer["Layer21"] = 2097152] = "Layer21";
      Layer[Layer["Layer22"] = 4194304] = "Layer22";
      Layer[Layer["Layer23"] = 8388608] = "Layer23";
      Layer[Layer["Layer24"] = 16777216] = "Layer24";
      Layer[Layer["Layer25"] = 33554432] = "Layer25";
      Layer[Layer["Layer26"] = 67108864] = "Layer26";
      Layer[Layer["Layer27"] = 134217728] = "Layer27";
      Layer[Layer["Layer28"] = 268435456] = "Layer28";
      Layer[Layer["Layer29"] = 536870912] = "Layer29";
      Layer[Layer["Layer30"] = 1073741824] = "Layer30";
      Layer[Layer["Layer31"] = 2147483648] = "Layer31";
      Layer[Layer["Everything"] = 4294967295] = "Everything";
      Layer[Layer["Nothing"] = 0] = "Nothing";
    })(exports3.Layer || (exports3.Layer = {}));
    var UpdateFlag = /* @__PURE__ */ function() {
      function UpdateFlag2() {
        this._flagManagers = [];
      }
      var _proto = UpdateFlag2.prototype;
      _proto.clearFromManagers = function clearFromManagers() {
        this._removeFromManagers();
        this._flagManagers.length = 0;
      };
      _proto.destroy = function destroy() {
        this._removeFromManagers();
        this._flagManagers = null;
      };
      _proto._removeFromManagers = function _removeFromManagers() {
        var flagManagers = this._flagManagers;
        for (var i = 0, n = flagManagers.length; i < n; i++) {
          removeFromArray2(flagManagers[i]._updateFlags, this);
        }
      };
      return UpdateFlag2;
    }();
    var BoolUpdateFlag = /* @__PURE__ */ function(_UpdateFlag) {
      _inheritsLoose2(BoolUpdateFlag2, _UpdateFlag);
      function BoolUpdateFlag2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _UpdateFlag.call.apply(_UpdateFlag, [this].concat(args)) || this;
        _this.flag = true;
        return _this;
      }
      var _proto = BoolUpdateFlag2.prototype;
      _proto.dispatch = function dispatch() {
        this.flag = true;
      };
      return BoolUpdateFlag2;
    }(UpdateFlag);
    var _class$e2, _descriptor$b, _descriptor2$a, _descriptor3$9, _descriptor4$9, _descriptor5$9;
    var Component = (_class$e2 = /* @__PURE__ */ function(_EngineObject) {
      _inheritsLoose2(Component2, _EngineObject);
      function Component2(entity) {
        var _this;
        _this = _EngineObject.call(this, entity.engine) || this;
        _initializerDefineProperty(_this, "_entity", _descriptor$b, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_awoken", _descriptor2$a, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_destroyed", _descriptor3$9, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_phasedActive", _descriptor4$9, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_enabled", _descriptor5$9, _assertThisInitialized(_this));
        _this._entity = entity;
        return _this;
      }
      var _proto = Component2.prototype;
      _proto.destroy = function destroy() {
        if (this._destroyed) {
          return;
        }
        this._entity._removeComponent(this);
        if (this._entity.isActiveInHierarchy) {
          this._enabled && this._onDisable();
        }
        this._destroyed = true;
        this._onDestroy();
      };
      _proto._onAwake = function _onAwake() {
      };
      _proto._onEnable = function _onEnable() {
      };
      _proto._onDisable = function _onDisable() {
      };
      _proto._onDestroy = function _onDestroy() {
      };
      _proto._setActive = function _setActive(value) {
        var entity = this._entity;
        if (value) {
          if (!this._awoken && entity._isActiveInHierarchy) {
            this._awoken = true;
            this._onAwake();
          }
          if (!this._phasedActive && entity._isActiveInHierarchy && this._enabled) {
            this._phasedActive = true;
            this._onEnable();
          }
        } else {
          if (this._phasedActive && !(entity._isActiveInHierarchy && this._enabled)) {
            this._phasedActive = false;
            this._onDisable();
          }
        }
      };
      _createClass2(Component2, [{
        key: "enabled",
        get: function get() {
          return this._enabled;
        },
        set: function set(value) {
          if (value !== this._enabled) {
            this._enabled = value;
            if (this._entity.isActiveInHierarchy) {
              if (value) {
                this._phasedActive = true;
                this._onEnable();
              } else {
                this._phasedActive = false;
                this._onDisable();
              }
            }
          }
        }
      }, {
        key: "destroyed",
        get: function get() {
          return this._destroyed;
        }
      }, {
        key: "entity",
        get: function get() {
          return this._entity;
        }
      }, {
        key: "scene",
        get: function get() {
          return this._entity.scene;
        }
      }]);
      return Component2;
    }(EngineObject), _descriptor$b = _applyDecoratedDescriptor(_class$e2.prototype, "_entity", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor2$a = _applyDecoratedDescriptor(_class$e2.prototype, "_awoken", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor3$9 = _applyDecoratedDescriptor(_class$e2.prototype, "_destroyed", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor4$9 = _applyDecoratedDescriptor(_class$e2.prototype, "_phasedActive", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor5$9 = _applyDecoratedDescriptor(_class$e2.prototype, "_enabled", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return true;
      }
    }), _class$e2);
    var ListenerUpdateFlag = /* @__PURE__ */ function(_UpdateFlag) {
      _inheritsLoose2(ListenerUpdateFlag2, _UpdateFlag);
      function ListenerUpdateFlag2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _UpdateFlag.call.apply(_UpdateFlag, [this].concat(args)) || this;
        _this.listener = void 0;
        return _this;
      }
      var _proto = ListenerUpdateFlag2.prototype;
      _proto.dispatch = function dispatch(param) {
        this.listener && this.listener(param);
      };
      return ListenerUpdateFlag2;
    }(UpdateFlag);
    var UpdateFlagManager = /* @__PURE__ */ function() {
      function UpdateFlagManager2() {
        this._updateFlags = [];
      }
      var _proto = UpdateFlagManager2.prototype;
      _proto.createFlag = function createFlag(type) {
        var flag = new type();
        this.addFlag(flag);
        return flag;
      };
      _proto.addFlag = function addFlag(flag) {
        this._updateFlags.push(flag);
        flag._flagManagers.push(this);
      };
      _proto.dispatch = function dispatch(param) {
        var updateFlags = this._updateFlags;
        for (var i = updateFlags.length - 1; i >= 0; i--) {
          updateFlags[i].dispatch(param);
        }
      };
      return UpdateFlagManager2;
    }();
    var _class$d2, _descriptor$a, _descriptor2$9, _descriptor3$8, _descriptor4$8, _descriptor5$8, _descriptor6$8, _descriptor7$8, _descriptor8$8, _descriptor9$7, _descriptor10$4, _descriptor11$4, _descriptor12$4, _descriptor13$3, _class2$b;
    var Transform = (_class$d2 = (_class2$b = /* @__PURE__ */ function(_Component) {
      _inheritsLoose2(Transform2, _Component);
      function Transform2(entity) {
        var _this;
        _this = _Component.call(this, entity) || this;
        _initializerDefineProperty(_this, "_position", _descriptor$a, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_rotation", _descriptor2$9, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_rotationQuaternion", _descriptor3$8, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_scale", _descriptor4$8, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_worldPosition", _descriptor5$8, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_worldRotation", _descriptor6$8, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_worldRotationQuaternion", _descriptor7$8, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_lossyWorldScale", _descriptor8$8, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_localMatrix", _descriptor9$7, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_worldMatrix", _descriptor10$4, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_updateFlagManager", _descriptor11$4, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_isParentDirty", _descriptor12$4, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_parentTransformCache", _descriptor13$3, _assertThisInitialized(_this));
        _this._dirtyFlag = TransformFlag2.WmWpWeWqWs;
        _this._onPositionChanged = _this._onPositionChanged.bind(_assertThisInitialized(_this));
        _this._onWorldPositionChanged = _this._onWorldPositionChanged.bind(_assertThisInitialized(_this));
        _this._onRotationChanged = _this._onRotationChanged.bind(_assertThisInitialized(_this));
        _this._onWorldRotationChanged = _this._onWorldRotationChanged.bind(_assertThisInitialized(_this));
        _this._onRotationQuaternionChanged = _this._onRotationQuaternionChanged.bind(_assertThisInitialized(_this));
        _this._onWorldRotationQuaternionChanged = _this._onWorldRotationQuaternionChanged.bind(_assertThisInitialized(_this));
        _this._onScaleChanged = _this._onScaleChanged.bind(_assertThisInitialized(_this));
        _this._position._onValueChanged = _this._onPositionChanged;
        _this._worldPosition._onValueChanged = _this._onWorldPositionChanged;
        _this._rotation._onValueChanged = _this._onRotationChanged;
        _this._worldRotation._onValueChanged = _this._onWorldRotationChanged;
        _this._rotationQuaternion._onValueChanged = _this._onRotationQuaternionChanged;
        _this._worldRotationQuaternion._onValueChanged = _this._onWorldRotationQuaternionChanged;
        _this._scale._onValueChanged = _this._onScaleChanged;
        return _this;
      }
      var _proto = Transform2.prototype;
      _proto.setPosition = function setPosition(x, y, z) {
        this._position.set(x, y, z);
      };
      _proto.setRotation = function setRotation(x, y, z) {
        this._rotation.set(x, y, z);
      };
      _proto.setRotationQuaternion = function setRotationQuaternion(x, y, z, w) {
        this._rotationQuaternion.set(x, y, z, w);
      };
      _proto.setScale = function setScale(x, y, z) {
        this._scale.set(x, y, z);
      };
      _proto.setWorldPosition = function setWorldPosition(x, y, z) {
        this._worldPosition.set(x, y, z);
      };
      _proto.setWorldRotation = function setWorldRotation(x, y, z) {
        this._worldRotation.set(x, y, z);
      };
      _proto.setWorldRotationQuaternion = function setWorldRotationQuaternion(x, y, z, w) {
        this._worldRotationQuaternion.set(x, y, z, w);
      };
      _proto.getWorldForward = function getWorldForward(forward) {
        var e = this.worldMatrix.elements;
        forward.set(-e[8], -e[9], -e[10]);
        return forward.normalize();
      };
      _proto.getWorldRight = function getWorldRight(right) {
        var e = this.worldMatrix.elements;
        right.set(e[0], e[1], e[2]);
        return right.normalize();
      };
      _proto.getWorldUp = function getWorldUp(up) {
        var e = this.worldMatrix.elements;
        up.set(e[4], e[5], e[6]);
        return up.normalize();
      };
      _proto.translate = function translate(translationOrX, relativeToLocalOrY, z, relativeToLocal) {
        if (typeof translationOrX === "number") {
          var _translate2 = Transform2._tempVec30;
          _translate2.set(translationOrX, relativeToLocalOrY, z);
          this._translate(_translate2, relativeToLocal);
        } else {
          this._translate(translationOrX, relativeToLocalOrY);
        }
      };
      _proto.rotate = function rotate(rotationOrX, relativeToLocalOrY, z, relativeToLocal) {
        if (typeof rotationOrX === "number") {
          this._rotateXYZ(rotationOrX, relativeToLocalOrY, z, relativeToLocal);
        } else {
          this._rotateXYZ(rotationOrX.x, rotationOrX.y, rotationOrX.z, relativeToLocalOrY);
        }
      };
      _proto.rotateByAxis = function rotateByAxis(axis, angle, relativeToLocal) {
        if (relativeToLocal === void 0) {
          relativeToLocal = true;
        }
        var rad = angle * miniprogram2.MathUtil.degreeToRadFactor;
        miniprogram2.Quaternion.rotationAxisAngle(axis, rad, Transform2._tempQuat0);
        this._rotateByQuat(Transform2._tempQuat0, relativeToLocal);
      };
      _proto.lookAt = function lookAt(targetPosition, worldUp) {
        var zAxis = Transform2._tempVec30;
        miniprogram2.Vector3.subtract(this.worldPosition, targetPosition, zAxis);
        var axisLen = zAxis.length();
        if (axisLen <= miniprogram2.MathUtil.zeroTolerance) {
          return;
        }
        zAxis.scale(1 / axisLen);
        var xAxis = Transform2._tempVec31;
        if (worldUp) {
          miniprogram2.Vector3.cross(worldUp, zAxis, xAxis);
        } else {
          xAxis.set(zAxis.z, 0, -zAxis.x);
        }
        axisLen = xAxis.length();
        if (axisLen <= miniprogram2.MathUtil.zeroTolerance) {
          return;
        }
        xAxis.scale(1 / axisLen);
        var yAxis = Transform2._tempVec32;
        miniprogram2.Vector3.cross(zAxis, xAxis, yAxis);
        var rotMat = Transform2._tempMat41;
        var e = rotMat.elements;
        e[0] = xAxis.x, e[1] = xAxis.y, e[2] = xAxis.z;
        e[4] = yAxis.x, e[5] = yAxis.y, e[6] = yAxis.z;
        e[8] = zAxis.x, e[9] = zAxis.y, e[10] = zAxis.z;
        rotMat.getRotation(this._worldRotationQuaternion);
      };
      _proto.registerWorldChangeFlag = function registerWorldChangeFlag() {
        return this._updateFlagManager.createFlag(BoolUpdateFlag);
      };
      _proto._registerWorldChangeListener = function _registerWorldChangeListener() {
        return this._updateFlagManager.createFlag(ListenerUpdateFlag);
      };
      _proto._parentChange = function _parentChange() {
        this._isParentDirty = true;
        this._updateAllWorldFlag();
      };
      _proto._isFrontFaceInvert = function _isFrontFaceInvert() {
        var scale = this.lossyWorldScale;
        var isInvert = scale.x < 0;
        scale.y < 0 && (isInvert = !isInvert);
        scale.z < 0 && (isInvert = !isInvert);
        return isInvert;
      };
      _proto._updateWorldPositionFlag = function _updateWorldPositionFlag() {
        if (!this._isContainDirtyFlags(TransformFlag2.WmWp)) {
          this._worldAssociatedChange(TransformFlag2.WmWp);
          var nodeChildren = this._entity._children;
          for (var i = 0, n = nodeChildren.length; i < n; i++) {
            var _nodeChildren$i$trans;
            (_nodeChildren$i$trans = nodeChildren[i].transform) === null || _nodeChildren$i$trans === void 0 ? void 0 : _nodeChildren$i$trans._updateWorldPositionFlag();
          }
        }
      };
      _proto._updateWorldRotationFlag = function _updateWorldRotationFlag() {
        if (!this._isContainDirtyFlags(TransformFlag2.WmWeWq)) {
          this._worldAssociatedChange(TransformFlag2.WmWeWq);
          var nodeChildren = this._entity._children;
          for (var i = 0, n = nodeChildren.length; i < n; i++) {
            var _nodeChildren$i$trans2;
            (_nodeChildren$i$trans2 = nodeChildren[i].transform) === null || _nodeChildren$i$trans2 === void 0 ? void 0 : _nodeChildren$i$trans2._updateWorldPositionAndRotationFlag();
          }
        }
      };
      _proto._updateWorldPositionAndRotationFlag = function _updateWorldPositionAndRotationFlag() {
        if (!this._isContainDirtyFlags(TransformFlag2.WmWpWeWq)) {
          this._worldAssociatedChange(TransformFlag2.WmWpWeWq);
          var nodeChildren = this._entity._children;
          for (var i = 0, n = nodeChildren.length; i < n; i++) {
            var _nodeChildren$i$trans3;
            (_nodeChildren$i$trans3 = nodeChildren[i].transform) === null || _nodeChildren$i$trans3 === void 0 ? void 0 : _nodeChildren$i$trans3._updateWorldPositionAndRotationFlag();
          }
        }
      };
      _proto._updateWorldScaleFlag = function _updateWorldScaleFlag() {
        if (!this._isContainDirtyFlags(TransformFlag2.WmWs)) {
          this._worldAssociatedChange(TransformFlag2.WmWs);
          var nodeChildren = this._entity._children;
          for (var i = 0, n = nodeChildren.length; i < n; i++) {
            var _nodeChildren$i$trans4;
            (_nodeChildren$i$trans4 = nodeChildren[i].transform) === null || _nodeChildren$i$trans4 === void 0 ? void 0 : _nodeChildren$i$trans4._updateWorldPositionAndScaleFlag();
          }
        }
      };
      _proto._updateWorldPositionAndScaleFlag = function _updateWorldPositionAndScaleFlag() {
        if (!this._isContainDirtyFlags(TransformFlag2.WmWpWs)) {
          this._worldAssociatedChange(TransformFlag2.WmWpWs);
          var nodeChildren = this._entity._children;
          for (var i = 0, n = nodeChildren.length; i < n; i++) {
            var _nodeChildren$i$trans5;
            (_nodeChildren$i$trans5 = nodeChildren[i].transform) === null || _nodeChildren$i$trans5 === void 0 ? void 0 : _nodeChildren$i$trans5._updateWorldPositionAndScaleFlag();
          }
        }
      };
      _proto._updateAllWorldFlag = function _updateAllWorldFlag() {
        if (!this._isContainDirtyFlags(TransformFlag2.WmWpWeWqWs)) {
          this._worldAssociatedChange(TransformFlag2.WmWpWeWqWs);
          var nodeChildren = this._entity._children;
          for (var i = 0, n = nodeChildren.length; i < n; i++) {
            var _nodeChildren$i$trans6;
            (_nodeChildren$i$trans6 = nodeChildren[i].transform) === null || _nodeChildren$i$trans6 === void 0 ? void 0 : _nodeChildren$i$trans6._updateAllWorldFlag();
          }
        }
      };
      _proto._getParentTransform = function _getParentTransform() {
        if (!this._isParentDirty) {
          return this._parentTransformCache;
        }
        var parentCache = null;
        var parent = this._entity.parent;
        while (parent) {
          var transform = parent.transform;
          if (transform) {
            parentCache = transform;
            break;
          } else {
            parent = parent.parent;
          }
        }
        this._parentTransformCache = parentCache;
        this._isParentDirty = false;
        return parentCache;
      };
      _proto._getScaleMatrix = function _getScaleMatrix() {
        var invRotation = Transform2._tempQuat0;
        var invRotationMat = Transform2._tempMat30;
        var worldRotScaMat = Transform2._tempMat31;
        var scaMat = Transform2._tempMat32;
        worldRotScaMat.copyFromMatrix(this.worldMatrix);
        miniprogram2.Quaternion.invert(this.worldRotationQuaternion, invRotation);
        miniprogram2.Matrix3x3.rotationQuaternion(invRotation, invRotationMat);
        miniprogram2.Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat);
        return scaMat;
      };
      _proto._isContainDirtyFlags = function _isContainDirtyFlags(targetDirtyFlags) {
        return (this._dirtyFlag & targetDirtyFlags) === targetDirtyFlags;
      };
      _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
        return (this._dirtyFlag & type) != 0;
      };
      _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
        this._dirtyFlag |= type;
      };
      _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
        this._dirtyFlag &= ~type;
      };
      _proto._worldAssociatedChange = function _worldAssociatedChange(type) {
        this._dirtyFlag |= type;
        this._updateFlagManager.dispatch();
      };
      _proto._rotateByQuat = function _rotateByQuat(rotateQuat, relativeToLocal) {
        if (relativeToLocal) {
          miniprogram2.Quaternion.multiply(this.rotationQuaternion, rotateQuat, this._rotationQuaternion);
        } else {
          miniprogram2.Quaternion.multiply(rotateQuat, this.worldRotationQuaternion, this._worldRotationQuaternion);
        }
      };
      _proto._translate = function _translate(translation, relativeToLocal) {
        if (relativeToLocal === void 0) {
          relativeToLocal = true;
        }
        if (relativeToLocal) {
          var _tempVec30 = Transform2._tempVec30;
          miniprogram2.Vector3.transformByQuat(translation, this.worldRotationQuaternion, _tempVec30);
          this._worldPosition.add(_tempVec30);
        } else {
          this._worldPosition.add(translation);
        }
      };
      _proto._rotateXYZ = function _rotateXYZ(x, y, z, relativeToLocal) {
        if (relativeToLocal === void 0) {
          relativeToLocal = true;
        }
        var radFactor = miniprogram2.MathUtil.degreeToRadFactor;
        var rotQuat = Transform2._tempQuat0;
        miniprogram2.Quaternion.rotationEuler(x * radFactor, y * radFactor, z * radFactor, rotQuat);
        this._rotateByQuat(rotQuat, relativeToLocal);
      };
      _proto._onPositionChanged = function _onPositionChanged() {
        this._setDirtyFlagTrue(TransformFlag2.LocalMatrix);
        this._updateWorldPositionFlag();
      };
      _proto._onWorldPositionChanged = function _onWorldPositionChanged() {
        var worldPosition = this._worldPosition;
        var parent = this._getParentTransform();
        if (parent) {
          miniprogram2.Matrix.invert(parent.worldMatrix, Transform2._tempMat41);
          miniprogram2.Vector3.transformCoordinate(worldPosition, Transform2._tempMat41, this._position);
        } else {
          this._position.copyFrom(worldPosition);
        }
        this._setDirtyFlagFalse(TransformFlag2.WorldPosition);
      };
      _proto._onRotationChanged = function _onRotationChanged() {
        this._setDirtyFlagTrue(TransformFlag2.LocalMatrix | TransformFlag2.LocalQuat);
        this._setDirtyFlagFalse(TransformFlag2.LocalEuler);
        this._updateWorldRotationFlag();
      };
      _proto._onWorldRotationChanged = function _onWorldRotationChanged() {
        var worldRotation = this._worldRotation;
        miniprogram2.Quaternion.rotationEuler(miniprogram2.MathUtil.degreeToRadian(worldRotation.x), miniprogram2.MathUtil.degreeToRadian(worldRotation.y), miniprogram2.MathUtil.degreeToRadian(worldRotation.z), this._worldRotationQuaternion);
        this._setDirtyFlagFalse(TransformFlag2.WorldEuler);
      };
      _proto._onRotationQuaternionChanged = function _onRotationQuaternionChanged() {
        this._setDirtyFlagTrue(TransformFlag2.LocalMatrix | TransformFlag2.LocalEuler);
        this._setDirtyFlagFalse(TransformFlag2.LocalQuat);
        this._updateWorldRotationFlag();
      };
      _proto._onWorldRotationQuaternionChanged = function _onWorldRotationQuaternionChanged() {
        var worldRotationQuaternion = this._worldRotationQuaternion;
        var parent = this._getParentTransform();
        if (parent) {
          var invParentQuaternion = Transform2._tempQuat0;
          miniprogram2.Quaternion.invert(parent.worldRotationQuaternion, invParentQuaternion);
          miniprogram2.Quaternion.multiply(invParentQuaternion, worldRotationQuaternion, this._rotationQuaternion);
        } else {
          this._rotationQuaternion.copyFrom(worldRotationQuaternion);
        }
        this._setDirtyFlagFalse(TransformFlag2.WorldQuat);
      };
      _proto._onScaleChanged = function _onScaleChanged() {
        this._setDirtyFlagTrue(TransformFlag2.LocalMatrix);
        this._updateWorldScaleFlag();
      };
      _createClass2(Transform2, [{
        key: "position",
        get: function get() {
          return this._position;
        },
        set: function set(value) {
          if (this._position !== value) {
            this._position.copyFrom(value);
          }
        }
      }, {
        key: "worldPosition",
        get: function get() {
          var worldPosition = this._worldPosition;
          if (this._isContainDirtyFlag(TransformFlag2.WorldPosition)) {
            worldPosition._onValueChanged = null;
            if (this._getParentTransform()) {
              this.worldMatrix.getTranslation(worldPosition);
            } else {
              worldPosition.copyFrom(this._position);
            }
            worldPosition._onValueChanged = this._onWorldPositionChanged;
            this._setDirtyFlagFalse(TransformFlag2.WorldPosition);
          }
          return worldPosition;
        },
        set: function set(value) {
          if (this._worldPosition !== value) {
            this._worldPosition.copyFrom(value);
          }
        }
      }, {
        key: "rotation",
        get: function get() {
          var rotation = this._rotation;
          if (this._isContainDirtyFlag(TransformFlag2.LocalEuler)) {
            rotation._onValueChanged = null;
            this._rotationQuaternion.toEuler(rotation);
            rotation._onValueChanged = this._onRotationChanged;
            rotation.scale(miniprogram2.MathUtil.radToDegreeFactor);
            this._setDirtyFlagFalse(TransformFlag2.LocalEuler);
          }
          return rotation;
        },
        set: function set(value) {
          if (this._rotation !== value) {
            this._rotation.copyFrom(value);
          }
        }
      }, {
        key: "worldRotation",
        get: function get() {
          var worldRotation = this._worldRotation;
          if (this._isContainDirtyFlag(TransformFlag2.WorldEuler)) {
            worldRotation._onValueChanged = null;
            this.worldRotationQuaternion.toEuler(worldRotation);
            worldRotation.scale(miniprogram2.MathUtil.radToDegreeFactor);
            worldRotation._onValueChanged = this._onWorldRotationChanged;
            this._setDirtyFlagFalse(TransformFlag2.WorldEuler);
          }
          return worldRotation;
        },
        set: function set(value) {
          if (this._worldRotation !== value) {
            this._worldRotation.copyFrom(value);
          }
        }
      }, {
        key: "rotationQuaternion",
        get: function get() {
          var rotationQuaternion = this._rotationQuaternion;
          if (this._isContainDirtyFlag(TransformFlag2.LocalQuat)) {
            rotationQuaternion._onValueChanged = null;
            miniprogram2.Quaternion.rotationEuler(miniprogram2.MathUtil.degreeToRadian(this._rotation.x), miniprogram2.MathUtil.degreeToRadian(this._rotation.y), miniprogram2.MathUtil.degreeToRadian(this._rotation.z), rotationQuaternion);
            rotationQuaternion._onValueChanged = this._onRotationQuaternionChanged;
            this._setDirtyFlagFalse(TransformFlag2.LocalQuat);
          }
          return rotationQuaternion;
        },
        set: function set(value) {
          if (this._rotationQuaternion !== value) {
            if (value.normalized) {
              this._rotationQuaternion.copyFrom(value);
            } else {
              miniprogram2.Quaternion.normalize(value, this._rotationQuaternion);
            }
          } else {
            value.normalized || value.normalize();
          }
        }
      }, {
        key: "worldRotationQuaternion",
        get: function get() {
          var worldRotationQuaternion = this._worldRotationQuaternion;
          if (this._isContainDirtyFlag(TransformFlag2.WorldQuat)) {
            worldRotationQuaternion._onValueChanged = null;
            var parent = this._getParentTransform();
            if (parent != null) {
              miniprogram2.Quaternion.multiply(parent.worldRotationQuaternion, this.rotationQuaternion, worldRotationQuaternion);
            } else {
              worldRotationQuaternion.copyFrom(this.rotationQuaternion);
            }
            worldRotationQuaternion._onValueChanged = this._onWorldRotationQuaternionChanged;
            this._setDirtyFlagFalse(TransformFlag2.WorldQuat);
          }
          return worldRotationQuaternion;
        },
        set: function set(value) {
          if (this._worldRotationQuaternion !== value) {
            if (value.normalized) {
              this._worldRotationQuaternion.copyFrom(value);
            } else {
              miniprogram2.Quaternion.normalize(value, this._worldRotationQuaternion);
            }
          }
          value.normalized || value.normalize();
        }
      }, {
        key: "scale",
        get: function get() {
          return this._scale;
        },
        set: function set(value) {
          if (this._scale !== value) {
            this._scale.copyFrom(value);
          }
        }
      }, {
        key: "lossyWorldScale",
        get: function get() {
          if (this._isContainDirtyFlag(TransformFlag2.WorldScale)) {
            if (this._getParentTransform()) {
              var scaleMat = this._getScaleMatrix();
              var e = scaleMat.elements;
              this._lossyWorldScale.set(e[0], e[4], e[8]);
            } else {
              this._lossyWorldScale.copyFrom(this._scale);
            }
            this._setDirtyFlagFalse(TransformFlag2.WorldScale);
          }
          return this._lossyWorldScale;
        }
      }, {
        key: "localMatrix",
        get: function get() {
          if (this._isContainDirtyFlag(TransformFlag2.LocalMatrix)) {
            miniprogram2.Matrix.affineTransformation(this._scale, this.rotationQuaternion, this._position, this._localMatrix);
            this._setDirtyFlagFalse(TransformFlag2.LocalMatrix);
          }
          return this._localMatrix;
        },
        set: function set(value) {
          if (this._localMatrix !== value) {
            this._localMatrix.copyFrom(value);
          }
          this._localMatrix.decompose(this._position, this._rotationQuaternion, this._scale);
          this._setDirtyFlagTrue(TransformFlag2.LocalEuler);
          this._setDirtyFlagFalse(TransformFlag2.LocalMatrix);
          this._updateAllWorldFlag();
        }
      }, {
        key: "worldMatrix",
        get: function get() {
          if (this._isContainDirtyFlag(TransformFlag2.WorldMatrix)) {
            var parent = this._getParentTransform();
            if (parent) {
              miniprogram2.Matrix.multiply(parent.worldMatrix, this.localMatrix, this._worldMatrix);
            } else {
              this._worldMatrix.copyFrom(this.localMatrix);
            }
            this._setDirtyFlagFalse(TransformFlag2.WorldMatrix);
          }
          return this._worldMatrix;
        },
        set: function set(value) {
          if (this._worldMatrix !== value) {
            this._worldMatrix.copyFrom(value);
          }
          var parent = this._getParentTransform();
          if (parent) {
            miniprogram2.Matrix.invert(parent.worldMatrix, Transform2._tempMat42);
            miniprogram2.Matrix.multiply(Transform2._tempMat42, value, this._localMatrix);
          } else {
            this._localMatrix.copyFrom(value);
          }
          this.localMatrix = this._localMatrix;
          this._setDirtyFlagFalse(TransformFlag2.WorldMatrix);
        }
      }]);
      return Transform2;
    }(Component), _class2$b._tempQuat0 = new miniprogram2.Quaternion(), _class2$b._tempVec30 = new miniprogram2.Vector3(), _class2$b._tempVec31 = new miniprogram2.Vector3(), _class2$b._tempVec32 = new miniprogram2.Vector3(), _class2$b._tempMat30 = new miniprogram2.Matrix3x3(), _class2$b._tempMat31 = new miniprogram2.Matrix3x3(), _class2$b._tempMat32 = new miniprogram2.Matrix3x3(), _class2$b._tempMat41 = new miniprogram2.Matrix(), _class2$b._tempMat42 = new miniprogram2.Matrix(), _class2$b), _descriptor$a = _applyDecoratedDescriptor(_class$d2.prototype, "_position", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Vector3();
      }
    }), _descriptor2$9 = _applyDecoratedDescriptor(_class$d2.prototype, "_rotation", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Vector3();
      }
    }), _descriptor3$8 = _applyDecoratedDescriptor(_class$d2.prototype, "_rotationQuaternion", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Quaternion();
      }
    }), _descriptor4$8 = _applyDecoratedDescriptor(_class$d2.prototype, "_scale", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Vector3(1, 1, 1);
      }
    }), _descriptor5$8 = _applyDecoratedDescriptor(_class$d2.prototype, "_worldPosition", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Vector3();
      }
    }), _descriptor6$8 = _applyDecoratedDescriptor(_class$d2.prototype, "_worldRotation", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Vector3();
      }
    }), _descriptor7$8 = _applyDecoratedDescriptor(_class$d2.prototype, "_worldRotationQuaternion", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Quaternion();
      }
    }), _descriptor8$8 = _applyDecoratedDescriptor(_class$d2.prototype, "_lossyWorldScale", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Vector3(1, 1, 1);
      }
    }), _descriptor9$7 = _applyDecoratedDescriptor(_class$d2.prototype, "_localMatrix", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Matrix();
      }
    }), _descriptor10$4 = _applyDecoratedDescriptor(_class$d2.prototype, "_worldMatrix", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Matrix();
      }
    }), _descriptor11$4 = _applyDecoratedDescriptor(_class$d2.prototype, "_updateFlagManager", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new UpdateFlagManager();
      }
    }), _descriptor12$4 = _applyDecoratedDescriptor(_class$d2.prototype, "_isParentDirty", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return true;
      }
    }), _descriptor13$3 = _applyDecoratedDescriptor(_class$d2.prototype, "_parentTransformCache", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return null;
      }
    }), _class$d2);
    var TransformFlag2;
    (function(TransformFlag3) {
      TransformFlag3[TransformFlag3["LocalEuler"] = 1] = "LocalEuler";
      TransformFlag3[TransformFlag3["LocalQuat"] = 2] = "LocalQuat";
      TransformFlag3[TransformFlag3["WorldPosition"] = 4] = "WorldPosition";
      TransformFlag3[TransformFlag3["WorldEuler"] = 8] = "WorldEuler";
      TransformFlag3[TransformFlag3["WorldQuat"] = 16] = "WorldQuat";
      TransformFlag3[TransformFlag3["WorldScale"] = 32] = "WorldScale";
      TransformFlag3[TransformFlag3["LocalMatrix"] = 64] = "LocalMatrix";
      TransformFlag3[TransformFlag3["WorldMatrix"] = 128] = "WorldMatrix";
      TransformFlag3[TransformFlag3["WmWp"] = 132] = "WmWp";
      TransformFlag3[TransformFlag3["WmWeWq"] = 152] = "WmWeWq";
      TransformFlag3[TransformFlag3["WmWpWeWq"] = 156] = "WmWpWeWq";
      TransformFlag3[TransformFlag3["WmWs"] = 160] = "WmWs";
      TransformFlag3[TransformFlag3["WmWpWs"] = 164] = "WmWpWs";
      TransformFlag3[TransformFlag3["WmWpWeWqWs"] = 188] = "WmWpWeWqWs";
    })(TransformFlag2 || (TransformFlag2 = {}));
    var Entity = /* @__PURE__ */ function(_EngineObject) {
      _inheritsLoose2(Entity2, _EngineObject);
      Entity2._findChildByName = function _findChildByName(root, name) {
        var children = root._children;
        for (var i = children.length - 1; i >= 0; i--) {
          var _child = children[i];
          if (_child.name === name) {
            return _child;
          }
        }
        return null;
      };
      Entity2._traverseSetOwnerScene = function _traverseSetOwnerScene(entity, scene) {
        entity._scene = scene;
        var children = entity._children;
        for (var i = entity.childCount - 1; i >= 0; i--) {
          this._traverseSetOwnerScene(children[i], scene);
        }
      };
      function Entity2(engine, name) {
        var _this;
        _this = _EngineObject.call(this, engine) || this;
        _this.name = void 0;
        _this.layer = exports3.Layer.Layer0;
        _this.transform = void 0;
        _this._isActiveInHierarchy = false;
        _this._components = [];
        _this._scripts = new DisorderedArray2();
        _this._children = [];
        _this._scene = void 0;
        _this._isRoot = false;
        _this._isActive = true;
        _this._siblingIndex = -1;
        _this._parent = null;
        _this._activeChangedComponents = void 0;
        _this._invModelMatrix = new miniprogram2.Matrix();
        _this._inverseWorldMatFlag = void 0;
        _this.name = name;
        _this.transform = _this.addComponent(Transform);
        _this._inverseWorldMatFlag = _this.transform.registerWorldChangeFlag();
        return _this;
      }
      var _proto = Entity2.prototype;
      _proto.addComponent = function addComponent(type) {
        ComponentsDependencies._addCheck(this, type);
        var component = new type(this);
        this._components.push(component);
        component._setActive(true);
        return component;
      };
      _proto.getComponent = function getComponent(type) {
        for (var i = this._components.length - 1; i >= 0; i--) {
          var component = this._components[i];
          if (component instanceof type) {
            return component;
          }
        }
      };
      _proto.getComponents = function getComponents(type, results) {
        results.length = 0;
        for (var i = this._components.length - 1; i >= 0; i--) {
          var component = this._components[i];
          if (component instanceof type) {
            results.push(component);
          }
        }
        return results;
      };
      _proto.getComponentsIncludeChildren = function getComponentsIncludeChildren(type, results) {
        results.length = 0;
        this._getComponentsInChildren(type, results);
        return results;
      };
      _proto.addChild = function addChild(indexOrChild, child) {
        var index;
        if (typeof indexOrChild === "number") {
          index = indexOrChild;
        } else {
          index = void 0;
          child = indexOrChild;
        }
        if (child._isRoot) {
          child._scene._removeFromEntityList(child);
          child._isRoot = false;
          this._addToChildrenList(index, child);
          child._parent = this;
          var newScene = this._scene;
          if (child._scene !== newScene) {
            Entity2._traverseSetOwnerScene(child, newScene);
          }
          if (this._isActiveInHierarchy) {
            !child._isActiveInHierarchy && child._isActive && child._processActive();
          } else {
            child._isActiveInHierarchy && child._processInActive();
          }
          child._setTransformDirty();
        } else {
          child._setParent(this, index);
        }
      };
      _proto.removeChild = function removeChild(child) {
        child._setParent(null);
      };
      _proto.getChild = function getChild(index) {
        return this._children[index];
      };
      _proto.findByName = function findByName(name) {
        var children = this._children;
        var child = Entity2._findChildByName(this, name);
        if (child)
          return child;
        for (var i = children.length - 1; i >= 0; i--) {
          var _child2 = children[i];
          var grandson = _child2.findByName(name);
          if (grandson) {
            return grandson;
          }
        }
        return null;
      };
      _proto.findByPath = function findByPath(path) {
        var splits = path.split("/");
        var entity = this;
        for (var i = 0, length2 = splits.length; i < length2; ++i) {
          var split = splits[i];
          if (split) {
            entity = Entity2._findChildByName(entity, split);
            if (!entity) {
              return null;
            }
          }
        }
        return entity;
      };
      _proto.createChild = function createChild(name) {
        var child = new Entity2(this.engine, name);
        child.layer = this.layer;
        child.parent = this;
        return child;
      };
      _proto.clearChildren = function clearChildren() {
        var children = this._children;
        for (var i = children.length - 1; i >= 0; i--) {
          var _child3 = children[i];
          _child3._parent = null;
          _child3._isActiveInHierarchy && _child3._processInActive();
          Entity2._traverseSetOwnerScene(_child3, null);
        }
        children.length = 0;
      };
      _proto.clone = function clone() {
        var cloneEntity = new Entity2(this._engine, this.name);
        cloneEntity._isActive = this._isActive;
        cloneEntity.transform.localMatrix = this.transform.localMatrix;
        var children = this._children;
        for (var i = 0, len = this._children.length; i < len; i++) {
          var _child4 = children[i];
          cloneEntity.addChild(_child4.clone());
        }
        var components = this._components;
        for (var _i = 0, n = components.length; _i < n; _i++) {
          var sourceComp = components[_i];
          if (!(sourceComp instanceof Transform)) {
            var targetComp = cloneEntity.addComponent(sourceComp.constructor);
            ComponentCloner.cloneComponent(sourceComp, targetComp);
          }
        }
        return cloneEntity;
      };
      _proto.destroy = function destroy() {
        if (this._destroyed) {
          return;
        }
        _EngineObject.prototype.destroy.call(this);
        var components = this._components;
        for (var i = components.length - 1; i >= 0; i--) {
          components[i].destroy();
        }
        this._components.length = 0;
        var children = this._children;
        for (var _i2 = children.length - 1; _i2 >= 0; _i2--) {
          children[_i2].destroy();
        }
        this._children.length = 0;
        if (this._isRoot) {
          this._scene._removeFromEntityList(this);
          this._isRoot = false;
        } else {
          this._removeFromParent();
        }
      };
      _proto._removeComponent = function _removeComponent(component) {
        ComponentsDependencies._removeCheck(this, component.constructor);
        var components = this._components;
        components.splice(components.indexOf(component), 1);
      };
      _proto._addScript = function _addScript(script) {
        script._entityScriptsIndex = this._scripts.length;
        this._scripts.add(script);
      };
      _proto._removeScript = function _removeScript(script) {
        var replaced = this._scripts.deleteByIndex(script._entityScriptsIndex);
        replaced && (replaced._entityScriptsIndex = script._entityScriptsIndex);
        script._entityScriptsIndex = -1;
      };
      _proto._removeFromParent = function _removeFromParent() {
        var oldParent = this._parent;
        if (oldParent != null) {
          var oldSibling = oldParent._children;
          var _index = this._siblingIndex;
          oldSibling.splice(_index, 1);
          for (var n = oldSibling.length; _index < n; _index++) {
            oldSibling[_index]._siblingIndex--;
          }
          this._parent = null;
          this._siblingIndex = -1;
        }
      };
      _proto._processActive = function _processActive() {
        if (this._activeChangedComponents) {
          throw "Note: can't set the 'main inActive entity' active in hierarchy, if the operation is in main inActive entity or it's children script's onDisable Event.";
        }
        this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();
        this._setActiveInHierarchy(this._activeChangedComponents);
        this._setActiveComponents(true);
      };
      _proto._processInActive = function _processInActive() {
        if (this._activeChangedComponents) {
          throw "Note: can't set the 'main active entity' inActive in hierarchy, if the operation is in main active entity or it's children script's onEnable Event.";
        }
        this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();
        this._setInActiveInHierarchy(this._activeChangedComponents);
        this._setActiveComponents(false);
      };
      _proto._addToChildrenList = function _addToChildrenList(index, child) {
        var children = this._children;
        var childCount = children.length;
        if (index === void 0) {
          child._siblingIndex = childCount;
          children.push(child);
        } else {
          if (index < 0 || index > childCount) {
            throw "The index " + index + " is out of child list bounds " + childCount;
          }
          child._siblingIndex = index;
          children.splice(index, 0, child);
          for (var i = index + 1, n = childCount + 1; i < n; i++) {
            children[i]._siblingIndex++;
          }
        }
      };
      _proto._setParent = function _setParent(parent, siblingIndex) {
        var oldParent = this._parent;
        if (parent !== oldParent) {
          this._removeFromParent();
          this._parent = parent;
          if (parent) {
            parent._addToChildrenList(siblingIndex, this);
            var parentScene = parent._scene;
            if (this._scene !== parentScene) {
              Entity2._traverseSetOwnerScene(this, parentScene);
            }
            if (parent._isActiveInHierarchy) {
              !this._isActiveInHierarchy && this._isActive && this._processActive();
            } else {
              this._isActiveInHierarchy && this._processInActive();
            }
          } else {
            this._isActiveInHierarchy && this._processInActive();
            if (oldParent) {
              Entity2._traverseSetOwnerScene(this, null);
            }
          }
          this._setTransformDirty();
        }
      };
      _proto._getComponentsInChildren = function _getComponentsInChildren(type, results) {
        for (var i = this._components.length - 1; i >= 0; i--) {
          var component = this._components[i];
          if (component instanceof type) {
            results.push(component);
          }
        }
        for (var _i3 = this._children.length - 1; _i3 >= 0; _i3--) {
          this._children[_i3]._getComponentsInChildren(type, results);
        }
      };
      _proto._setActiveComponents = function _setActiveComponents(isActive) {
        var activeChangedComponents = this._activeChangedComponents;
        for (var i = 0, length2 = activeChangedComponents.length; i < length2; ++i) {
          activeChangedComponents[i]._setActive(isActive);
        }
        this._engine._componentsManager.putActiveChangedTempList(activeChangedComponents);
        this._activeChangedComponents = null;
      };
      _proto._setActiveInHierarchy = function _setActiveInHierarchy(activeChangedComponents) {
        this._isActiveInHierarchy = true;
        var components = this._components;
        for (var i = components.length - 1; i >= 0; i--) {
          var component = components[i];
          (component.enabled || !component._awoken) && activeChangedComponents.push(component);
        }
        var children = this._children;
        for (var _i4 = children.length - 1; _i4 >= 0; _i4--) {
          var _child5 = children[_i4];
          _child5.isActive && _child5._setActiveInHierarchy(activeChangedComponents);
        }
      };
      _proto._setInActiveInHierarchy = function _setInActiveInHierarchy(activeChangedComponents) {
        this._isActiveInHierarchy = false;
        var components = this._components;
        for (var i = components.length - 1; i >= 0; i--) {
          var component = components[i];
          component.enabled && activeChangedComponents.push(component);
        }
        var children = this._children;
        for (var _i5 = children.length - 1; _i5 >= 0; _i5--) {
          var _child6 = children[_i5];
          _child6.isActive && _child6._setInActiveInHierarchy(activeChangedComponents);
        }
      };
      _proto._setTransformDirty = function _setTransformDirty() {
        if (this.transform) {
          this.transform._parentChange();
        } else {
          for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i]._setTransformDirty();
          }
        }
      };
      _proto._setSiblingIndex = function _setSiblingIndex(sibling, target) {
        target = Math.min(target, sibling.length - 1);
        if (target < 0) {
          throw "Sibling index " + target + " should large than 0";
        }
        if (this._siblingIndex !== target) {
          var oldIndex = this._siblingIndex;
          if (target < oldIndex) {
            for (var i = oldIndex; i >= target; i--) {
              var _child7 = i == target ? this : sibling[i - 1];
              sibling[i] = _child7;
              _child7._siblingIndex = i;
            }
          } else {
            for (var _i6 = oldIndex; _i6 <= target; _i6++) {
              var _child8 = _i6 == target ? this : sibling[_i6 + 1];
              sibling[_i6] = _child8;
              _child8._siblingIndex = _i6;
            }
          }
        }
      };
      _proto.getInvModelMatrix = function getInvModelMatrix() {
        if (this._inverseWorldMatFlag.flag) {
          miniprogram2.Matrix.invert(this.transform.worldMatrix, this._invModelMatrix);
          this._inverseWorldMatFlag.flag = false;
        }
        return this._invModelMatrix;
      };
      _createClass2(Entity2, [{
        key: "isActive",
        get: function get() {
          return this._isActive;
        },
        set: function set(value) {
          if (value !== this._isActive) {
            this._isActive = value;
            if (value) {
              var parent = this._parent;
              if (parent !== null && parent !== void 0 && parent._isActiveInHierarchy || this._isRoot && this._scene._isActiveInEngine) {
                this._processActive();
              }
            } else {
              if (this._isActiveInHierarchy) {
                this._processInActive();
              }
            }
          }
        }
      }, {
        key: "isActiveInHierarchy",
        get: function get() {
          return this._isActiveInHierarchy;
        }
      }, {
        key: "parent",
        get: function get() {
          return this._parent;
        },
        set: function set(value) {
          this._setParent(value);
        }
      }, {
        key: "children",
        get: function get() {
          return this._children;
        }
      }, {
        key: "childCount",
        get: function get() {
          return this._children.length;
        }
      }, {
        key: "scene",
        get: function get() {
          return this._scene;
        }
      }, {
        key: "siblingIndex",
        get: function get() {
          return this._siblingIndex;
        },
        set: function set(value) {
          if (this._siblingIndex === -1) {
            throw "The entity " + this.name + " is not in the hierarchy";
          }
          this._setSiblingIndex(this._isRoot ? this._scene._rootEntities : this._parent._children, value);
        }
      }]);
      return Entity2;
    }(EngineObject);
    var FeatureManager = /* @__PURE__ */ function() {
      function FeatureManager2() {
        this._features = [];
        this._objects = [];
      }
      var _proto = FeatureManager2.prototype;
      _proto.registerFeature = function registerFeature(IFeature) {
        var featureArray = this._features;
        for (var i = 0, len = featureArray.length; i < len; i++) {
          if (featureArray[i] === IFeature) {
            return;
          }
        }
        featureArray.push(IFeature);
        var objectArray = this._objects;
        for (var _i = 0, _len = objectArray.length; _i < _len; _i++) {
          objectArray[_i].features.push(new IFeature());
        }
      };
      _proto.addObject = function addObject(obj) {
        obj.features = [];
        for (var i = 0, len = this._features.length; i < len; i++) {
          var _engine;
          obj.features.push(new this._features[i]((_engine = obj.engine) != null ? _engine : obj));
        }
        this._objects.push(obj);
      };
      _proto.callFeatureMethod = function callFeatureMethod(obj, method, args) {
        var features = obj.features;
        var count = features.length;
        for (var i = 0; i < count; i++) {
          var feature = features[i];
          if (feature[method]) {
            feature[method].apply(feature, args);
          }
        }
      };
      _proto.findFeature = function findFeature(obj, IFeature) {
        var features = obj.features;
        var count = features.length;
        for (var i = 0; i < count; i++) {
          var feature = features[i];
          if (feature.constructor === IFeature) {
            return feature;
          }
        }
        return void 0;
      };
      return FeatureManager2;
    }();
    exports3.Keys = void 0;
    (function(Keys) {
      Keys[Keys["Backquote"] = 0] = "Backquote";
      Keys[Keys["Backslash"] = 1] = "Backslash";
      Keys[Keys["Backspace"] = 2] = "Backspace";
      Keys[Keys["BracketLeft"] = 3] = "BracketLeft";
      Keys[Keys["BracketRight"] = 4] = "BracketRight";
      Keys[Keys["Comma"] = 5] = "Comma";
      Keys[Keys["Digit0"] = 6] = "Digit0";
      Keys[Keys["Digit1"] = 7] = "Digit1";
      Keys[Keys["Digit2"] = 8] = "Digit2";
      Keys[Keys["Digit3"] = 9] = "Digit3";
      Keys[Keys["Digit4"] = 10] = "Digit4";
      Keys[Keys["Digit5"] = 11] = "Digit5";
      Keys[Keys["Digit6"] = 12] = "Digit6";
      Keys[Keys["Digit7"] = 13] = "Digit7";
      Keys[Keys["Digit8"] = 14] = "Digit8";
      Keys[Keys["Digit9"] = 15] = "Digit9";
      Keys[Keys["Equal"] = 16] = "Equal";
      Keys[Keys["IntlBackslash"] = 17] = "IntlBackslash";
      Keys[Keys["IntlRo"] = 18] = "IntlRo";
      Keys[Keys["IntlYen"] = 19] = "IntlYen";
      Keys[Keys["KeyA"] = 20] = "KeyA";
      Keys[Keys["KeyB"] = 21] = "KeyB";
      Keys[Keys["KeyC"] = 22] = "KeyC";
      Keys[Keys["KeyD"] = 23] = "KeyD";
      Keys[Keys["KeyE"] = 24] = "KeyE";
      Keys[Keys["KeyF"] = 25] = "KeyF";
      Keys[Keys["KeyG"] = 26] = "KeyG";
      Keys[Keys["KeyH"] = 27] = "KeyH";
      Keys[Keys["KeyI"] = 28] = "KeyI";
      Keys[Keys["KeyJ"] = 29] = "KeyJ";
      Keys[Keys["KeyK"] = 30] = "KeyK";
      Keys[Keys["KeyL"] = 31] = "KeyL";
      Keys[Keys["KeyM"] = 32] = "KeyM";
      Keys[Keys["KeyN"] = 33] = "KeyN";
      Keys[Keys["KeyO"] = 34] = "KeyO";
      Keys[Keys["KeyP"] = 35] = "KeyP";
      Keys[Keys["KeyQ"] = 36] = "KeyQ";
      Keys[Keys["KeyR"] = 37] = "KeyR";
      Keys[Keys["KeyS"] = 38] = "KeyS";
      Keys[Keys["KeyT"] = 39] = "KeyT";
      Keys[Keys["KeyU"] = 40] = "KeyU";
      Keys[Keys["KeyV"] = 41] = "KeyV";
      Keys[Keys["KeyW"] = 42] = "KeyW";
      Keys[Keys["KeyX"] = 43] = "KeyX";
      Keys[Keys["KeyY"] = 44] = "KeyY";
      Keys[Keys["KeyZ"] = 45] = "KeyZ";
      Keys[Keys["Minus"] = 46] = "Minus";
      Keys[Keys["Period"] = 47] = "Period";
      Keys[Keys["Quote"] = 48] = "Quote";
      Keys[Keys["Semicolon"] = 49] = "Semicolon";
      Keys[Keys["Slash"] = 50] = "Slash";
      Keys[Keys["AltLeft"] = 51] = "AltLeft";
      Keys[Keys["AltRight"] = 52] = "AltRight";
      Keys[Keys["CapsLock"] = 53] = "CapsLock";
      Keys[Keys["ContextMenu"] = 54] = "ContextMenu";
      Keys[Keys["ControlLeft"] = 55] = "ControlLeft";
      Keys[Keys["ControlRight"] = 56] = "ControlRight";
      Keys[Keys["Enter"] = 57] = "Enter";
      Keys[Keys["MetaLeft"] = 58] = "MetaLeft";
      Keys[Keys["MetaRight"] = 59] = "MetaRight";
      Keys[Keys["ShiftLeft"] = 60] = "ShiftLeft";
      Keys[Keys["ShiftRight"] = 61] = "ShiftRight";
      Keys[Keys["Space"] = 62] = "Space";
      Keys[Keys["Tab"] = 63] = "Tab";
      Keys[Keys["Convert"] = 64] = "Convert";
      Keys[Keys["KanaMode"] = 65] = "KanaMode";
      Keys[Keys["Lang1"] = 66] = "Lang1";
      Keys[Keys["Lang2"] = 67] = "Lang2";
      Keys[Keys["Lang3"] = 68] = "Lang3";
      Keys[Keys["Lang4"] = 69] = "Lang4";
      Keys[Keys["Lang5"] = 70] = "Lang5";
      Keys[Keys["NonConvert"] = 71] = "NonConvert";
      Keys[Keys["Delete"] = 72] = "Delete";
      Keys[Keys["End"] = 73] = "End";
      Keys[Keys["Help"] = 74] = "Help";
      Keys[Keys["Home"] = 75] = "Home";
      Keys[Keys["Insert"] = 76] = "Insert";
      Keys[Keys["PageDown"] = 77] = "PageDown";
      Keys[Keys["PageUp"] = 78] = "PageUp";
      Keys[Keys["ArrowDown"] = 79] = "ArrowDown";
      Keys[Keys["ArrowLeft"] = 80] = "ArrowLeft";
      Keys[Keys["ArrowRight"] = 81] = "ArrowRight";
      Keys[Keys["ArrowUp"] = 82] = "ArrowUp";
      Keys[Keys["NumLock"] = 83] = "NumLock";
      Keys[Keys["Numpad0"] = 84] = "Numpad0";
      Keys[Keys["Numpad1"] = 85] = "Numpad1";
      Keys[Keys["Numpad2"] = 86] = "Numpad2";
      Keys[Keys["Numpad3"] = 87] = "Numpad3";
      Keys[Keys["Numpad4"] = 88] = "Numpad4";
      Keys[Keys["Numpad5"] = 89] = "Numpad5";
      Keys[Keys["Numpad6"] = 90] = "Numpad6";
      Keys[Keys["Numpad7"] = 91] = "Numpad7";
      Keys[Keys["Numpad8"] = 92] = "Numpad8";
      Keys[Keys["Numpad9"] = 93] = "Numpad9";
      Keys[Keys["NumpadAdd"] = 94] = "NumpadAdd";
      Keys[Keys["NumpadBackspace"] = 95] = "NumpadBackspace";
      Keys[Keys["NumpadClear"] = 96] = "NumpadClear";
      Keys[Keys["NumpadClearEntry"] = 97] = "NumpadClearEntry";
      Keys[Keys["NumpadComma"] = 98] = "NumpadComma";
      Keys[Keys["NumpadDecimal"] = 99] = "NumpadDecimal";
      Keys[Keys["NumpadDivide"] = 100] = "NumpadDivide";
      Keys[Keys["NumpadEnter"] = 101] = "NumpadEnter";
      Keys[Keys["NumpadEqual"] = 102] = "NumpadEqual";
      Keys[Keys["NumpadHash"] = 103] = "NumpadHash";
      Keys[Keys["NumpadMemoryAdd"] = 104] = "NumpadMemoryAdd";
      Keys[Keys["NumpadMemoryClear"] = 105] = "NumpadMemoryClear";
      Keys[Keys["NumpadMemoryRecall"] = 106] = "NumpadMemoryRecall";
      Keys[Keys["NumpadMemoryStore"] = 107] = "NumpadMemoryStore";
      Keys[Keys["NumpadMemorySubtract"] = 108] = "NumpadMemorySubtract";
      Keys[Keys["NumpadMultiply"] = 109] = "NumpadMultiply";
      Keys[Keys["NumpadParenLeft"] = 110] = "NumpadParenLeft";
      Keys[Keys["NumpadParenRight"] = 111] = "NumpadParenRight";
      Keys[Keys["NumpadStar"] = 112] = "NumpadStar";
      Keys[Keys["NumpadSubtract"] = 113] = "NumpadSubtract";
      Keys[Keys["Escape"] = 114] = "Escape";
      Keys[Keys["F1"] = 115] = "F1";
      Keys[Keys["F2"] = 116] = "F2";
      Keys[Keys["F3"] = 117] = "F3";
      Keys[Keys["F4"] = 118] = "F4";
      Keys[Keys["F5"] = 119] = "F5";
      Keys[Keys["F6"] = 120] = "F6";
      Keys[Keys["F7"] = 121] = "F7";
      Keys[Keys["F8"] = 122] = "F8";
      Keys[Keys["F9"] = 123] = "F9";
      Keys[Keys["F10"] = 124] = "F10";
      Keys[Keys["F11"] = 125] = "F11";
      Keys[Keys["F12"] = 126] = "F12";
      Keys[Keys["F13"] = 127] = "F13";
      Keys[Keys["F14"] = 128] = "F14";
      Keys[Keys["F15"] = 129] = "F15";
      Keys[Keys["Fn"] = 130] = "Fn";
      Keys[Keys["FnLock"] = 131] = "FnLock";
      Keys[Keys["PrintScreen"] = 132] = "PrintScreen";
      Keys[Keys["ScrollLock"] = 133] = "ScrollLock";
      Keys[Keys["Pause"] = 134] = "Pause";
      Keys[Keys["BrowserBack"] = 135] = "BrowserBack";
      Keys[Keys["BrowserFavorites"] = 136] = "BrowserFavorites";
      Keys[Keys["BrowserForward"] = 137] = "BrowserForward";
      Keys[Keys["BrowserHome"] = 138] = "BrowserHome";
      Keys[Keys["BrowserRefresh"] = 139] = "BrowserRefresh";
      Keys[Keys["BrowserSearch"] = 140] = "BrowserSearch";
      Keys[Keys["BrowserStop"] = 141] = "BrowserStop";
      Keys[Keys["Eject"] = 142] = "Eject";
      Keys[Keys["LaunchApp1"] = 143] = "LaunchApp1";
      Keys[Keys["LaunchApp2"] = 144] = "LaunchApp2";
      Keys[Keys["LaunchMail"] = 145] = "LaunchMail";
      Keys[Keys["MediaPlayPause"] = 146] = "MediaPlayPause";
      Keys[Keys["MediaSelect"] = 147] = "MediaSelect";
      Keys[Keys["MediaStop"] = 148] = "MediaStop";
      Keys[Keys["MediaTrackNext"] = 149] = "MediaTrackNext";
      Keys[Keys["MediaTrackPrevious"] = 150] = "MediaTrackPrevious";
      Keys[Keys["Power"] = 151] = "Power";
      Keys[Keys["Sleep"] = 152] = "Sleep";
      Keys[Keys["AudioVolumeDown"] = 153] = "AudioVolumeDown";
      Keys[Keys["AudioVolumeMute"] = 154] = "AudioVolumeMute";
      Keys[Keys["AudioVolumeUp"] = 155] = "AudioVolumeUp";
      Keys[Keys["WakeUp"] = 156] = "WakeUp";
      Keys[Keys["Hyper"] = 157] = "Hyper";
      Keys[Keys["Super"] = 158] = "Super";
      Keys[Keys["Turbo"] = 159] = "Turbo";
      Keys[Keys["Abort"] = 160] = "Abort";
      Keys[Keys["Resume"] = 161] = "Resume";
      Keys[Keys["Suspend"] = 162] = "Suspend";
      Keys[Keys["Again"] = 163] = "Again";
      Keys[Keys["Copy"] = 164] = "Copy";
      Keys[Keys["Cut"] = 165] = "Cut";
      Keys[Keys["Find"] = 166] = "Find";
      Keys[Keys["Open"] = 167] = "Open";
      Keys[Keys["Paste"] = 168] = "Paste";
      Keys[Keys["Props"] = 169] = "Props";
      Keys[Keys["Select"] = 170] = "Select";
      Keys[Keys["Undo"] = 171] = "Undo";
      Keys[Keys["Hiragana"] = 172] = "Hiragana";
      Keys[Keys["Katakana"] = 173] = "Katakana";
      Keys[Keys["Unidentified"] = 174] = "Unidentified";
    })(exports3.Keys || (exports3.Keys = {}));
    var KeyboardManager = /* @__PURE__ */ function() {
      function KeyboardManager2(htmlCanvas) {
        this._curHeldDownKeyToIndexMap = [];
        this._upKeyToFrameCountMap = [];
        this._downKeyToFrameCountMap = [];
        this._curFrameHeldDownList = new DisorderedArray2();
        this._curFrameDownList = new DisorderedArray2();
        this._curFrameUpList = new DisorderedArray2();
        this._htmlCanvas = void 0;
        this._nativeEvents = [];
        this._hadListener = false;
        this._htmlCanvas = htmlCanvas;
        htmlCanvas.tabIndex = htmlCanvas.tabIndex;
        this._onKeyEvent = this._onKeyEvent.bind(this);
        htmlCanvas.addEventListener("keydown", this._onKeyEvent);
        htmlCanvas.addEventListener("keyup", this._onKeyEvent);
        this._hadListener = true;
      }
      var _proto = KeyboardManager2.prototype;
      _proto._update = function _update(frameCount) {
        var nativeEvents = this._nativeEvents, curFrameDownList = this._curFrameDownList, curFrameUpList = this._curFrameUpList;
        curFrameDownList.length = 0;
        curFrameUpList.length = 0;
        if (nativeEvents.length > 0) {
          var curHeldDownKeyToIndexMap = this._curHeldDownKeyToIndexMap, curFrameHeldDownList = this._curFrameHeldDownList, downKeyToFrameCountMap = this._downKeyToFrameCountMap, upKeyToFrameCountMap = this._upKeyToFrameCountMap;
          for (var i = 0, n = nativeEvents.length; i < n; i++) {
            var evt = nativeEvents[i];
            var codeKey = exports3.Keys[evt.code];
            switch (evt.type) {
              case "keydown":
                if (curHeldDownKeyToIndexMap[codeKey] == null) {
                  curFrameDownList.add(codeKey);
                  curFrameHeldDownList.add(codeKey);
                  curHeldDownKeyToIndexMap[codeKey] = curFrameHeldDownList.length - 1;
                  downKeyToFrameCountMap[codeKey] = frameCount;
                }
                break;
              case "keyup":
                var delIndex = curHeldDownKeyToIndexMap[codeKey];
                if (delIndex != null) {
                  curHeldDownKeyToIndexMap[codeKey] = null;
                  var swapCode = curFrameHeldDownList.deleteByIndex(delIndex);
                  swapCode && (curHeldDownKeyToIndexMap[swapCode] = delIndex);
                }
                curFrameUpList.add(codeKey);
                upKeyToFrameCountMap[codeKey] = frameCount;
                break;
            }
          }
          nativeEvents.length = 0;
        }
      };
      _proto._onFocus = function _onFocus() {
        if (!this._hadListener) {
          this._htmlCanvas.addEventListener("keydown", this._onKeyEvent);
          this._htmlCanvas.addEventListener("keyup", this._onKeyEvent);
          this._hadListener = true;
        }
      };
      _proto._onBlur = function _onBlur() {
        if (this._hadListener) {
          this._htmlCanvas.removeEventListener("keydown", this._onKeyEvent);
          this._htmlCanvas.removeEventListener("keyup", this._onKeyEvent);
          this._curHeldDownKeyToIndexMap.length = 0;
          this._curFrameHeldDownList.length = 0;
          this._curFrameDownList.length = 0;
          this._curFrameUpList.length = 0;
          this._nativeEvents.length = 0;
          this._hadListener = false;
        }
      };
      _proto._destroy = function _destroy() {
        if (this._hadListener) {
          this._htmlCanvas.removeEventListener("keydown", this._onKeyEvent);
          this._htmlCanvas.removeEventListener("keyup", this._onKeyEvent);
          this._hadListener = false;
        }
        this._curHeldDownKeyToIndexMap = null;
        this._upKeyToFrameCountMap = null;
        this._downKeyToFrameCountMap = null;
        this._nativeEvents = null;
        this._curFrameHeldDownList = null;
        this._curFrameDownList = null;
        this._curFrameUpList = null;
      };
      _proto._onKeyEvent = function _onKeyEvent(evt) {
        evt.cancelable && evt.preventDefault();
        this._nativeEvents.push(evt);
      };
      return KeyboardManager2;
    }();
    exports3.CameraClearFlags = void 0;
    (function(CameraClearFlags) {
      CameraClearFlags[CameraClearFlags["None"] = 0] = "None";
      CameraClearFlags[CameraClearFlags["Color"] = 1] = "Color";
      CameraClearFlags[CameraClearFlags["Depth"] = 2] = "Depth";
      CameraClearFlags[CameraClearFlags["Stencil"] = 4] = "Stencil";
      CameraClearFlags[CameraClearFlags["ColorDepth"] = 3] = "ColorDepth";
      CameraClearFlags[CameraClearFlags["ColorStencil"] = 5] = "ColorStencil";
      CameraClearFlags[CameraClearFlags["DepthStencil"] = 6] = "DepthStencil";
      CameraClearFlags[CameraClearFlags["All"] = 7] = "All";
    })(exports3.CameraClearFlags || (exports3.CameraClearFlags = {}));
    var HitResult = function HitResult2() {
      this.entity = null;
      this.distance = 0;
      this.point = new miniprogram2.Vector3();
      this.normal = new miniprogram2.Vector3();
    };
    var PhysicsManager = /* @__PURE__ */ function() {
      function PhysicsManager2(engine) {
        var _this = this;
        this._initialized = false;
        this._engine = void 0;
        this._restTime = 0;
        this._colliders = new DisorderedArray2();
        this._gravity = new miniprogram2.Vector3(0, -9.81, 0);
        this._nativePhysicsManager = void 0;
        this._physicalObjectsMap = {};
        this._onContactEnter = function(obj1, obj2) {
          var shape1 = _this._physicalObjectsMap[obj1];
          var shape2 = _this._physicalObjectsMap[obj2];
          var scripts = shape1.collider.entity._scripts;
          for (var i = 0, len = scripts.length; i < len; i++) {
            var script = scripts.get(i);
            script._waitHandlingInValid || script.onCollisionEnter(shape2);
          }
          scripts = shape2.collider.entity._scripts;
          for (var _i = 0, _len = scripts.length; _i < _len; _i++) {
            var _script = scripts.get(_i);
            _script._waitHandlingInValid || _script.onCollisionEnter(shape1);
          }
        };
        this._onContactExit = function(obj1, obj2) {
          var shape1 = _this._physicalObjectsMap[obj1];
          var shape2 = _this._physicalObjectsMap[obj2];
          var scripts = shape1.collider.entity._scripts;
          for (var i = 0, len = scripts.length; i < len; i++) {
            var script = scripts.get(i);
            script._waitHandlingInValid || script.onCollisionExit(shape2);
          }
          scripts = shape2.collider.entity._scripts;
          for (var _i2 = 0, _len2 = scripts.length; _i2 < _len2; _i2++) {
            var _script2 = scripts.get(_i2);
            _script2._waitHandlingInValid || _script2.onCollisionExit(shape1);
          }
        };
        this._onContactStay = function(obj1, obj2) {
          var shape1 = _this._physicalObjectsMap[obj1];
          var shape2 = _this._physicalObjectsMap[obj2];
          var scripts = shape1.collider.entity._scripts;
          for (var i = 0, len = scripts.length; i < len; i++) {
            var script = scripts.get(i);
            script._waitHandlingInValid || script.onCollisionStay(shape2);
          }
          scripts = shape2.collider.entity._scripts;
          for (var _i3 = 0, _len3 = scripts.length; _i3 < _len3; _i3++) {
            var _script3 = scripts.get(_i3);
            _script3._waitHandlingInValid || _script3.onCollisionStay(shape1);
          }
        };
        this._onTriggerEnter = function(obj1, obj2) {
          var shape1 = _this._physicalObjectsMap[obj1];
          var shape2 = _this._physicalObjectsMap[obj2];
          var scripts = shape1.collider.entity._scripts;
          for (var i = 0, len = scripts.length; i < len; i++) {
            var script = scripts.get(i);
            script._waitHandlingInValid || script.onTriggerEnter(shape2);
          }
          scripts = shape2.collider.entity._scripts;
          for (var _i4 = 0, _len4 = scripts.length; _i4 < _len4; _i4++) {
            var _script4 = scripts.get(_i4);
            _script4._waitHandlingInValid || _script4.onTriggerEnter(shape1);
          }
        };
        this._onTriggerExit = function(obj1, obj2) {
          var shape1 = _this._physicalObjectsMap[obj1];
          var shape2 = _this._physicalObjectsMap[obj2];
          var scripts = shape1.collider.entity._scripts;
          for (var i = 0, n = scripts.length; i < n; i++) {
            var script = scripts.get(i);
            script._waitHandlingInValid || script.onTriggerExit(shape2);
          }
          scripts = shape2.collider.entity._scripts;
          for (var _i5 = 0, _n = scripts.length; _i5 < _n; _i5++) {
            var _script5 = scripts.get(_i5);
            _script5._waitHandlingInValid || _script5.onTriggerExit(shape1);
          }
        };
        this._onTriggerStay = function(obj1, obj2) {
          var shape1 = _this._physicalObjectsMap[obj1];
          var shape2 = _this._physicalObjectsMap[obj2];
          var scripts = shape1.collider.entity._scripts;
          for (var i = 0, len = scripts.length; i < len; i++) {
            var script = scripts.get(i);
            script._waitHandlingInValid || script.onTriggerStay(shape2);
          }
          scripts = shape2.collider.entity._scripts;
          for (var _i6 = 0, _len5 = scripts.length; _i6 < _len5; _i6++) {
            var _script6 = scripts.get(_i6);
            _script6._waitHandlingInValid || _script6.onTriggerStay(shape1);
          }
        };
        this.fixedTimeStep = 1 / 60;
        this.maxSumTimeStep = 1 / 3;
        this._engine = engine;
      }
      var _proto = PhysicsManager2.prototype;
      _proto.initialize = function initialize(physics) {
        if (this._initialized) {
          return;
        }
        PhysicsManager2._nativePhysics = physics;
        this._nativePhysicsManager = PhysicsManager2._nativePhysics.createPhysicsManager(this._onContactEnter, this._onContactExit, this._onContactStay, this._onTriggerEnter, this._onTriggerExit, this._onTriggerStay);
        this._initialized = true;
      };
      _proto.raycast = function raycast(ray, distanceOrResult, layerMaskOrResult, outHitResult) {
        var _this2 = this;
        var hitResult;
        var distance = Number.MAX_VALUE;
        if (typeof distanceOrResult === "number") {
          distance = distanceOrResult;
        } else if (distanceOrResult != void 0) {
          hitResult = distanceOrResult;
        }
        var layerMask = exports3.Layer.Everything;
        if (typeof layerMaskOrResult === "number") {
          layerMask = layerMaskOrResult;
        } else if (layerMaskOrResult != void 0) {
          hitResult = layerMaskOrResult;
        }
        if (outHitResult) {
          hitResult = outHitResult;
        }
        if (hitResult != void 0) {
          var result = this._nativePhysicsManager.raycast(ray, distance, function(idx, distance2, position, normal) {
            hitResult.entity = _this2._physicalObjectsMap[idx]._collider.entity;
            hitResult.distance = distance2;
            hitResult.normal.copyFrom(normal);
            hitResult.point.copyFrom(position);
          });
          if (result) {
            if (hitResult.entity.layer & layerMask) {
              return true;
            } else {
              hitResult.entity = null;
              hitResult.distance = 0;
              hitResult.point.set(0, 0, 0);
              hitResult.normal.set(0, 0, 0);
              return false;
            }
          }
          return false;
        } else {
          return this._nativePhysicsManager.raycast(ray, distance);
        }
      };
      _proto._update = function _update(deltaTime) {
        var fixedTimeStep = this.fixedTimeStep, nativePhysicsManager = this._nativePhysicsManager;
        var componentsManager = this._engine._componentsManager;
        var simulateTime = deltaTime + this._restTime;
        var step = Math.floor(Math.min(this.maxSumTimeStep, simulateTime) / fixedTimeStep);
        this._restTime = simulateTime - step * fixedTimeStep;
        for (var i = 0; i < step; i++) {
          componentsManager.callScriptOnPhysicsUpdate();
          this._callColliderOnUpdate();
          nativePhysicsManager.update(fixedTimeStep);
          this._callColliderOnLateUpdate();
        }
      };
      _proto._addColliderShape = function _addColliderShape(colliderShape) {
        this._physicalObjectsMap[colliderShape.id] = colliderShape;
        this._nativePhysicsManager.addColliderShape(colliderShape._nativeShape);
      };
      _proto._removeColliderShape = function _removeColliderShape(colliderShape) {
        delete this._physicalObjectsMap[colliderShape.id];
        this._nativePhysicsManager.removeColliderShape(colliderShape._nativeShape);
      };
      _proto._addCollider = function _addCollider(collider) {
        if (collider._index === -1) {
          collider._index = this._colliders.length;
          this._colliders.add(collider);
        }
        this._nativePhysicsManager.addCollider(collider._nativeCollider);
      };
      _proto._addCharacterController = function _addCharacterController(controller) {
        if (controller._index === -1) {
          controller._index = this._colliders.length;
          this._colliders.add(controller);
        }
        this._nativePhysicsManager.addCharacterController(controller._nativeCollider);
      };
      _proto._removeCollider = function _removeCollider(collider) {
        var replaced = this._colliders.deleteByIndex(collider._index);
        replaced && (replaced._index = collider._index);
        collider._index = -1;
        this._nativePhysicsManager.removeCollider(collider._nativeCollider);
      };
      _proto._removeCharacterController = function _removeCharacterController(controller) {
        var replaced = this._colliders.deleteByIndex(controller._index);
        replaced && (replaced._index = controller._index);
        controller._index = -1;
        this._nativePhysicsManager.removeCharacterController(controller._nativeCollider);
      };
      _proto._callColliderOnUpdate = function _callColliderOnUpdate() {
        var elements = this._colliders._elements;
        for (var i = this._colliders.length - 1; i >= 0; --i) {
          elements[i]._onUpdate();
        }
      };
      _proto._callColliderOnLateUpdate = function _callColliderOnLateUpdate() {
        var elements = this._colliders._elements;
        for (var i = this._colliders.length - 1; i >= 0; --i) {
          elements[i]._onLateUpdate();
        }
      };
      _createClass2(PhysicsManager2, [{
        key: "gravity",
        get: function get() {
          return this._gravity;
        },
        set: function set(value) {
          var gravity = this._gravity;
          if (gravity !== value) {
            gravity.copyFrom(value);
          }
          this._nativePhysicsManager.setGravity(gravity);
        }
      }]);
      return PhysicsManager2;
    }();
    PhysicsManager._nativePhysics = void 0;
    exports3.PhysicsMaterialCombineMode = void 0;
    (function(PhysicsMaterialCombineMode) {
      PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Average"] = 0] = "Average";
      PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Minimum"] = 1] = "Minimum";
      PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Multiply"] = 2] = "Multiply";
      PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Maximum"] = 3] = "Maximum";
    })(exports3.PhysicsMaterialCombineMode || (exports3.PhysicsMaterialCombineMode = {}));
    var PhysicsMaterial = /* @__PURE__ */ function() {
      function PhysicsMaterial2() {
        this._bounciness = 0.1;
        this._dynamicFriction = 0.1;
        this._staticFriction = 0.1;
        this._bounceCombine = exports3.PhysicsMaterialCombineMode.Average;
        this._frictionCombine = exports3.PhysicsMaterialCombineMode.Average;
        this._nativeMaterial = void 0;
        this._nativeMaterial = PhysicsManager._nativePhysics.createPhysicsMaterial(this._staticFriction, this._dynamicFriction, this._bounciness, this._bounceCombine, this._frictionCombine);
      }
      var _proto = PhysicsMaterial2.prototype;
      _proto._destroy = function _destroy() {
        this._nativeMaterial.destroy();
      };
      _createClass2(PhysicsMaterial2, [{
        key: "bounciness",
        get: function get() {
          return this._bounciness;
        },
        set: function set(value) {
          this._bounciness = value;
          this._nativeMaterial.setBounciness(value);
        }
      }, {
        key: "dynamicFriction",
        get: function get() {
          return this._dynamicFriction;
        },
        set: function set(value) {
          this._dynamicFriction = value;
          this._nativeMaterial.setDynamicFriction(value);
        }
      }, {
        key: "staticFriction",
        get: function get() {
          return this._staticFriction;
        },
        set: function set(value) {
          this._staticFriction = value;
          this._nativeMaterial.setStaticFriction(value);
        }
      }, {
        key: "bounceCombine",
        get: function get() {
          return this._bounceCombine;
        },
        set: function set(value) {
          this._bounceCombine = value;
          this._nativeMaterial.setBounceCombine(value);
        }
      }, {
        key: "frictionCombine",
        get: function get() {
          return this._frictionCombine;
        },
        set: function set(value) {
          this._frictionCombine = value;
          this._nativeMaterial.setFrictionCombine(value);
        }
      }]);
      return PhysicsMaterial2;
    }();
    var _dec$52, _class$c2, _class2$a, _descriptor$9;
    var Collider = (_dec$52 = dependentComponents(Transform), _dec$52(_class$c2 = (_class2$a = /* @__PURE__ */ function(_Component) {
      _inheritsLoose2(Collider2, _Component);
      function Collider2(entity) {
        var _this;
        _this = _Component.call(this, entity) || this;
        _initializerDefineProperty(_this, "_index", _descriptor$9, _assertThisInitialized(_this));
        _this._nativeCollider = void 0;
        _this._updateFlag = void 0;
        _this._shapes = [];
        _this._updateFlag = _this.entity.transform.registerWorldChangeFlag();
        return _this;
      }
      var _proto = Collider2.prototype;
      _proto.addShape = function addShape(shape) {
        var oldCollider = shape._collider;
        if (oldCollider !== this) {
          if (oldCollider) {
            oldCollider.removeShape(shape);
          }
          this._shapes.push(shape);
          this.engine.physicsManager._addColliderShape(shape);
          shape._collider = this;
          this._nativeCollider.addShape(shape._nativeShape);
        }
      };
      _proto.removeShape = function removeShape(shape) {
        var index = this._shapes.indexOf(shape);
        if (index !== -1) {
          this._shapes.splice(index, 1);
          this.engine.physicsManager._removeColliderShape(shape);
          shape._collider = null;
          this._nativeCollider.removeShape(shape._nativeShape);
        }
      };
      _proto.clearShapes = function clearShapes() {
        var shapes = this._shapes;
        for (var i = 0, n = shapes.length; i < n; i++) {
          var shape = shapes[i];
          this.engine.physicsManager._removeColliderShape(shape);
          shape._destroy();
          this._nativeCollider.removeShape(shape._nativeShape);
        }
        shapes.length = 0;
      };
      _proto._onUpdate = function _onUpdate() {
        if (this._updateFlag.flag) {
          var transform = this.entity.transform;
          this._nativeCollider.setWorldTransform(transform.worldPosition, transform.worldRotationQuaternion);
          var worldScale = transform.lossyWorldScale;
          for (var i = 0, n = this.shapes.length; i < n; i++) {
            this.shapes[i]._nativeShape.setWorldScale(worldScale);
          }
          this._updateFlag.flag = false;
        }
      };
      _proto._onLateUpdate = function _onLateUpdate() {
      };
      _proto._onEnable = function _onEnable() {
        this.engine.physicsManager._addCollider(this);
      };
      _proto._onDisable = function _onDisable() {
        this.engine.physicsManager._removeCollider(this);
      };
      _proto._onDestroy = function _onDestroy() {
        this.clearShapes();
        this._nativeCollider.destroy();
      };
      _createClass2(Collider2, [{
        key: "shapes",
        get: function get() {
          return this._shapes;
        }
      }]);
      return Collider2;
    }(Component), _descriptor$9 = _applyDecoratedDescriptor(_class2$a.prototype, "_index", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return -1;
      }
    }), _class2$a)) || _class$c2);
    exports3.ControllerNonWalkableMode = void 0;
    (function(ControllerNonWalkableMode) {
      ControllerNonWalkableMode[ControllerNonWalkableMode["PreventClimbing"] = 0] = "PreventClimbing";
      ControllerNonWalkableMode[ControllerNonWalkableMode["PreventClimbingAndForceSliding"] = 1] = "PreventClimbingAndForceSliding";
    })(exports3.ControllerNonWalkableMode || (exports3.ControllerNonWalkableMode = {}));
    var CharacterController = /* @__PURE__ */ function(_Collider) {
      _inheritsLoose2(CharacterController2, _Collider);
      function CharacterController2(entity) {
        var _this;
        _this = _Collider.call(this, entity) || this;
        _this._index = -1;
        _this._stepOffset = 0;
        _this._nonWalkableMode = exports3.ControllerNonWalkableMode.PreventClimbing;
        _this._upDirection = new miniprogram2.Vector3(0, 1, 0);
        _this._slopeLimit = 0;
        _this._nativeCollider = PhysicsManager._nativePhysics.createCharacterController();
        return _this;
      }
      var _proto = CharacterController2.prototype;
      _proto.move = function move(disp, minDist, elapsedTime) {
        return this._nativeCollider.move(disp, minDist, elapsedTime);
      };
      _proto.addShape = function addShape(shape) {
        if (this._shapes.length > 0) {
          throw "only allow single shape on controller!";
        }
        _Collider.prototype.addShape.call(this, shape);
        this._updateFlag.flag = true;
      };
      _proto.clearShapes = function clearShapes() {
        if (this._shapes.length > 0) {
          _Collider.prototype.removeShape.call(this, this._shapes[0]);
        }
      };
      _proto._onUpdate = function _onUpdate() {
        if (this._updateFlag.flag) {
          var transform = this.entity.transform;
          var shapes = this.shapes;
          this._nativeCollider.setWorldPosition(transform.worldPosition);
          var worldScale = transform.lossyWorldScale;
          for (var i = 0, n = shapes.length; i < n; i++) {
            shapes[i]._nativeShape.setWorldScale(worldScale);
          }
          this._updateFlag.flag = false;
        }
      };
      _proto._onLateUpdate = function _onLateUpdate() {
        var position = this.entity.transform.worldPosition;
        this._nativeCollider.getWorldPosition(position);
        this.entity.transform.worldPosition = position;
        this._updateFlag.flag = false;
      };
      _proto._onEnable = function _onEnable() {
        this.engine.physicsManager._addCharacterController(this);
      };
      _proto._onDisable = function _onDisable() {
        this.engine.physicsManager._removeCharacterController(this);
      };
      _createClass2(CharacterController2, [{
        key: "stepOffset",
        get: function get() {
          return this._stepOffset;
        },
        set: function set(value) {
          this._stepOffset = value;
          this._nativeCollider.setStepOffset(value);
        }
      }, {
        key: "nonWalkableMode",
        get: function get() {
          return this._nonWalkableMode;
        },
        set: function set(value) {
          this._nonWalkableMode = value;
          this._nativeCollider.setNonWalkableMode(value);
        }
      }, {
        key: "upDirection",
        get: function get() {
          return this._upDirection;
        },
        set: function set(value) {
          if (this._upDirection !== value) {
            this._upDirection.copyFrom(value);
          }
          this._nativeCollider.setUpDirection(this._upDirection);
        }
      }, {
        key: "slopeLimit",
        get: function get() {
          return this._slopeLimit;
        },
        set: function set(value) {
          this._slopeLimit = value;
          this._nativeCollider.setSlopeLimit(value);
        }
      }]);
      return CharacterController2;
    }(Collider);
    var ColliderShape = /* @__PURE__ */ function() {
      function ColliderShape2() {
        this._collider = void 0;
        this._nativeShape = void 0;
        this._id = void 0;
        this._position = new miniprogram2.Vector3();
        this._material = void 0;
        this._isTrigger = false;
        this._isSceneQuery = true;
        this._contactOffset = 0;
        this._material = new PhysicsMaterial();
        this._id = ColliderShape2._idGenerator++;
      }
      var _proto = ColliderShape2.prototype;
      _proto.setPosition = function setPosition(x, y, z) {
        this._position.set(x, y, z);
        this._nativeShape.setPosition(this._position);
      };
      _proto._destroy = function _destroy() {
        this._material._destroy();
        this._nativeShape.destroy();
      };
      _createClass2(ColliderShape2, [{
        key: "collider",
        get: function get() {
          return this._collider;
        }
      }, {
        key: "id",
        get: function get() {
          return this._id;
        }
      }, {
        key: "contactOffset",
        get: function get() {
          return this._contactOffset;
        },
        set: function set(value) {
          this._contactOffset = value;
          this._nativeShape.setContactOffset(value);
        }
      }, {
        key: "material",
        get: function get() {
          return this._material;
        },
        set: function set(value) {
          this._material = value;
          this._nativeShape.setMaterial(value._nativeMaterial);
        }
      }, {
        key: "position",
        get: function get() {
          return this._position;
        },
        set: function set(value) {
          if (this._position !== value) {
            this._position.copyFrom(value);
          }
          this._nativeShape.setPosition(value);
        }
      }, {
        key: "isTrigger",
        get: function get() {
          return this._isTrigger;
        },
        set: function set(value) {
          this._isTrigger = value;
          this._nativeShape.setIsTrigger(value);
        }
      }]);
      return ColliderShape2;
    }();
    ColliderShape._idGenerator = 0;
    var BoxColliderShape = /* @__PURE__ */ function(_ColliderShape) {
      _inheritsLoose2(BoxColliderShape2, _ColliderShape);
      function BoxColliderShape2() {
        var _this;
        _this = _ColliderShape.call(this) || this;
        _this._size = new miniprogram2.Vector3(1, 1, 1);
        _this._nativeShape = PhysicsManager._nativePhysics.createBoxColliderShape(_this._id, _this._size, _this._material._nativeMaterial);
        return _this;
      }
      var _proto = BoxColliderShape2.prototype;
      _proto.setSize = function setSize(x, y, z) {
        this._size.x = x;
        this._size.y = y;
        this._size.z = z;
        this._nativeShape.setSize(this._size);
      };
      _createClass2(BoxColliderShape2, [{
        key: "size",
        get: function get() {
          return this._size;
        },
        set: function set(value) {
          if (this._size != value) {
            this._size.copyFrom(value);
          }
          this._nativeShape.setSize(value);
        }
      }]);
      return BoxColliderShape2;
    }(ColliderShape);
    var SphereColliderShape = /* @__PURE__ */ function(_ColliderShape) {
      _inheritsLoose2(SphereColliderShape2, _ColliderShape);
      function SphereColliderShape2() {
        var _this;
        _this = _ColliderShape.call(this) || this;
        _this._radius = 1;
        _this._nativeShape = PhysicsManager._nativePhysics.createSphereColliderShape(_this._id, _this._radius, _this._material._nativeMaterial);
        return _this;
      }
      _createClass2(SphereColliderShape2, [{
        key: "radius",
        get: function get() {
          return this._radius;
        },
        set: function set(value) {
          this._radius = value;
          this._nativeShape.setRadius(value);
        }
      }]);
      return SphereColliderShape2;
    }(ColliderShape);
    var PlaneColliderShape = /* @__PURE__ */ function(_ColliderShape) {
      _inheritsLoose2(PlaneColliderShape2, _ColliderShape);
      function PlaneColliderShape2() {
        var _this;
        _this = _ColliderShape.call(this) || this;
        _this._rotation = new miniprogram2.Vector3();
        _this._nativeShape = PhysicsManager._nativePhysics.createPlaneColliderShape(_this._id, _this._material._nativeMaterial);
        return _this;
      }
      var _proto = PlaneColliderShape2.prototype;
      _proto.setRotation = function setRotation(x, y, z) {
        this._rotation.set(x, y, z);
        this._nativeShape.setRotation(this._rotation);
      };
      _createClass2(PlaneColliderShape2, [{
        key: "rotation",
        get: function get() {
          return this._rotation;
        },
        set: function set(value) {
          if (this._rotation != value) {
            this._rotation.copyFrom(value);
          }
          this._nativeShape.setRotation(value);
        }
      }]);
      return PlaneColliderShape2;
    }(ColliderShape);
    exports3.ColliderShapeUpAxis = void 0;
    (function(ColliderShapeUpAxis) {
      ColliderShapeUpAxis[ColliderShapeUpAxis["X"] = 0] = "X";
      ColliderShapeUpAxis[ColliderShapeUpAxis["Y"] = 1] = "Y";
      ColliderShapeUpAxis[ColliderShapeUpAxis["Z"] = 2] = "Z";
    })(exports3.ColliderShapeUpAxis || (exports3.ColliderShapeUpAxis = {}));
    var CapsuleColliderShape = /* @__PURE__ */ function(_ColliderShape) {
      _inheritsLoose2(CapsuleColliderShape2, _ColliderShape);
      function CapsuleColliderShape2() {
        var _this;
        _this = _ColliderShape.call(this) || this;
        _this._radius = 1;
        _this._height = 2;
        _this._upAxis = exports3.ColliderShapeUpAxis.Y;
        _this._nativeShape = PhysicsManager._nativePhysics.createCapsuleColliderShape(_this._id, _this._radius, _this._height, _this._material._nativeMaterial);
        _this._nativeShape.setUpAxis(exports3.ColliderShapeUpAxis.Y);
        return _this;
      }
      _createClass2(CapsuleColliderShape2, [{
        key: "radius",
        get: function get() {
          return this._radius;
        },
        set: function set(value) {
          this._radius = value;
          this._nativeShape.setRadius(value);
        }
      }, {
        key: "height",
        get: function get() {
          return this._height;
        },
        set: function set(value) {
          this._height = value;
          this._nativeShape.setHeight(value);
        }
      }, {
        key: "upAxis",
        get: function get() {
          return this._upAxis;
        },
        set: function set(value) {
          this._upAxis = value;
          this._nativeShape.setUpAxis(value);
        }
      }]);
      return CapsuleColliderShape2;
    }(ColliderShape);
    var _dec$42, _class$b2;
    var Joint = (_dec$42 = dependentComponents(Collider), _dec$42(_class$b2 = /* @__PURE__ */ function(_Component) {
      _inheritsLoose2(Joint2, _Component);
      function Joint2(entity) {
        var _this;
        _this = _Component.call(this, entity) || this;
        _this._connectedCollider = new JointCollider();
        _this._collider = new JointCollider();
        _this._nativeJoint = void 0;
        _this._force = 0;
        _this._torque = 0;
        _this._connectedCollider.localPosition = new miniprogram2.Vector3();
        return _this;
      }
      _createClass2(Joint2, [{
        key: "connectedCollider",
        get: function get() {
          return this._connectedCollider.collider;
        },
        set: function set(value) {
          if (this._connectedCollider.collider !== value) {
            this._connectedCollider.collider = value;
            this._nativeJoint.setConnectedCollider(value._nativeCollider);
          }
        }
      }, {
        key: "connectedAnchor",
        get: function get() {
          return this._connectedCollider.localPosition;
        },
        set: function set(value) {
          var connectedAnchor = this._connectedCollider.localPosition;
          if (value !== connectedAnchor) {
            connectedAnchor.copyFrom(value);
          }
          this._nativeJoint.setConnectedAnchor(value);
        }
      }, {
        key: "connectedMassScale",
        get: function get() {
          return this._connectedCollider.massScale;
        },
        set: function set(value) {
          if (value !== this._connectedCollider.massScale) {
            this._connectedCollider.massScale = value;
            this._nativeJoint.setConnectedMassScale(value);
          }
        }
      }, {
        key: "connectedInertiaScale",
        get: function get() {
          return this._connectedCollider.inertiaScale;
        },
        set: function set(value) {
          if (value !== this._connectedCollider.inertiaScale) {
            this._connectedCollider.inertiaScale = value;
            this._nativeJoint.setConnectedInertiaScale(value);
          }
        }
      }, {
        key: "massScale",
        get: function get() {
          return this._collider.massScale;
        },
        set: function set(value) {
          if (value !== this._collider.massScale) {
            this._collider.massScale = value;
            this._nativeJoint.setMassScale(value);
          }
        }
      }, {
        key: "inertiaScale",
        get: function get() {
          return this._collider.inertiaScale;
        },
        set: function set(value) {
          if (value !== this._collider.inertiaScale) {
            this._collider.inertiaScale = value;
            this._nativeJoint.setInertiaScale(value);
          }
        }
      }, {
        key: "breakForce",
        get: function get() {
          return this._force;
        },
        set: function set(value) {
          if (value !== this._force) {
            this._force = value;
            this._nativeJoint.setBreakForce(value);
          }
        }
      }, {
        key: "breakTorque",
        get: function get() {
          return this._torque;
        },
        set: function set(value) {
          if (value !== this._torque) {
            this._torque = value;
            this._nativeJoint.setBreakTorque(value);
          }
        }
      }]);
      return Joint2;
    }(Component)) || _class$b2);
    var JointCollider = function JointCollider2() {
      this.collider = null;
      this.localPosition = void 0;
      this.localRotation = void 0;
      this.massScale = 0;
      this.inertiaScale = 0;
    };
    var FixedJoint = /* @__PURE__ */ function(_Joint) {
      _inheritsLoose2(FixedJoint2, _Joint);
      function FixedJoint2() {
        return _Joint.apply(this, arguments) || this;
      }
      var _proto = FixedJoint2.prototype;
      _proto._onAwake = function _onAwake() {
        var collider = this._collider;
        collider.collider = this.entity.getComponent(Collider);
        this._nativeJoint = PhysicsManager._nativePhysics.createFixedJoint(collider.collider._nativeCollider);
      };
      return FixedJoint2;
    }(Joint);
    var HingeJointFlag;
    (function(HingeJointFlag2) {
      HingeJointFlag2[HingeJointFlag2["LimitEnabled"] = 1] = "LimitEnabled";
      HingeJointFlag2[HingeJointFlag2["DriveEnabled"] = 2] = "DriveEnabled";
      HingeJointFlag2[HingeJointFlag2["DriveFreeSpin"] = 4] = "DriveFreeSpin";
    })(HingeJointFlag || (HingeJointFlag = {}));
    var HingeJoint = /* @__PURE__ */ function(_Joint) {
      _inheritsLoose2(HingeJoint2, _Joint);
      function HingeJoint2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _Joint.call.apply(_Joint, [this].concat(args)) || this;
        _this._axis = new miniprogram2.Vector3(1, 0, 0);
        _this._hingeFlags = 0;
        _this._useSpring = false;
        _this._jointMonitor = void 0;
        _this._limits = void 0;
        return _this;
      }
      var _proto = HingeJoint2.prototype;
      _proto._onAwake = function _onAwake() {
        var collider = this._collider;
        collider.localPosition = new miniprogram2.Vector3();
        collider.collider = this.entity.getComponent(Collider);
        this._nativeJoint = PhysicsManager._nativePhysics.createHingeJoint(collider.collider._nativeCollider);
      };
      _createClass2(HingeJoint2, [{
        key: "axis",
        get: function get() {
          return this._axis;
        },
        set: function set(value) {
          var axis = this._axis;
          if (value !== axis) {
            axis.copyFrom(value);
          }
          this._nativeJoint.setAxis(axis);
        }
      }, {
        key: "swingOffset",
        get: function get() {
          return this._collider.localPosition;
        },
        set: function set(value) {
          var swingOffset = this._collider.localPosition;
          if (value !== swingOffset) {
            swingOffset.copyFrom(value);
          }
          this._nativeJoint.setSwingOffset(swingOffset);
        }
      }, {
        key: "angle",
        get: function get() {
          return this._nativeJoint.getAngle();
        }
      }, {
        key: "velocity",
        get: function get() {
          return this._nativeJoint.getVelocity();
        }
      }, {
        key: "useLimits",
        get: function get() {
          return (this._hingeFlags & HingeJointFlag.LimitEnabled) == HingeJointFlag.LimitEnabled;
        },
        set: function set(value) {
          if (value !== this.useLimits) {
            this._hingeFlags |= HingeJointFlag.LimitEnabled;
          }
          this._nativeJoint.setHingeJointFlag(HingeJointFlag.LimitEnabled, value);
        }
      }, {
        key: "useMotor",
        get: function get() {
          return (this._hingeFlags & HingeJointFlag.DriveEnabled) == HingeJointFlag.DriveEnabled;
        },
        set: function set(value) {
          if (value !== this.useMotor) {
            this._hingeFlags |= HingeJointFlag.DriveEnabled;
          }
          this._nativeJoint.setHingeJointFlag(HingeJointFlag.DriveEnabled, value);
        }
      }, {
        key: "useSpring",
        get: function get() {
          return this._useSpring;
        },
        set: function set(value) {
          this._useSpring = value;
          this.limits = this._limits;
        }
      }, {
        key: "motor",
        get: function get() {
          return this._jointMonitor;
        },
        set: function set(value) {
          this._jointMonitor = value;
          this._nativeJoint.setDriveVelocity(value.targetVelocity);
          this._nativeJoint.setDriveForceLimit(value.forceLimit);
          this._nativeJoint.setDriveGearRatio(value.gearRation);
          this._nativeJoint.setHingeJointFlag(HingeJointFlag.DriveFreeSpin, value.freeSpin);
        }
      }, {
        key: "limits",
        get: function get() {
          return this._limits;
        },
        set: function set(value) {
          this._limits = value;
          if (this.useSpring) {
            this._nativeJoint.setSoftLimit(value.min, value.max, value.stiffness, value.damping);
          } else {
            this._nativeJoint.setHardLimit(value.min, value.max, value.contactDistance);
          }
        }
      }]);
      return HingeJoint2;
    }(Joint);
    var SpringJoint = /* @__PURE__ */ function(_Joint) {
      _inheritsLoose2(SpringJoint2, _Joint);
      function SpringJoint2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _Joint.call.apply(_Joint, [this].concat(args)) || this;
        _this._minDistance = 0;
        _this._maxDistance = 0;
        _this._tolerance = 0.25;
        _this._stiffness = 0;
        _this._damping = 0;
        return _this;
      }
      var _proto = SpringJoint2.prototype;
      _proto._onAwake = function _onAwake() {
        var collider = this._collider;
        collider.localPosition = new miniprogram2.Vector3();
        collider.collider = this.entity.getComponent(Collider);
        this._nativeJoint = PhysicsManager._nativePhysics.createSpringJoint(collider.collider._nativeCollider);
      };
      _createClass2(SpringJoint2, [{
        key: "swingOffset",
        get: function get() {
          return this._collider.localPosition;
        },
        set: function set(value) {
          var swingOffset = this._collider.localPosition;
          if (value !== swingOffset) {
            swingOffset.copyFrom(value);
          }
          this._nativeJoint.setSwingOffset(value);
        }
      }, {
        key: "minDistance",
        get: function get() {
          return this._minDistance;
        },
        set: function set(value) {
          this._minDistance = value;
          this._nativeJoint.setMinDistance(value);
        }
      }, {
        key: "maxDistance",
        get: function get() {
          return this._maxDistance;
        },
        set: function set(value) {
          this._maxDistance = value;
          this._nativeJoint.setMaxDistance(value);
        }
      }, {
        key: "tolerance",
        get: function get() {
          return this._tolerance;
        },
        set: function set(value) {
          this._tolerance = value;
          this._nativeJoint.setTolerance(value);
        }
      }, {
        key: "stiffness",
        get: function get() {
          return this._stiffness;
        },
        set: function set(value) {
          this._stiffness = value;
          this._nativeJoint.setStiffness(value);
        }
      }, {
        key: "damping",
        get: function get() {
          return this._damping;
        },
        set: function set(value) {
          this._damping = value;
          this._nativeJoint.setDamping(value);
        }
      }]);
      return SpringJoint2;
    }(Joint);
    var JointLimits = function JointLimits2() {
      this.max = 0;
      this.min = 0;
      this.contactDistance = -1;
      this.stiffness = 0;
      this.damping = 0;
    };
    var JointMotor = function JointMotor2() {
      this.targetVelocity = 0;
      this.forceLimit = Number.MAX_VALUE;
      this.gearRation = 1;
      this.freeSpin = false;
    };
    exports3.ControllerCollisionFlag = void 0;
    (function(ControllerCollisionFlag) {
      ControllerCollisionFlag[ControllerCollisionFlag["Sides"] = 1] = "Sides";
      ControllerCollisionFlag[ControllerCollisionFlag["Up"] = 2] = "Up";
      ControllerCollisionFlag[ControllerCollisionFlag["Down"] = 4] = "Down";
    })(exports3.ControllerCollisionFlag || (exports3.ControllerCollisionFlag = {}));
    var StaticCollider = /* @__PURE__ */ function(_Collider) {
      _inheritsLoose2(StaticCollider2, _Collider);
      function StaticCollider2(entity) {
        var _this;
        _this = _Collider.call(this, entity) || this;
        var transform = _this.entity.transform;
        _this._nativeCollider = PhysicsManager._nativePhysics.createStaticCollider(transform.worldPosition, transform.worldRotationQuaternion);
        return _this;
      }
      return StaticCollider2;
    }(Collider);
    var DynamicCollider = /* @__PURE__ */ function(_Collider) {
      _inheritsLoose2(DynamicCollider2, _Collider);
      function DynamicCollider2(entity) {
        var _this;
        _this = _Collider.call(this, entity) || this;
        _this._linearDamping = 0;
        _this._angularDamping = 0;
        _this._linearVelocity = new miniprogram2.Vector3();
        _this._angularVelocity = new miniprogram2.Vector3();
        _this._mass = 0;
        _this._centerOfMass = new miniprogram2.Vector3();
        _this._inertiaTensor = new miniprogram2.Vector3();
        _this._maxAngularVelocity = 0;
        _this._maxDepenetrationVelocity = 0;
        _this._sleepThreshold = 0;
        _this._solverIterations = 0;
        _this._isKinematic = false;
        _this._constraints = 0;
        _this._collisionDetectionMode = exports3.CollisionDetectionMode.Discrete;
        var transform = _this.entity.transform;
        _this._nativeCollider = PhysicsManager._nativePhysics.createDynamicCollider(transform.worldPosition, transform.worldRotationQuaternion);
        return _this;
      }
      var _proto = DynamicCollider2.prototype;
      _proto.applyForce = function applyForce(force) {
        this._nativeCollider.addForce(force);
      };
      _proto.applyTorque = function applyTorque(torque) {
        this._nativeCollider.addTorque(torque);
      };
      _proto.move = function move(positionOrRotation, rotation) {
        this._nativeCollider.move(positionOrRotation, rotation);
      };
      _proto.sleep = function sleep() {
        this._nativeCollider.sleep();
      };
      _proto.wakeUp = function wakeUp() {
        this._nativeCollider.wakeUp();
      };
      _proto._onLateUpdate = function _onLateUpdate() {
        var transform = this.entity.transform;
        var worldPosition = transform.worldPosition, worldRotationQuaternion = transform.worldRotationQuaternion;
        this._nativeCollider.getWorldTransform(worldPosition, worldRotationQuaternion);
        this._updateFlag.flag = false;
      };
      _createClass2(DynamicCollider2, [{
        key: "linearDamping",
        get: function get() {
          return this._linearDamping;
        },
        set: function set(value) {
          this._linearDamping = value;
          this._nativeCollider.setLinearDamping(value);
        }
      }, {
        key: "angularDamping",
        get: function get() {
          return this._angularDamping;
        },
        set: function set(value) {
          this._angularDamping = value;
          this._nativeCollider.setAngularDamping(value);
        }
      }, {
        key: "linearVelocity",
        get: function get() {
          return this._linearVelocity;
        },
        set: function set(value) {
          if (this._linearVelocity !== value) {
            this._linearVelocity.copyFrom(value);
          }
          this._nativeCollider.setLinearVelocity(this._linearVelocity);
        }
      }, {
        key: "angularVelocity",
        get: function get() {
          return this._angularVelocity;
        },
        set: function set(value) {
          if (this._angularVelocity !== value) {
            this._angularVelocity.copyFrom(value);
          }
          this._nativeCollider.setAngularVelocity(this._angularVelocity);
        }
      }, {
        key: "mass",
        get: function get() {
          return this._mass;
        },
        set: function set(value) {
          this._mass = value;
          this._nativeCollider.setMass(value);
        }
      }, {
        key: "centerOfMass",
        get: function get() {
          return this._centerOfMass;
        },
        set: function set(value) {
          if (this._centerOfMass !== value) {
            this._centerOfMass.copyFrom(value);
          }
          this._nativeCollider.setCenterOfMass(this._centerOfMass);
        }
      }, {
        key: "inertiaTensor",
        get: function get() {
          return this._inertiaTensor;
        },
        set: function set(value) {
          if (this._inertiaTensor !== value) {
            this._inertiaTensor.copyFrom(value);
          }
          this._nativeCollider.setInertiaTensor(this._inertiaTensor);
        }
      }, {
        key: "maxAngularVelocity",
        get: function get() {
          return this._maxAngularVelocity;
        },
        set: function set(value) {
          this._maxAngularVelocity = value;
          this._nativeCollider.setMaxAngularVelocity(value);
        }
      }, {
        key: "maxDepenetrationVelocity",
        get: function get() {
          return this._maxDepenetrationVelocity;
        },
        set: function set(value) {
          this._maxDepenetrationVelocity = value;
          this._nativeCollider.setMaxDepenetrationVelocity(value);
        }
      }, {
        key: "sleepThreshold",
        get: function get() {
          return this._sleepThreshold;
        },
        set: function set(value) {
          this._sleepThreshold = value;
          this._nativeCollider.setSleepThreshold(value);
        }
      }, {
        key: "solverIterations",
        get: function get() {
          return this._solverIterations;
        },
        set: function set(value) {
          this._solverIterations = value;
          this._nativeCollider.setSolverIterations(value);
        }
      }, {
        key: "isKinematic",
        get: function get() {
          return this._isKinematic;
        },
        set: function set(value) {
          this._isKinematic = value;
          this._nativeCollider.setIsKinematic(value);
        }
      }, {
        key: "constraints",
        get: function get() {
          return this._constraints;
        },
        set: function set(value) {
          this._constraints = value;
          this._nativeCollider.setConstraints(value);
        }
      }, {
        key: "collisionDetectionMode",
        get: function get() {
          return this._collisionDetectionMode;
        },
        set: function set(value) {
          this._collisionDetectionMode = value;
          this._nativeCollider.setCollisionDetectionMode(value);
        }
      }]);
      return DynamicCollider2;
    }(Collider);
    exports3.CollisionDetectionMode = void 0;
    (function(CollisionDetectionMode) {
      CollisionDetectionMode[CollisionDetectionMode["Discrete"] = 0] = "Discrete";
      CollisionDetectionMode[CollisionDetectionMode["Continuous"] = 1] = "Continuous";
      CollisionDetectionMode[CollisionDetectionMode["ContinuousDynamic"] = 2] = "ContinuousDynamic";
      CollisionDetectionMode[CollisionDetectionMode["ContinuousSpeculative"] = 3] = "ContinuousSpeculative";
    })(exports3.CollisionDetectionMode || (exports3.CollisionDetectionMode = {}));
    exports3.DynamicColliderConstraints = void 0;
    (function(DynamicColliderConstraints) {
      DynamicColliderConstraints[DynamicColliderConstraints["None"] = 0] = "None";
      DynamicColliderConstraints[DynamicColliderConstraints["FreezePositionX"] = 1] = "FreezePositionX";
      DynamicColliderConstraints[DynamicColliderConstraints["FreezePositionY"] = 2] = "FreezePositionY";
      DynamicColliderConstraints[DynamicColliderConstraints["FreezePositionZ"] = 4] = "FreezePositionZ";
      DynamicColliderConstraints[DynamicColliderConstraints["FreezeRotationX"] = 8] = "FreezeRotationX";
      DynamicColliderConstraints[DynamicColliderConstraints["FreezeRotationY"] = 16] = "FreezeRotationY";
      DynamicColliderConstraints[DynamicColliderConstraints["FreezeRotationZ"] = 32] = "FreezeRotationZ";
    })(exports3.DynamicColliderConstraints || (exports3.DynamicColliderConstraints = {}));
    exports3.PointerPhase = void 0;
    (function(PointerPhase) {
      PointerPhase[PointerPhase["Down"] = 0] = "Down";
      PointerPhase[PointerPhase["Move"] = 1] = "Move";
      PointerPhase[PointerPhase["Up"] = 2] = "Up";
      PointerPhase[PointerPhase["Leave"] = 3] = "Leave";
    })(exports3.PointerPhase || (exports3.PointerPhase = {}));
    exports3.PointerButton = void 0;
    (function(PointerButton) {
      PointerButton[PointerButton["Primary"] = 0] = "Primary";
      PointerButton[PointerButton["Auxiliary"] = 1] = "Auxiliary";
      PointerButton[PointerButton["Secondary"] = 2] = "Secondary";
      PointerButton[PointerButton["XButton1"] = 3] = "XButton1";
      PointerButton[PointerButton["XButton2"] = 4] = "XButton2";
      PointerButton[PointerButton["XButton3"] = 5] = "XButton3";
      PointerButton[PointerButton["XButton4"] = 6] = "XButton4";
      PointerButton[PointerButton["XButton5"] = 7] = "XButton5";
      PointerButton[PointerButton["XButton6"] = 8] = "XButton6";
      PointerButton[PointerButton["XButton7"] = 9] = "XButton7";
      PointerButton[PointerButton["XButton8"] = 10] = "XButton8";
    })(exports3.PointerButton || (exports3.PointerButton = {}));
    var Pointer = function Pointer2(id) {
      this.id = void 0;
      this.phase = exports3.PointerPhase.Leave;
      this.position = new miniprogram2.Vector2();
      this._uniqueID = void 0;
      this.id = id;
    };
    var PointerManager = /* @__PURE__ */ function() {
      function PointerManager2(engine, htmlCanvas) {
        this._pointers = [];
        this._movingDelta = new miniprogram2.Vector2();
        this._multiPointerEnabled = true;
        this._buttons = 0;
        this._upMap = [];
        this._downMap = [];
        this._downList = new DisorderedArray2();
        this._upList = new DisorderedArray2();
        this._currentPosition = new miniprogram2.Vector2();
        this._currentPressedEntity = void 0;
        this._currentEnteredEntity = void 0;
        this._engine = void 0;
        this._canvas = void 0;
        this._htmlCanvas = void 0;
        this._nativeEvents = [];
        this._pointerPool = void 0;
        this._keyEventList = [];
        this._keyEventCount = 0;
        this._needOverallPointers = false;
        this._hadListener = false;
        this._lastPositionFrameCount = 0;
        this._engine = engine;
        this._canvas = engine.canvas;
        this._htmlCanvas = htmlCanvas;
        htmlCanvas.oncontextmenu = function(event) {
          return false;
        };
        var onPointerEvent = this._onPointerEvent = this._onPointerEvent.bind(this);
        htmlCanvas.addEventListener("pointerdown", onPointerEvent);
        htmlCanvas.addEventListener("pointerup", onPointerEvent);
        htmlCanvas.addEventListener("pointerout", onPointerEvent);
        htmlCanvas.addEventListener("pointermove", onPointerEvent);
        this._hadListener = true;
        this._pointerPool = new Array(11);
      }
      var _proto = PointerManager2.prototype;
      _proto._update = function _update(frameCount) {
        this._needOverallPointers && this._overallPointers();
        this._downList.length = 0;
        this._upList.length = 0;
        this._movingDelta.set(0, 0);
        this._nativeEvents.length > 0 && this._handlePointerEvent(this._nativeEvents, frameCount);
        this._pointers.length > 0 && (this._lastPositionFrameCount = frameCount);
        if (this._engine.physicsManager._initialized) {
          var rayCastEntity = this._pointerRayCast();
          var keyEventCount = this._keyEventCount;
          if (keyEventCount > 0) {
            var keyEventList = this._keyEventList;
            for (var i = 0; i < keyEventCount; i++) {
              switch (keyEventList[i]) {
                case PointerKeyEvent.Down:
                  this._firePointerDown(rayCastEntity);
                  break;
                case PointerKeyEvent.Up:
                  this._firePointerUpAndClick(rayCastEntity);
                  break;
              }
            }
            this._firePointerExitAndEnter(rayCastEntity);
            keyEventList[keyEventCount - 1] === PointerKeyEvent.Leave && (this._currentPressedEntity = null);
            this._keyEventCount = 0;
          } else {
            this._firePointerDrag();
            this._firePointerExitAndEnter(rayCastEntity);
          }
        }
      };
      _proto._onFocus = function _onFocus() {
        if (!this._hadListener) {
          var htmlCanvas = this._htmlCanvas, onPointerEvent = this._onPointerEvent;
          htmlCanvas.addEventListener("pointerdown", onPointerEvent);
          htmlCanvas.addEventListener("pointerup", onPointerEvent);
          htmlCanvas.addEventListener("pointerout", onPointerEvent);
          htmlCanvas.addEventListener("pointermove", onPointerEvent);
          this._hadListener = true;
        }
      };
      _proto._onBlur = function _onBlur() {
        if (this._hadListener) {
          var htmlCanvas = this._htmlCanvas, onPointerEvent = this._onPointerEvent;
          htmlCanvas.removeEventListener("pointerdown", onPointerEvent);
          htmlCanvas.removeEventListener("pointerup", onPointerEvent);
          htmlCanvas.removeEventListener("pointerout", onPointerEvent);
          htmlCanvas.removeEventListener("pointermove", onPointerEvent);
          this._nativeEvents.length = 0;
          this._pointerPool.length = 0;
          this._currentEnteredEntity = null;
          this._currentPressedEntity = null;
          this._downList.length = 0;
          this._upList.length = 0;
          this._hadListener = false;
        }
      };
      _proto._destroy = function _destroy() {
        if (this._hadListener) {
          var htmlCanvas = this._htmlCanvas, onPointerEvent = this._onPointerEvent;
          htmlCanvas.removeEventListener("pointerdown", onPointerEvent);
          htmlCanvas.removeEventListener("pointerup", onPointerEvent);
          htmlCanvas.removeEventListener("pointerout", onPointerEvent);
          htmlCanvas.removeEventListener("pointermove", onPointerEvent);
          this._hadListener = false;
        }
        this._nativeEvents.length = 0;
        this._pointerPool.length = 0;
        this._pointers.length = 0;
        this._currentPosition = null;
        this._currentEnteredEntity = null;
        this._currentPressedEntity = null;
        this._engine = null;
        this._canvas = null;
      };
      _proto._onPointerEvent = function _onPointerEvent(evt) {
        evt.cancelable && evt.preventDefault();
        evt.type === "pointerdown" && this._htmlCanvas.focus();
        this._nativeEvents.push(evt);
      };
      _proto._overallPointers = function _overallPointers() {
        var pointers = this._pointers;
        var deleteCount = 0;
        var totalCount = pointers.length;
        for (var i = 0; i < totalCount; i++) {
          if (pointers[i].phase === exports3.PointerPhase.Leave) {
            deleteCount++;
          } else {
            if (deleteCount > 0) {
              pointers[i - deleteCount] = pointers[i];
            }
          }
        }
        pointers.length = totalCount - deleteCount;
        this._needOverallPointers = false;
      };
      _proto._getIndexByPointerID = function _getIndexByPointerID(pointerId) {
        var pointers = this._pointers;
        for (var i = pointers.length - 1; i >= 0; i--) {
          if (pointers[i]._uniqueID === pointerId) {
            return i;
          }
        }
        return -1;
      };
      _proto._addPointer = function _addPointer(pointerId, x, y, phase) {
        var pointers = this._pointers;
        var lastCount = pointers.length;
        if (lastCount === 0 || this._multiPointerEnabled) {
          var pointerPool = this._pointerPool;
          var i = 0;
          for (; i < lastCount; i++) {
            if (pointers[i].id > i) {
              break;
            }
          }
          var pointer = pointerPool[i];
          if (!pointer) {
            pointer = pointerPool[i] = new Pointer(i);
          }
          pointer._uniqueID = pointerId;
          pointer.position.set(x, y);
          pointer.phase = phase;
          pointers.splice(i, 0, pointer);
        }
      };
      _proto._removePointer = function _removePointer(pointerIndex) {
        var leavePointer = this._pointers[pointerIndex];
        leavePointer.phase = exports3.PointerPhase.Leave;
      };
      _proto._updatePointer = function _updatePointer(pointerIndex, x, y, phase) {
        var updatedPointer = this._pointers[pointerIndex];
        updatedPointer.position.set(x, y);
        updatedPointer.phase = phase;
      };
      _proto._handlePointerEvent = function _handlePointerEvent(nativeEvents, frameCount) {
        var pointers = this._pointers, keyEventList = this._keyEventList, upMap = this._upMap, downMap = this._downMap, upList = this._upList, downList = this._downList;
        var activePointerCount = pointers.length;
        var pixelRatioW = this._canvas.width / this._htmlCanvas.clientWidth;
        var pixelRatioH = this._canvas.height / this._htmlCanvas.clientHeight;
        var nativeEventsLen = nativeEvents.length;
        for (var i = 0; i < nativeEventsLen; i++) {
          var evt = nativeEvents[i];
          var pointerButton = evt.button | exports3.PointerButton.Primary;
          var pointerIndex = this._getIndexByPointerID(evt.pointerId);
          switch (evt.type) {
            case "pointerdown":
              if (pointerIndex === -1) {
                this._addPointer(evt.pointerId, evt.offsetX * pixelRatioW, evt.offsetY * pixelRatioH, exports3.PointerPhase.Down);
                activePointerCount++;
              } else {
                this._updatePointer(pointerIndex, evt.offsetX * pixelRatioW, evt.offsetY * pixelRatioH, exports3.PointerPhase.Down);
              }
              activePointerCount === 1 && (keyEventList[this._keyEventCount++] = PointerKeyEvent.Down);
              downList.add(pointerButton);
              downMap[pointerButton] = frameCount;
              break;
            case "pointerup":
              if (pointerIndex >= 0) {
                this._updatePointer(pointerIndex, evt.offsetX * pixelRatioW, evt.offsetY * pixelRatioH, exports3.PointerPhase.Up);
                activePointerCount === 1 && (keyEventList[this._keyEventCount++] = PointerKeyEvent.Up);
              }
              upList.add(pointerButton);
              upMap[pointerButton] = frameCount;
              break;
            case "pointermove":
              if (pointerIndex === -1) {
                this._addPointer(evt.pointerId, evt.offsetX * pixelRatioW, evt.offsetY * pixelRatioH, exports3.PointerPhase.Move);
                activePointerCount++;
              } else {
                this._updatePointer(pointerIndex, evt.offsetX * pixelRatioW, evt.offsetY * pixelRatioH, exports3.PointerPhase.Move);
              }
              break;
            case "pointerout":
              if (pointerIndex >= 0) {
                this._removePointer(pointerIndex);
                --activePointerCount === 0 && (keyEventList[this._keyEventCount++] = PointerKeyEvent.Leave);
                this._needOverallPointers = true;
              }
              break;
          }
        }
        this._buttons = nativeEvents[nativeEventsLen - 1].buttons;
        var pointerCount = pointers.length;
        if (pointerCount > 0) {
          var currentPosition = this._currentPosition;
          var lastX = currentPosition.x, lastY = currentPosition.y;
          if (activePointerCount === 0) {
            var lastNativeEvent = nativeEvents[nativeEventsLen - 1];
            currentPosition.set(lastNativeEvent.offsetX * pixelRatioW, lastNativeEvent.offsetY * pixelRatioH);
          } else {
            currentPosition.set(0, 0);
            for (var _i = 0; _i < pointerCount; _i++) {
              currentPosition.add(pointers[_i].position);
            }
            currentPosition.scale(1 / pointerCount);
          }
          if (this._lastPositionFrameCount === frameCount - 1) {
            this._movingDelta.set(currentPosition.x - lastX, currentPosition.y - lastY);
          }
        }
        nativeEvents.length = 0;
      };
      _proto._pointerRayCast = function _pointerRayCast() {
        if (this._pointers.length > 0) {
          var point = PointerManager2._tempPoint, ray = PointerManager2._tempRay, hitResult = PointerManager2._tempHitResult;
          var cameras = this._engine.sceneManager.activeScene._activeCameras;
          var x = this._currentPosition.x / this._canvas.width;
          var y = this._currentPosition.y / this._canvas.height;
          for (var i = cameras.length - 1; i >= 0; i--) {
            var camera = cameras[i];
            if (!camera.enabled || camera.renderTarget) {
              continue;
            }
            var _camera$viewport = camera.viewport, vpX = _camera$viewport.x, vpY = _camera$viewport.y, vpW = _camera$viewport.z, vpH = _camera$viewport.w;
            if (x >= vpX && y >= vpY && x - vpX <= vpW && y - vpY <= vpH) {
              point.set((x - vpX) / vpW, (y - vpY) / vpH);
              if (this._engine.physicsManager.raycast(camera.viewportPointToRay(point, ray), Number.MAX_VALUE, camera.cullingMask, hitResult)) {
                return hitResult.entity;
              } else if (camera.clearFlags & exports3.CameraClearFlags.Color) {
                return null;
              }
            }
          }
        }
        return null;
      };
      _proto._firePointerDrag = function _firePointerDrag() {
        if (this._currentPressedEntity) {
          var scripts = this._currentPressedEntity._scripts;
          for (var i = scripts.length - 1; i >= 0; i--) {
            var script = scripts.get(i);
            script._waitHandlingInValid || script.onPointerDrag();
          }
        }
      };
      _proto._firePointerExitAndEnter = function _firePointerExitAndEnter(rayCastEntity) {
        if (this._currentEnteredEntity !== rayCastEntity) {
          if (this._currentEnteredEntity) {
            var scripts = this._currentEnteredEntity._scripts;
            for (var i = scripts.length - 1; i >= 0; i--) {
              var script = scripts.get(i);
              script._waitHandlingInValid || script.onPointerExit();
            }
          }
          if (rayCastEntity) {
            var _scripts = rayCastEntity._scripts;
            for (var _i2 = _scripts.length - 1; _i2 >= 0; _i2--) {
              var _script = _scripts.get(_i2);
              _script._waitHandlingInValid || _script.onPointerEnter();
            }
          }
          this._currentEnteredEntity = rayCastEntity;
        }
      };
      _proto._firePointerDown = function _firePointerDown(rayCastEntity) {
        if (rayCastEntity) {
          var scripts = rayCastEntity._scripts;
          for (var i = scripts.length - 1; i >= 0; i--) {
            var script = scripts.get(i);
            script._waitHandlingInValid || script.onPointerDown();
          }
        }
        this._currentPressedEntity = rayCastEntity;
      };
      _proto._firePointerUpAndClick = function _firePointerUpAndClick(rayCastEntity) {
        var pressedEntity = this._currentPressedEntity;
        if (pressedEntity) {
          var sameTarget = pressedEntity === rayCastEntity;
          var scripts = pressedEntity._scripts;
          for (var i = scripts.length - 1; i >= 0; i--) {
            var script = scripts.get(i);
            if (!script._waitHandlingInValid) {
              sameTarget && script.onPointerClick();
              script.onPointerUp();
            }
          }
          this._currentPressedEntity = null;
        }
      };
      return PointerManager2;
    }();
    PointerManager.Buttons = [1, 4, 2, 8, 16, 32, 64, 128, 256, 512, 1024];
    PointerManager._tempRay = new miniprogram2.Ray();
    PointerManager._tempPoint = new miniprogram2.Vector2();
    PointerManager._tempHitResult = new HitResult();
    var PointerKeyEvent;
    (function(PointerKeyEvent2) {
      PointerKeyEvent2[PointerKeyEvent2["Down"] = 0] = "Down";
      PointerKeyEvent2[PointerKeyEvent2["Up"] = 1] = "Up";
      PointerKeyEvent2[PointerKeyEvent2["Leave"] = 2] = "Leave";
    })(PointerKeyEvent || (PointerKeyEvent = {}));
    var WheelManager = /* @__PURE__ */ function() {
      function WheelManager2(htmlCanvas) {
        this._delta = new miniprogram2.Vector3();
        this._nativeEvents = [];
        this._canvas = void 0;
        this._hadListener = void 0;
        this._onWheelEvent = this._onWheelEvent.bind(this);
        htmlCanvas.addEventListener("wheel", this._onWheelEvent);
        this._canvas = htmlCanvas;
        this._hadListener = true;
      }
      var _proto = WheelManager2.prototype;
      _proto._update = function _update() {
        var delta = this._delta;
        delta.set(0, 0, 0);
        var nativeEvents = this._nativeEvents;
        if (nativeEvents.length > 0) {
          for (var i = nativeEvents.length - 1; i >= 0; i--) {
            var evt = nativeEvents[i];
            delta.x += evt.deltaX;
            delta.y += evt.deltaY;
            delta.z += evt.deltaZ;
          }
          nativeEvents.length = 0;
        }
      };
      _proto._onFocus = function _onFocus() {
        if (!this._hadListener) {
          this._canvas.addEventListener("wheel", this._onWheelEvent);
          this._hadListener = true;
        }
      };
      _proto._onBlur = function _onBlur() {
        if (this._hadListener) {
          this._canvas.removeEventListener("wheel", this._onWheelEvent);
          this._nativeEvents.length = 0;
          this._delta.set(0, 0, 0);
          this._hadListener = false;
        }
      };
      _proto._destroy = function _destroy() {
        if (this._hadListener) {
          this._canvas.removeEventListener("wheel", this._onWheelEvent);
          this._hadListener = false;
        }
        this._nativeEvents = null;
      };
      _proto._onWheelEvent = function _onWheelEvent(evt) {
        evt.cancelable && evt.preventDefault();
        this._nativeEvents.push(evt);
      };
      return WheelManager2;
    }();
    var InputManager = /* @__PURE__ */ function() {
      var _proto = InputManager2.prototype;
      _proto.isKeyHeldDown = function isKeyHeldDown(key) {
        if (this._initialized) {
          if (key === void 0) {
            return this._keyboardManager._curFrameHeldDownList.length > 0;
          } else {
            return this._keyboardManager._curHeldDownKeyToIndexMap[key] != null;
          }
        } else {
          return false;
        }
      };
      _proto.isKeyDown = function isKeyDown(key) {
        if (this._initialized) {
          if (key === void 0) {
            return this._keyboardManager._curFrameDownList.length > 0;
          } else {
            return this._keyboardManager._downKeyToFrameCountMap[key] === this._curFrameCount;
          }
        } else {
          return false;
        }
      };
      _proto.isKeyUp = function isKeyUp(key) {
        if (this._initialized) {
          if (key === void 0) {
            return this._keyboardManager._curFrameUpList.length > 0;
          } else {
            return this._keyboardManager._upKeyToFrameCountMap[key] === this._curFrameCount;
          }
        } else {
          return false;
        }
      };
      _proto.isPointerHeldDown = function isPointerHeldDown(pointerButton) {
        if (this._initialized) {
          if (pointerButton === void 0) {
            return this._pointerManager._buttons !== 0;
          } else {
            return (this._pointerManager._buttons & PointerManager.Buttons[pointerButton]) !== 0;
          }
        } else {
          return false;
        }
      };
      _proto.isPointerDown = function isPointerDown(pointerButton) {
        if (this._initialized) {
          if (pointerButton === void 0) {
            return this._pointerManager._downList.length > 0;
          } else {
            return this._pointerManager._downMap[pointerButton] === this._curFrameCount;
          }
        } else {
          return false;
        }
      };
      _proto.isPointerUp = function isPointerUp(pointerButton) {
        if (this._initialized) {
          if (pointerButton === void 0) {
            return this._pointerManager._upList.length > 0;
          } else {
            return this._pointerManager._upMap[pointerButton] === this._curFrameCount;
          }
        } else {
          return false;
        }
      };
      function InputManager2(engine) {
        this._initialized = false;
        this._curFrameCount = 0;
        this._wheelManager = void 0;
        this._pointerManager = void 0;
        this._keyboardManager = void 0;
        var canvas = engine._canvas._webCanvas;
        if (typeof miniprogramAdapter2.OffscreenCanvas === "undefined" || !(canvas instanceof miniprogramAdapter2.OffscreenCanvas)) {
          this._wheelManager = new WheelManager(canvas);
          this._pointerManager = new PointerManager(engine, canvas);
          this._keyboardManager = new KeyboardManager(canvas);
          this._onBlur = this._onBlur.bind(this);
          miniprogramAdapter2.window.addEventListener("blur", this._onBlur);
          this._onFocus = this._onFocus.bind(this);
          miniprogramAdapter2.window.addEventListener("focus", this._onFocus);
          this._initialized = true;
        }
      }
      _proto._update = function _update() {
        if (this._initialized) {
          ++this._curFrameCount;
          this._wheelManager._update();
          this._pointerManager._update(this._curFrameCount);
          this._keyboardManager._update(this._curFrameCount);
        }
      };
      _proto._destroy = function _destroy() {
        if (this._initialized) {
          miniprogramAdapter2.window.removeEventListener("blur", this._onBlur);
          miniprogramAdapter2.window.removeEventListener("focus", this._onFocus);
          this._wheelManager._destroy();
          this._pointerManager._destroy();
          this._keyboardManager._destroy();
        }
      };
      _proto._onBlur = function _onBlur() {
        this._wheelManager._onBlur();
        this._pointerManager._onBlur();
        this._keyboardManager._onBlur();
      };
      _proto._onFocus = function _onFocus() {
        this._wheelManager._onFocus();
        this._pointerManager._onFocus();
        this._keyboardManager._onFocus();
      };
      _createClass2(InputManager2, [{
        key: "pointers",
        get: function get() {
          return this._initialized ? this._pointerManager._pointers : null;
        }
      }, {
        key: "multiPointerEnabled",
        get: function get() {
          return this._initialized ? this._pointerManager._multiPointerEnabled : false;
        },
        set: function set(enabled) {
          this._initialized && (this._pointerManager._multiPointerEnabled = enabled);
        }
      }, {
        key: "wheelDelta",
        get: function get() {
          return this._initialized ? this._wheelManager._delta : null;
        }
      }, {
        key: "pointerMovingDelta",
        get: function get() {
          return this._initialized ? this._pointerManager._movingDelta : null;
        }
      }, {
        key: "pointerPosition",
        get: function get() {
          return this._initialized && this._pointerManager._pointers.length > 0 ? this._pointerManager._currentPosition : null;
        }
      }]);
      return InputManager2;
    }();
    exports3.RenderQueueType = void 0;
    (function(RenderQueueType) {
      RenderQueueType[RenderQueueType["Opaque"] = 0] = "Opaque";
      RenderQueueType[RenderQueueType["AlphaTest"] = 1] = "AlphaTest";
      RenderQueueType[RenderQueueType["Transparent"] = 2] = "Transparent";
    })(exports3.RenderQueueType || (exports3.RenderQueueType = {}));
    var RefObject = /* @__PURE__ */ function(_EngineObject) {
      _inheritsLoose2(RefObject2, _EngineObject);
      function RefObject2(engine) {
        var _this;
        _this = _EngineObject.call(this, engine) || this;
        _this.isGCIgnored = false;
        _this._refCount = 0;
        engine.resourceManager._addRefObject(_this.instanceId, _assertThisInitialized(_this));
        return _this;
      }
      var _proto = RefObject2.prototype;
      _proto.destroy = function destroy(force) {
        if (force === void 0) {
          force = false;
        }
        if (this._destroyed)
          return true;
        if (!force && this._refCount !== 0)
          return false;
        var resourceManager = this._engine.resourceManager;
        if (resourceManager) {
          _EngineObject.prototype.destroy.call(this);
          resourceManager._deleteRefObject(this.instanceId);
        }
        var refCount = this._getRefCount();
        if (refCount > 0) {
          this._addRefCount(-refCount);
        }
        this._engine = null;
        this._onDestroy();
        return true;
      };
      _proto._getRefCount = function _getRefCount() {
        return this._refCount;
      };
      _proto._addRefCount = function _addRefCount(value) {
        this._refCount += value;
      };
      _proto._addToResourceManager = function _addToResourceManager(path) {
        this._engine.resourceManager._addAsset(path, this);
      };
      _createClass2(RefObject2, [{
        key: "refCount",
        get: function get() {
          return this._refCount;
        }
      }]);
      return RefObject2;
    }(EngineObject);
    var ShaderDataGroup;
    (function(ShaderDataGroup2) {
      ShaderDataGroup2[ShaderDataGroup2["Scene"] = 0] = "Scene";
      ShaderDataGroup2[ShaderDataGroup2["Camera"] = 1] = "Camera";
      ShaderDataGroup2[ShaderDataGroup2["Renderer"] = 2] = "Renderer";
      ShaderDataGroup2[ShaderDataGroup2["Material"] = 3] = "Material";
    })(ShaderDataGroup || (ShaderDataGroup = {}));
    var Texture = /* @__PURE__ */ function(_RefObject) {
      _inheritsLoose2(Texture2, _RefObject);
      function Texture2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _RefObject.call.apply(_RefObject, [this].concat(args)) || this;
        _this.name = void 0;
        _this._platformTexture = void 0;
        _this._mipmap = void 0;
        _this._format = void 0;
        _this._width = void 0;
        _this._height = void 0;
        _this._mipmapCount = void 0;
        _this._wrapModeU = void 0;
        _this._wrapModeV = void 0;
        _this._filterMode = void 0;
        _this._anisoLevel = 1;
        return _this;
      }
      var _proto = Texture2.prototype;
      _proto.generateMipmaps = function generateMipmaps() {
        if (!this._mipmap)
          return;
        this._platformTexture.generateMipmaps();
      };
      _proto._onDestroy = function _onDestroy() {
        this._platformTexture.destroy();
        this._platformTexture = null;
      };
      _proto._getMaxMiplevel = function _getMaxMiplevel(size) {
        return Math.floor(Math.log2(size));
      };
      _proto._getMipmapCount = function _getMipmapCount() {
        return this._mipmap ? Math.floor(Math.log2(Math.max(this._width, this._height))) + 1 : 1;
      };
      _createClass2(Texture2, [{
        key: "format",
        get: function get() {
          return this._format;
        }
      }, {
        key: "width",
        get: function get() {
          return this._width;
        }
      }, {
        key: "height",
        get: function get() {
          return this._height;
        }
      }, {
        key: "wrapModeU",
        get: function get() {
          return this._wrapModeU;
        },
        set: function set(value) {
          if (value === this._wrapModeU)
            return;
          this._wrapModeU = value;
          this._platformTexture.wrapModeU = value;
        }
      }, {
        key: "wrapModeV",
        get: function get() {
          return this._wrapModeV;
        },
        set: function set(value) {
          if (value === this._wrapModeV)
            return;
          this._wrapModeV = value;
          this._platformTexture.wrapModeV = value;
        }
      }, {
        key: "mipmapCount",
        get: function get() {
          return this._mipmapCount;
        }
      }, {
        key: "filterMode",
        get: function get() {
          return this._filterMode;
        },
        set: function set(value) {
          if (value === this._filterMode)
            return;
          this._filterMode = value;
          this._platformTexture.filterMode = value;
        }
      }, {
        key: "anisoLevel",
        get: function get() {
          return this._anisoLevel;
        },
        set: function set(value) {
          var max = this._engine._hardwareRenderer.capability.maxAnisoLevel;
          if (value > max) {
            Logger.warn("anisoLevel:" + value + ", exceeds the limit and is automatically downgraded to:" + max);
            value = max;
          }
          if (value < 1) {
            Logger.warn("anisoLevel:" + value + ", must be greater than 0, and is automatically downgraded to 1");
            value = 1;
          }
          if (value === this._anisoLevel)
            return;
          this._anisoLevel = value;
          this._platformTexture.anisoLevel = value;
        }
      }]);
      return Texture2;
    }(RefObject);
    exports3.ShaderPropertyType = void 0;
    (function(ShaderPropertyType) {
      ShaderPropertyType[ShaderPropertyType["Float"] = 0] = "Float";
      ShaderPropertyType[ShaderPropertyType["Int"] = 1] = "Int";
      ShaderPropertyType[ShaderPropertyType["Vector2"] = 2] = "Vector2";
      ShaderPropertyType[ShaderPropertyType["Vector3"] = 3] = "Vector3";
      ShaderPropertyType[ShaderPropertyType["Vector4"] = 4] = "Vector4";
      ShaderPropertyType[ShaderPropertyType["Matrix"] = 5] = "Matrix";
      ShaderPropertyType[ShaderPropertyType["Color"] = 6] = "Color";
      ShaderPropertyType[ShaderPropertyType["Texture"] = 7] = "Texture";
      ShaderPropertyType[ShaderPropertyType["FloatArray"] = 8] = "FloatArray";
      ShaderPropertyType[ShaderPropertyType["IntArray"] = 9] = "IntArray";
      ShaderPropertyType[ShaderPropertyType["TextureArray"] = 10] = "TextureArray";
    })(exports3.ShaderPropertyType || (exports3.ShaderPropertyType = {}));
    var common = "#define GLSLIFY 1\n#define PI 3.14159265359\n#define RECIPROCAL_PI 0.31830988618\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2(float x){return x*x;}vec4 RGBMToLinear(vec4 value,float maxRange){return vec4(value.rgb*value.a*maxRange,1.0);}vec4 gammaToLinear(vec4 srgbIn){return vec4(pow(srgbIn.rgb,vec3(2.2)),srgbIn.a);}vec4 linearToGamma(vec4 linearIn){return vec4(pow(linearIn.rgb,vec3(1.0/2.2)),linearIn.a);}";
    var common_vert = "#define GLSLIFY 1\nattribute vec3 POSITION;\n#ifdef O3_HAS_UV\nattribute vec2 TEXCOORD_0;\n#endif\n#ifdef O3_HAS_UV1\nattribute vec2 TEXCOORD_1;\n#endif\n#ifdef O3_HAS_SKIN\nattribute vec4 JOINTS_0;attribute vec4 WEIGHTS_0;\n#ifdef O3_USE_JOINT_TEXTURE\nuniform sampler2D u_jointSampler;uniform float u_jointCount;mat4 getJointMatrix(sampler2D smp,float index){float base=index/u_jointCount;float hf=0.5/u_jointCount;float v=base+hf;vec4 m0=texture2D(smp,vec2(0.125,v));vec4 m1=texture2D(smp,vec2(0.375,v));vec4 m2=texture2D(smp,vec2(0.625,v));vec4 m3=texture2D(smp,vec2(0.875,v));return mat4(m0,m1,m2,m3);}\n#else\nuniform mat4 u_jointMatrix[O3_JOINTS_NUM];\n#endif\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\nattribute vec4 COLOR_0;\n#endif\nuniform mat4 u_localMat;uniform mat4 u_modelMat;uniform mat4 u_viewMat;uniform mat4 u_projMat;uniform mat4 u_MVMat;uniform mat4 u_MVPMat;uniform mat4 u_normalMat;uniform vec3 u_cameraPos;uniform vec4 u_tilingOffset;\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nattribute vec3 NORMAL;\n#endif\n#ifdef O3_HAS_TANGENT\nattribute vec4 TANGENT;\n#endif\n#endif\n";
    var common_frag = "#define GLSLIFY 1\nuniform mat4 u_localMat;uniform mat4 u_modelMat;uniform mat4 u_viewMat;uniform mat4 u_projMat;uniform mat4 u_MVMat;uniform mat4 u_MVPMat;uniform mat4 u_normalMat;uniform vec3 u_cameraPos;";
    var color_share = "#define GLSLIFY 1\n#ifdef O3_HAS_VERTEXCOLOR\nvarying vec4 v_color;\n#endif\n";
    var normal_share = "#define GLSLIFY 1\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nvarying vec3 v_normal;\n#if defined(O3_HAS_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\nvarying mat3 v_TBN;\n#endif\n#endif\n#endif\n";
    var uv_share = "#define GLSLIFY 1\nvarying vec2 v_uv;\n#ifdef O3_HAS_UV1\nvarying vec2 v_uv1;\n#endif\n";
    var worldpos_share = "#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvarying vec3 v_pos;\n#endif\n";
    var shadow_share = "#define GLSLIFY 1\n#ifdef O3_GENERATE_SHADOW_MAP\nuniform mat4 u_viewMatFromLight;uniform mat4 u_projMatFromLight;\n#endif\n#ifdef O3_SHADOW_MAP_COUNT\nuniform mat4 u_viewMatFromLight[O3_SHADOW_MAP_COUNT];uniform mat4 u_projMatFromLight[O3_SHADOW_MAP_COUNT];varying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];\n#endif\n";
    var fog_share = "#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nvarying vec3 v_fogDepth;uniform vec3 u_fogColor;\n#ifdef O3_FOG_EXP2\nuniform float u_fogDensity;\n#else\nuniform float u_fogNear;uniform float u_fogFar;\n#endif\n#endif\n";
    var begin_normal_vert = "#define GLSLIFY 1\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nvec3 normal=vec3(NORMAL);\n#endif\n#ifdef O3_HAS_TANGENT\nvec4 tangent=vec4(TANGENT);\n#endif\n#endif\n";
    var begin_position_vert = "#define GLSLIFY 1\nvec4 position=vec4(POSITION,1.0);";
    var position_vert = "#define GLSLIFY 1\n#ifndef O3_GENERATE_SHADOW_MAP\ngl_Position=u_MVPMat*position;\n#endif\n";
    var color_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_VERTEXCOLOR\nv_color=COLOR_0;\n#endif\n";
    var normal_vert = "#define GLSLIFY 1\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nv_normal=normalize(mat3(u_normalMat)*normal);\n#if defined(O3_HAS_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\nvec3 normalW=normalize(mat3(u_normalMat)*normal.xyz);vec3 tangentW=normalize(mat3(u_normalMat)*tangent.xyz);vec3 bitangentW=cross(normalW,tangentW)*tangent.w;v_TBN=mat3(tangentW,bitangentW,normalW);\n#endif\n#endif\n#endif\n";
    var skinning_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_SKIN\n#ifdef O3_USE_JOINT_TEXTURE\nmat4 skinMatrix=WEIGHTS_0.x*getJointMatrix(u_jointSampler,JOINTS_0.x)+WEIGHTS_0.y*getJointMatrix(u_jointSampler,JOINTS_0.y)+WEIGHTS_0.z*getJointMatrix(u_jointSampler,JOINTS_0.z)+WEIGHTS_0.w*getJointMatrix(u_jointSampler,JOINTS_0.w);\n#else\nmat4 skinMatrix=WEIGHTS_0.x*u_jointMatrix[int(JOINTS_0.x)]+WEIGHTS_0.y*u_jointMatrix[int(JOINTS_0.y)]+WEIGHTS_0.z*u_jointMatrix[int(JOINTS_0.z)]+WEIGHTS_0.w*u_jointMatrix[int(JOINTS_0.w)];\n#endif\nposition=skinMatrix*position;\n#if defined(O3_HAS_NORMAL) && !defined(OMIT_NORMAL)\nnormal=vec4(skinMatrix*vec4(normal,0.0)).xyz;\n#if defined(O3_HAS_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\ntangent.xyz=vec4(skinMatrix*vec4(tangent.xyz,0.0)).xyz;\n#endif\n#endif\n#endif\n";
    var blendShape_input = "#define GLSLIFY 1\n#ifdef OASIS_BLENDSHAPE\n#ifdef OASIS_BLENDSHAPE_TEXTURE\nuniform mediump sampler2DArray u_blendShapeTexture;uniform ivec3 u_blendShapeTextureInfo;uniform float u_blendShapeWeights[OASIS_BLENDSHAPE_COUNT];\n#else\nattribute vec3 POSITION_BS0;attribute vec3 POSITION_BS1;attribute vec3 POSITION_BS2;attribute vec3 POSITION_BS3;\n#if defined( OASIS_BLENDSHAPE_NORMAL ) || defined( OASIS_BLENDSHAPE_TANGENT )\n#ifdef OASIS_BLENDSHAPE_NORMAL\nattribute vec3 NORMAL_BS0;attribute vec3 NORMAL_BS1;attribute vec3 NORMAL_BS2;attribute vec3 NORMAL_BS3;\n#endif\n#ifdef OASIS_BLENDSHAPE_TANGENT\nattribute vec3 TANGENT_BS0;attribute vec3 TANGENT_BS1;attribute vec3 TANGENT_BS2;attribute vec3 TANGENT_BS3;\n#endif\nuniform float u_blendShapeWeights[4];\n#else\nattribute vec3 POSITION_BS4;attribute vec3 POSITION_BS5;attribute vec3 POSITION_BS6;attribute vec3 POSITION_BS7;uniform float u_blendShapeWeights[8];\n#endif\n#endif\n#ifdef OASIS_BLENDSHAPE_TEXTURE\nvec3 getBlendShapeVertexElement(int blendShapeIndex,int vertexElementIndex){int y=vertexElementIndex/u_blendShapeTextureInfo.y;int x=vertexElementIndex-y*u_blendShapeTextureInfo.y;ivec3 uv=ivec3(x,y,blendShapeIndex);return texelFetch(u_blendShapeTexture,uv,0).xyz;}\n#endif\n#endif\n";
    var blendShape_vert = "#define GLSLIFY 1\n#ifdef OASIS_BLENDSHAPE\n#ifdef OASIS_BLENDSHAPE_TEXTURE\nint vertexOffset=gl_VertexID*u_blendShapeTextureInfo.x;for(int i=0;i<OASIS_BLENDSHAPE_COUNT;i++){int vertexElementOffset=vertexOffset;float weight=u_blendShapeWeights[i];position.xyz+=getBlendShapeVertexElement(i,vertexElementOffset)*weight;\n#ifndef OMIT_NORMAL\n#if defined( O3_HAS_NORMAL ) && defined( OASIS_BLENDSHAPE_NORMAL )\nvertexElementOffset+=1;normal+=getBlendShapeVertexElement(i,vertexElementOffset)*weight;\n#endif\n#if defined( O3_HAS_TANGENT ) && defined(OASIS_BLENDSHAPE_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\nvertexElementOffset+=1;tangent.xyz+=getBlendShapeVertexElement(i,vertexElementOffset)*weight;\n#endif\n#endif\n}\n#else\nposition.xyz+=POSITION_BS0*u_blendShapeWeights[0];position.xyz+=POSITION_BS1*u_blendShapeWeights[1];position.xyz+=POSITION_BS2*u_blendShapeWeights[2];position.xyz+=POSITION_BS3*u_blendShapeWeights[3];\n#if defined( OASIS_BLENDSHAPE_NORMAL ) || defined( OASIS_BLENDSHAPE_TANGENT )\n#ifndef OMIT_NORMAL\n#if defined( O3_HAS_NORMAL ) && defined( OASIS_BLENDSHAPE_NORMAL )\nnormal+=NORMAL_BS0*u_blendShapeWeights[0];normal+=NORMAL_BS1*u_blendShapeWeights[1];normal+=NORMAL_BS2*u_blendShapeWeights[2];normal+=NORMAL_BS3*u_blendShapeWeights[3];\n#endif\n#if defined( O3_HAS_TANGENT ) && defined(OASIS_BLENDSHAPE_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\ntangent.xyz+=TANGENT_BS0*u_blendShapeWeights[0];tangent.xyz+=TANGENT_BS1*u_blendShapeWeights[1];tangent.xyz+=TANGENT_BS2*u_blendShapeWeights[2];tangent.xyz+=TANGENT_BS3*u_blendShapeWeights[3];\n#endif\n#endif\n#else\nposition.xyz+=POSITION_BS4*u_blendShapeWeights[4];position.xyz+=POSITION_BS5*u_blendShapeWeights[5];position.xyz+=POSITION_BS6*u_blendShapeWeights[6];position.xyz+=POSITION_BS7*u_blendShapeWeights[7];\n#endif\n#endif\n#endif\n";
    var uv_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_UV\nv_uv=TEXCOORD_0;\n#else\nv_uv=vec2(0.,0.);\n#endif\n#ifdef O3_HAS_UV1\nv_uv1=TEXCOORD_1;\n#endif\n#ifdef O3_NEED_TILINGOFFSET\nv_uv=v_uv*u_tilingOffset.xy+u_tilingOffset.zw;\n#endif\n";
    var worldpos_vert = "#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvec4 temp_pos=u_modelMat*position;v_pos=temp_pos.xyz/temp_pos.w;\n#endif\n";
    var shadow_vert = "#define GLSLIFY 1\n#ifdef O3_GENERATE_SHADOW_MAP\ngl_Position=u_projMatFromLight*u_viewMatFromLight*u_modelMat*position;\n#endif\n#ifdef O3_SHADOW_MAP_COUNT\nfor(int i=0;i<O3_SHADOW_MAP_COUNT;i++){v_PositionFromLight[i]=u_projMatFromLight[i]*u_viewMatFromLight[i]*u_modelMat*vec4(POSITION,1.0);}\n#endif\n";
    var fog_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nv_fogDepth=(u_MVMat*position).xyz;\n#endif\n";
    var light_frag_define = "#define GLSLIFY 1\n#ifdef O3_DIRECT_LIGHT_COUNT\nstruct DirectLight{vec3 color;vec3 direction;};uniform vec3 u_directLightColor[O3_DIRECT_LIGHT_COUNT];uniform vec3 u_directLightDirection[O3_DIRECT_LIGHT_COUNT];\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nstruct PointLight{vec3 color;vec3 position;float distance;};uniform vec3 u_pointLightColor[O3_POINT_LIGHT_COUNT];uniform vec3 u_pointLightPosition[O3_POINT_LIGHT_COUNT];uniform float u_pointLightDistance[O3_POINT_LIGHT_COUNT];\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nstruct SpotLight{vec3 color;vec3 position;vec3 direction;float distance;float angleCos;float penumbraCos;};uniform vec3 u_spotLightColor[O3_SPOT_LIGHT_COUNT];uniform vec3 u_spotLightPosition[O3_SPOT_LIGHT_COUNT];uniform vec3 u_spotLightDirection[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightDistance[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightAngleCos[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightPenumbraCos[O3_SPOT_LIGHT_COUNT];\n#endif\nstruct EnvMapLight{vec3 diffuse;float mipMapLevel;float diffuseIntensity;float specularIntensity;};uniform EnvMapLight u_envMapLight;\n#ifdef O3_USE_SH\nuniform vec3 u_env_sh[9];\n#endif\n#ifdef O3_USE_SPECULAR_ENV\nuniform samplerCube u_env_specularSampler;\n#endif\n";
    var mobile_material_frag = "#define GLSLIFY 1\nuniform vec4 u_emissiveColor;uniform vec4 u_baseColor;uniform vec4 u_specularColor;uniform float u_shininess;uniform float u_normalIntensity;uniform float u_alphaCutoff;\n#ifdef EMISSIVETEXTURE\nuniform sampler2D u_emissiveTexture;\n#endif\n#ifdef BASETEXTURE\nuniform sampler2D u_baseTexture;\n#endif\n#ifdef O3_SPECULAR_TEXTURE\nuniform sampler2D u_specularTexture;\n#endif\n#ifdef NORMALTEXTURE\nuniform sampler2D u_normalTexture;\n#endif\n";
    var fog_frag = "#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nfloat fogDepth=length(v_fogDepth);\n#ifdef O3_FOG_EXP2\nfloat fogFactor=whiteCompliment(exp2(-u_fogDensity*u_fogDensity*fogDepth*fogDepth*LOG2));\n#else\nfloat fogFactor=smoothstep(u_fogNear,u_fogFar,fogDepth);\n#endif\ngl_FragColor.rgb=mix(gl_FragColor.rgb,u_fogColor,fogFactor);\n#endif\n";
    var begin_mobile_frag = "#define GLSLIFY 1\nvec4 ambient=vec4(0.0);vec4 emission=u_emissiveColor;vec4 diffuse=u_baseColor;vec4 specular=u_specularColor;\n#ifdef EMISSIVETEXTURE\nvec4 emissiveTextureColor=texture2D(u_emissiveTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\nemissiveTextureColor=gammaToLinear(emissiveTextureColor);\n#endif\nemission*=emissiveTextureColor;\n#endif\n#ifdef BASETEXTURE\nvec4 diffuseTextureColor=texture2D(u_baseTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\ndiffuseTextureColor=gammaToLinear(diffuseTextureColor);\n#endif\ndiffuse*=diffuseTextureColor;\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\ndiffuse*=v_color;\n#endif\n#ifdef O3_SPECULAR_TEXTURE\nvec4 specularTextureColor=texture2D(u_specularTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\nspecularTextureColor=gammaToLinear(specularTextureColor);\n#endif\nspecular*=specularTextureColor;\n#endif\nambient=vec4(u_envMapLight.diffuse*u_envMapLight.diffuseIntensity,1.0)*diffuse;";
    var begin_viewdir_frag = "#define GLSLIFY 1\n#ifdef O3_NEED_WORLDPOS\nvec3 V=normalize(u_cameraPos-v_pos);\n#endif\n";
    var mobile_blinnphong_frag = "#define GLSLIFY 1\n#ifdef NORMALTEXTURE\nmat3 tbn=getTBN();vec3 N=getNormalByNormalTexture(tbn,u_normalTexture,u_normalIntensity,v_uv);\n#else\nvec3 N=getNormal();\n#endif\nvec3 lightDiffuse=vec3(0.0,0.0,0.0);vec3 lightSpecular=vec3(0.0,0.0,0.0);\n#ifdef O3_DIRECT_LIGHT_COUNT\nDirectLight directionalLight;for(int i=0;i<O3_DIRECT_LIGHT_COUNT;i++){directionalLight.color=u_directLightColor[i];directionalLight.direction=u_directLightDirection[i];float d=max(dot(N,-directionalLight.direction),0.0);lightDiffuse+=directionalLight.color*d;vec3 halfDir=normalize(V-directionalLight.direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess);lightSpecular+=directionalLight.color*s;}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nPointLight pointLight;for(int i=0;i<O3_POINT_LIGHT_COUNT;i++){pointLight.color=u_pointLightColor[i];pointLight.position=u_pointLightPosition[i];pointLight.distance=u_pointLightDistance[i];vec3 direction=v_pos-pointLight.position;float dist=length(direction);direction/=dist;float decay=clamp(1.0-pow(dist/pointLight.distance,4.0),0.0,1.0);float d=max(dot(N,-direction),0.0)*decay;lightDiffuse+=pointLight.color*d;vec3 halfDir=normalize(V-direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess)*decay;lightSpecular+=pointLight.color*s;}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nSpotLight spotLight;for(int i=0;i<O3_SPOT_LIGHT_COUNT;i++){spotLight.color=u_spotLightColor[i];spotLight.position=u_spotLightPosition[i];spotLight.direction=u_spotLightDirection[i];spotLight.distance=u_spotLightDistance[i];spotLight.angleCos=u_spotLightAngleCos[i];spotLight.penumbraCos=u_spotLightPenumbraCos[i];vec3 direction=spotLight.position-v_pos;float lightDistance=length(direction);direction/=lightDistance;float angleCos=dot(direction,-spotLight.direction);float decay=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayTotal=decay*spotEffect;float d=max(dot(N,direction),0.0)*decayTotal;lightDiffuse+=spotLight.color*d;vec3 halfDir=normalize(V+direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess)*decayTotal;lightSpecular+=spotLight.color*s;}\n#endif\ndiffuse*=vec4(lightDiffuse,1.0);specular*=vec4(lightSpecular,1.0);\n#ifdef ALPHA_CUTOFF\nif(diffuse.a<u_alphaCutoff){discard;}\n#endif\n";
    var noise_common = "#define GLSLIFY 1\nvec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec2 mod289(vec2 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod7(vec4 x){return x-floor(x*(1.0/7.0))*7.0;}vec3 mod7(vec3 x){return x-floor(x*(1.0/7.0))*7.0;}vec4 permute(vec4 x){return mod289((34.0*x+1.0)*x);}vec3 permute(vec3 x){return mod289((34.0*x+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 fade(vec4 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec2 fade(vec2 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}\n#define K 0.142857142857\n#define Ko 0.428571428571\n#define K2 0.020408163265306\n#define Kd2 0.0714285714285\n#define Kz 0.166666666667\n#define Kzo 0.416666666667\n#define jitter 1.0\n#define jitter1 0.8\n";
    var noise_cellular_2D = "#define GLSLIFY 1\nvec2 cellular(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec3 oi=vec3(-1.0,0.0,1.0);vec3 of=vec3(-0.5,0.5,1.5);vec3 px=permute(Pi.x+oi);vec3 p=permute(px.x+Pi.y+oi);vec3 ox=fract(p*K)-Ko;vec3 oy=mod7(floor(p*K))*K-Ko;vec3 dx=Pf.x+0.5+jitter*ox;vec3 dy=Pf.y-of+jitter*oy;vec3 d1=dx*dx+dy*dy;p=permute(px.y+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-0.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d2=dx*dx+dy*dy;p=permute(px.z+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-1.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d3=dx*dx+dy*dy;vec3 d1a=min(d1,d2);d2=max(d1,d2);d2=min(d2,d3);d1=min(d1a,d2);d2=max(d1a,d2);d1.xy=(d1.x<d1.y)? d1.xy : d1.yx;d1.xz=(d1.x<d1.z)? d1.xz : d1.zx;d1.yz=min(d1.yz,d2.yz);d1.y=min(d1.y,d1.z);d1.y=min(d1.y,d2.x);return sqrt(d1.xy);}";
    var noise_cellular_2x2 = "#define GLSLIFY 1\nvec2 cellular2x2(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec4 Pfx=Pf.x+vec4(-0.5,-1.5,-0.5,-1.5);vec4 Pfy=Pf.y+vec4(-0.5,-0.5,-1.5,-1.5);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 ox=mod7(p)*K+Kd2;vec4 oy=mod7(floor(p*K))*K+Kd2;vec4 dx=Pfx+jitter1*ox;vec4 dy=Pfy+jitter1*oy;vec4 d=dx*dx+dy*dy;d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.y=min(d.y,d.z);d.y=min(d.y,d.w);return sqrt(d.xy);}";
    var noise_cellular_2x2x2 = "#define GLSLIFY 1\nvec2 cellular2x2x2(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P);vec4 Pfx=Pf.x+vec4(0.0,-1.0,0.0,-1.0);vec4 Pfy=Pf.y+vec4(0.0,0.0,-1.0,-1.0);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 p1=permute(p+Pi.z);vec4 p2=permute(p+Pi.z+vec4(1.0));vec4 ox1=fract(p1*K)-Ko;vec4 oy1=mod7(floor(p1*K))*K-Ko;vec4 oz1=floor(p1*K2)*Kz-Kzo;vec4 ox2=fract(p2*K)-Ko;vec4 oy2=mod7(floor(p2*K))*K-Ko;vec4 oz2=floor(p2*K2)*Kz-Kzo;vec4 dx1=Pfx+jitter1*ox1;vec4 dy1=Pfy+jitter1*oy1;vec4 dz1=Pf.z+jitter1*oz1;vec4 dx2=Pfx+jitter1*ox2;vec4 dy2=Pfy+jitter1*oy2;vec4 dz2=Pf.z-1.0+jitter1*oz2;vec4 d1=dx1*dx1+dy1*dy1+dz1*dz1;vec4 d2=dx2*dx2+dy2*dy2+dz2*dz2;vec4 d=min(d1,d2);d2=max(d1,d2);d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.yzw=min(d.yzw,d2.yzw);d.y=min(d.y,d.z);d.y=min(d.y,d.w);d.y=min(d.y,d2.x);return sqrt(d.xy);}";
    var noise_cellular_3D = "#define GLSLIFY 1\nvec2 cellular(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P)-0.5;vec3 Pfx=Pf.x+vec3(1.0,0.0,-1.0);vec3 Pfy=Pf.y+vec3(1.0,0.0,-1.0);vec3 Pfz=Pf.z+vec3(1.0,0.0,-1.0);vec3 p=permute(Pi.x+vec3(-1.0,0.0,1.0));vec3 p1=permute(p+Pi.y-1.0);vec3 p2=permute(p+Pi.y);vec3 p3=permute(p+Pi.y+1.0);vec3 p11=permute(p1+Pi.z-1.0);vec3 p12=permute(p1+Pi.z);vec3 p13=permute(p1+Pi.z+1.0);vec3 p21=permute(p2+Pi.z-1.0);vec3 p22=permute(p2+Pi.z);vec3 p23=permute(p2+Pi.z+1.0);vec3 p31=permute(p3+Pi.z-1.0);vec3 p32=permute(p3+Pi.z);vec3 p33=permute(p3+Pi.z+1.0);vec3 ox11=fract(p11*K)-Ko;vec3 oy11=mod7(floor(p11*K))*K-Ko;vec3 oz11=floor(p11*K2)*Kz-Kzo;vec3 ox12=fract(p12*K)-Ko;vec3 oy12=mod7(floor(p12*K))*K-Ko;vec3 oz12=floor(p12*K2)*Kz-Kzo;vec3 ox13=fract(p13*K)-Ko;vec3 oy13=mod7(floor(p13*K))*K-Ko;vec3 oz13=floor(p13*K2)*Kz-Kzo;vec3 ox21=fract(p21*K)-Ko;vec3 oy21=mod7(floor(p21*K))*K-Ko;vec3 oz21=floor(p21*K2)*Kz-Kzo;vec3 ox22=fract(p22*K)-Ko;vec3 oy22=mod7(floor(p22*K))*K-Ko;vec3 oz22=floor(p22*K2)*Kz-Kzo;vec3 ox23=fract(p23*K)-Ko;vec3 oy23=mod7(floor(p23*K))*K-Ko;vec3 oz23=floor(p23*K2)*Kz-Kzo;vec3 ox31=fract(p31*K)-Ko;vec3 oy31=mod7(floor(p31*K))*K-Ko;vec3 oz31=floor(p31*K2)*Kz-Kzo;vec3 ox32=fract(p32*K)-Ko;vec3 oy32=mod7(floor(p32*K))*K-Ko;vec3 oz32=floor(p32*K2)*Kz-Kzo;vec3 ox33=fract(p33*K)-Ko;vec3 oy33=mod7(floor(p33*K))*K-Ko;vec3 oz33=floor(p33*K2)*Kz-Kzo;vec3 dx11=Pfx+jitter*ox11;vec3 dy11=Pfy.x+jitter*oy11;vec3 dz11=Pfz.x+jitter*oz11;vec3 dx12=Pfx+jitter*ox12;vec3 dy12=Pfy.x+jitter*oy12;vec3 dz12=Pfz.y+jitter*oz12;vec3 dx13=Pfx+jitter*ox13;vec3 dy13=Pfy.x+jitter*oy13;vec3 dz13=Pfz.z+jitter*oz13;vec3 dx21=Pfx+jitter*ox21;vec3 dy21=Pfy.y+jitter*oy21;vec3 dz21=Pfz.x+jitter*oz21;vec3 dx22=Pfx+jitter*ox22;vec3 dy22=Pfy.y+jitter*oy22;vec3 dz22=Pfz.y+jitter*oz22;vec3 dx23=Pfx+jitter*ox23;vec3 dy23=Pfy.y+jitter*oy23;vec3 dz23=Pfz.z+jitter*oz23;vec3 dx31=Pfx+jitter*ox31;vec3 dy31=Pfy.z+jitter*oy31;vec3 dz31=Pfz.x+jitter*oz31;vec3 dx32=Pfx+jitter*ox32;vec3 dy32=Pfy.z+jitter*oy32;vec3 dz32=Pfz.y+jitter*oz32;vec3 dx33=Pfx+jitter*ox33;vec3 dy33=Pfy.z+jitter*oy33;vec3 dz33=Pfz.z+jitter*oz33;vec3 d11=dx11*dx11+dy11*dy11+dz11*dz11;vec3 d12=dx12*dx12+dy12*dy12+dz12*dz12;vec3 d13=dx13*dx13+dy13*dy13+dz13*dz13;vec3 d21=dx21*dx21+dy21*dy21+dz21*dz21;vec3 d22=dx22*dx22+dy22*dy22+dz22*dz22;vec3 d23=dx23*dx23+dy23*dy23+dz23*dz23;vec3 d31=dx31*dx31+dy31*dy31+dz31*dz31;vec3 d32=dx32*dx32+dy32*dy32+dz32*dz32;vec3 d33=dx33*dx33+dy33*dy33+dz33*dz33;vec3 d1a=min(d11,d12);d12=max(d11,d12);d11=min(d1a,d13);d13=max(d1a,d13);d12=min(d12,d13);vec3 d2a=min(d21,d22);d22=max(d21,d22);d21=min(d2a,d23);d23=max(d2a,d23);d22=min(d22,d23);vec3 d3a=min(d31,d32);d32=max(d31,d32);d31=min(d3a,d33);d33=max(d3a,d33);d32=min(d32,d33);vec3 da=min(d11,d21);d21=max(d11,d21);d11=min(da,d31);d31=max(da,d31);d11.xy=(d11.x<d11.y)? d11.xy : d11.yx;d11.xz=(d11.x<d11.z)? d11.xz : d11.zx;d12=min(d12,d21);d12=min(d12,d22);d12=min(d12,d31);d12=min(d12,d32);d11.yz=min(d11.yz,d12.xy);d11.y=min(d11.y,d12.z);d11.y=min(d11.y,d11.z);return sqrt(d11.xy);}";
    var noise_cellular = "#define GLSLIFY 1\n#include <noise_cellular_2D>\n#include <noise_cellular_3D>\n#include <noise_cellular_2x2>\n#include <noise_cellular_2x2x2>\n";
    var noise_perlin_2D = "#define GLSLIFY 1\nfloat perlin(vec2 P){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}float perlin(vec2 P,vec2 rep){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod(Pi,rep.xyxy);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}";
    var noise_perlin_3D = "#define GLSLIFY 1\nfloat perlin(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}float perlin(vec3 P,vec3 rep){vec3 Pi0=mod(floor(P),rep);vec3 Pi1=mod(Pi0+vec3(1.0),rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}";
    var noise_perlin_4D = "#define GLSLIFY 1\nfloat perlin(vec4 P){vec4 Pi0=floor(P);vec4 Pi1=Pi0+1.0;Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}float perlin(vec4 P,vec4 rep){vec4 Pi0=mod(floor(P),rep);vec4 Pi1=mod(Pi0+1.0,rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}";
    var noise_perlin = "#define GLSLIFY 1\n#include <noise_perlin_2D>\n#include <noise_perlin_3D>\n#include <noise_perlin_4D>\n";
    var noise_psrd_2D = "#define GLSLIFY 1\nvec2 rgrad2(vec2 p,float rot){float u=permute(permute(p.x)+p.y)*0.0243902439+rot;u=fract(u)*6.28318530718;return vec2(cos(u),sin(u));}vec3 psrdnoise(vec2 pos,vec2 per,float rot){pos.y+=0.01;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 psdnoise(vec2 pos,vec2 per){return psrdnoise(pos,per,0.0);}float psrnoise(vec2 pos,vec2 per,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float psnoise(vec2 pos,vec2 per){return psrnoise(pos,per,0.0);}vec3 srdnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 sdnoise(vec2 pos){return srdnoise(pos,0.0);}float srnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float snoise(vec2 pos){return srnoise(pos,0.0);}";
    var noise_simplex_2D = "#define GLSLIFY 1\nfloat simplex(vec2 v){const vec4 C=vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);vec2 i=floor(v+dot(v,C.yy));vec2 x0=v-i+dot(i,C.xx);vec2 i1;i1=(x0.x>x0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec4 x12=x0.xyxy+C.xxzz;x12.xy-=i1;i=mod289(i);vec3 p=permute(permute(i.y+vec3(0.0,i1.y,1.0))+i.x+vec3(0.0,i1.x,1.0));vec3 m=max(0.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.0);m=m*m;m=m*m;vec3 x=2.0*fract(p*C.www)-1.0;vec3 h=abs(x)-0.5;vec3 ox=floor(x+0.5);vec3 a0=x-ox;m*=1.79284291400159-0.85373472095314*(a0*a0+h*h);vec3 g;g.x=a0.x*x0.x+h.x*x0.y;g.yz=a0.yz*x12.xz+h.yz*x12.yw;return 130.0*dot(m,g);}";
    var noise_simplex_3D_grad = "#define GLSLIFY 1\nfloat simplex(vec3 v,out vec3 gradient){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);vec4 m2=m*m;vec4 m4=m2*m2;vec4 pdotx=vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3));vec4 temp=m2*m*pdotx;gradient=-8.0*(temp.x*x0+temp.y*x1+temp.z*x2+temp.w*x3);gradient+=m4.x*p0+m4.y*p1+m4.z*p2+m4.w*p3;gradient*=42.0;return 42.0*dot(m4,pdotx);}";
    var noise_simplex_3D = "#define GLSLIFY 1\nfloat simplex(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}";
    var noise_simplex_4D = "#define GLSLIFY 1\nvec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}\n#define F4 0.309016994374947451\nfloat simplex(vec4 v){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v+dot(v,vec4(F4)));vec4 x0=v-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 m0=max(0.6-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.6-vec2(dot(x3,x3),dot(x4,x4)),0.0);m0=m0*m0;m1=m1*m1;return 49.0*(dot(m0*m0,vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2)))+dot(m1*m1,vec2(dot(p3,x3),dot(p4,x4))));}";
    var noise_simplex = "#define GLSLIFY 1\n#include <noise_simplex_2D>\n#include <noise_simplex_3D>\n#include <noise_simplex_3D_grad>\n#include <noise_simplex_4D>\n";
    var pbr_frag_define = "#define GLSLIFY 1\nuniform float u_alphaCutoff;uniform vec4 u_baseColor;uniform float u_metal;uniform float u_roughness;uniform vec3 u_PBRSpecularColor;uniform float u_glossiness;uniform vec3 u_emissiveColor;\n#ifdef CLEARCOAT\nuniform float u_clearCoat;uniform float u_clearCoatRoughness;\n#endif\nuniform float u_normalIntensity;uniform float u_occlusionIntensity;uniform float u_occlusionTextureCoord;\n#ifdef BASETEXTURE\nuniform sampler2D u_baseTexture;\n#endif\n#ifdef NORMALTEXTURE\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef EMISSIVETEXTURE\nuniform sampler2D u_emissiveTexture;\n#endif\n#ifdef ROUGHNESSMETALLICTEXTURE\nuniform sampler2D u_roughnessMetallicTexture;\n#endif\n#ifdef SPECULARGLOSSINESSTEXTURE\nuniform sampler2D u_specularGlossinessTexture;\n#endif\n#ifdef OCCLUSIONTEXTURE\nuniform sampler2D u_occlusionTexture;\n#endif\n#ifdef HAS_CLEARCOATTEXTURE\nuniform sampler2D u_clearCoatTexture;\n#endif\n#ifdef HAS_CLEARCOATROUGHNESSTEXTURE\nuniform sampler2D u_clearCoatRoughnessTexture;\n#endif\n#ifdef HAS_CLEARCOATNORMALTEXTURE\nuniform sampler2D u_clearCoatNormalTexture;\n#endif\nstruct ReflectedLight{vec3 directDiffuse;vec3 directSpecular;vec3 indirectDiffuse;vec3 indirectSpecular;};struct Geometry{vec3 position;vec3 normal;vec3 viewDir;float dotNV;\n#ifdef CLEARCOAT\nvec3 clearCoatNormal;float clearCoatDotNV;\n#endif\n};struct Material{vec3 diffuseColor;float roughness;vec3 specularColor;float opacity;\n#ifdef CLEARCOAT\nfloat clearCoat;float clearCoatRoughness;\n#endif\n};";
    var pbr_helper = "#define GLSLIFY 1\n#include <normal_get>\nfloat computeSpecularOcclusion(float ambientOcclusion,float roughness,float dotNV){return saturate(pow(dotNV+ambientOcclusion,exp2(-16.0*roughness-1.0))-1.0+ambientOcclusion);}float getAARoughnessFactor(vec3 normal){\n#ifdef HAS_DERIVATIVES\nvec3 dxy=max(abs(dFdx(normal)),abs(dFdy(normal)));return 0.04+max(max(dxy.x,dxy.y),dxy.z);\n#else\nreturn 0.04;\n#endif\n}void initGeometry(out Geometry geometry){geometry.position=v_pos;geometry.viewDir=normalize(u_cameraPos-v_pos);\n#if defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE)\nmat3 tbn=getTBN();\n#endif\n#ifdef NORMALTEXTURE\ngeometry.normal=getNormalByNormalTexture(tbn,u_normalTexture,u_normalIntensity,v_uv);\n#else\ngeometry.normal=getNormal();\n#endif\ngeometry.dotNV=saturate(dot(geometry.normal,geometry.viewDir));\n#ifdef CLEARCOAT\n#ifdef HAS_CLEARCOATNORMALTEXTURE\ngeometry.clearCoatNormal=getNormalByNormalTexture(tbn,u_clearCoatNormalTexture,u_normalIntensity,v_uv);\n#else\ngeometry.clearCoatNormal=getNormal();\n#endif\ngeometry.clearCoatDotNV=saturate(dot(geometry.clearCoatNormal,geometry.viewDir));\n#endif\n}void initMaterial(out Material material,const in Geometry geometry){vec4 baseColor=u_baseColor;float metal=u_metal;float roughness=u_roughness;vec3 specularColor=u_PBRSpecularColor;float glossiness=u_glossiness;float alphaCutoff=u_alphaCutoff;\n#ifdef BASETEXTURE\nvec4 baseTextureColor=texture2D(u_baseTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\nbaseTextureColor=gammaToLinear(baseTextureColor);\n#endif\nbaseColor*=baseTextureColor;\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\nbaseColor*=v_color;\n#endif\n#ifdef ALPHA_CUTOFF\nif(baseColor.a<alphaCutoff){discard;}\n#endif\n#ifdef ROUGHNESSMETALLICTEXTURE\nvec4 metalRoughMapColor=texture2D(u_roughnessMetallicTexture,v_uv);roughness*=metalRoughMapColor.g;metal*=metalRoughMapColor.b;\n#endif\n#ifdef SPECULARGLOSSINESSTEXTURE\nvec4 specularGlossinessColor=texture2D(u_specularGlossinessTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\nspecularGlossinessColor=gammaToLinear(specularGlossinessColor);\n#endif\nspecularColor*=specularGlossinessColor.rgb;glossiness*=specularGlossinessColor.a;\n#endif\n#ifdef IS_METALLIC_WORKFLOW\nmaterial.diffuseColor=baseColor.rgb*(1.0-metal);material.specularColor=mix(vec3(0.04),baseColor.rgb,metal);material.roughness=roughness;\n#else\nfloat specularStrength=max(max(specularColor.r,specularColor.g),specularColor.b);material.diffuseColor=baseColor.rgb*(1.0-specularStrength);material.specularColor=specularColor;material.roughness=1.0-glossiness;\n#endif\nmaterial.roughness=max(material.roughness,getAARoughnessFactor(geometry.normal));\n#ifdef CLEARCOAT\nmaterial.clearCoat=u_clearCoat;material.clearCoatRoughness=u_clearCoatRoughness;\n#ifdef HAS_CLEARCOATTEXTURE\nmaterial.clearCoat*=texture2D(u_clearCoatTexture,v_uv).r;\n#endif\n#ifdef HAS_CLEARCOATROUGHNESSTEXTURE\nmaterial.clearCoatRoughness*=texture2D(u_clearCoatRoughnessTexture,v_uv).g;\n#endif\nmaterial.clearCoat=saturate(material.clearCoat);material.clearCoatRoughness=max(material.clearCoatRoughness,getAARoughnessFactor(geometry.clearCoatNormal));\n#endif\nmaterial.opacity=baseColor.a;}\n#include <brdf>\n#include <direct_irradiance_frag_define>\n#include <ibl_frag_define>\n";
    var brdf = "#define GLSLIFY 1\nfloat F_Schlick(float dotLH){return 0.04+0.96*(pow(1.0-dotLH,5.0));}vec3 F_Schlick(vec3 specularColor,float dotLH){float fresnel=exp2((-5.55473*dotLH-6.98316)*dotLH);return(1.0-specularColor)*fresnel+specularColor;}float G_GGX_SmithCorrelated(float alpha,float dotNL,float dotNV){float a2=pow2(alpha);float gv=dotNL*sqrt(a2+(1.0-a2)*pow2(dotNV));float gl=dotNV*sqrt(a2+(1.0-a2)*pow2(dotNL));return 0.5/max(gv+gl,EPSILON);}float D_GGX(float alpha,float dotNH){float a2=pow2(alpha);float denom=pow2(dotNH)*(a2-1.0)+1.0;return RECIPROCAL_PI*a2/pow2(denom);}vec3 BRDF_Specular_GGX(vec3 incidentDirection,vec3 viewDir,vec3 normal,vec3 specularColor,float roughness){float alpha=pow2(roughness);vec3 halfDir=normalize(incidentDirection+viewDir);float dotNL=saturate(dot(normal,incidentDirection));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotLH=saturate(dot(incidentDirection,halfDir));vec3 F=F_Schlick(specularColor,dotLH);float G=G_GGX_SmithCorrelated(alpha,dotNL,dotNV);float D=D_GGX(alpha,dotNH);return F*(G*D);}vec3 BRDF_Diffuse_Lambert(vec3 diffuseColor){return RECIPROCAL_PI*diffuseColor;}";
    var direct_irradiance_frag_define = "#define GLSLIFY 1\nvoid addDirectRadiance(vec3 incidentDirection,vec3 color,Geometry geometry,Material material,inout ReflectedLight reflectedLight){float attenuation=1.0;\n#ifdef CLEARCOAT\nfloat clearCoatDotNL=saturate(dot(geometry.clearCoatNormal,incidentDirection));vec3 clearCoatIrradiance=clearCoatDotNL*color;reflectedLight.directSpecular+=material.clearCoat*clearCoatIrradiance*BRDF_Specular_GGX(incidentDirection,geometry.viewDir,geometry.clearCoatNormal,vec3(0.04),material.clearCoatRoughness);attenuation-=material.clearCoat*F_Schlick(geometry.clearCoatDotNV);\n#endif\nfloat dotNL=saturate(dot(geometry.normal,incidentDirection));vec3 irradiance=dotNL*color*PI;reflectedLight.directSpecular+=attenuation*irradiance*BRDF_Specular_GGX(incidentDirection,geometry.viewDir,geometry.normal,material.specularColor,material.roughness);reflectedLight.directDiffuse+=attenuation*irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);}\n#ifdef O3_DIRECT_LIGHT_COUNT\nvoid addDirectionalDirectLightRadiance(DirectLight directionalLight,Geometry geometry,Material material,inout ReflectedLight reflectedLight){vec3 color=directionalLight.color;vec3 direction=-directionalLight.direction;addDirectRadiance(direction,color,geometry,material,reflectedLight);}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nvoid addPointDirectLightRadiance(PointLight pointLight,Geometry geometry,Material material,inout ReflectedLight reflectedLight){vec3 lVector=pointLight.position-geometry.position;vec3 direction=normalize(lVector);float lightDistance=length(lVector);vec3 color=pointLight.color;color*=clamp(1.0-pow(lightDistance/pointLight.distance,4.0),0.0,1.0);addDirectRadiance(direction,color,geometry,material,reflectedLight);}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nvoid addSpotDirectLightRadiance(SpotLight spotLight,Geometry geometry,Material material,inout ReflectedLight reflectedLight){vec3 lVector=spotLight.position-geometry.position;vec3 direction=normalize(lVector);float lightDistance=length(lVector);float angleCos=dot(direction,-spotLight.direction);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayEffect=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);vec3 color=spotLight.color;color*=spotEffect*decayEffect;addDirectRadiance(direction,color,geometry,material,reflectedLight);}\n#endif\nvoid addTotalDirectRadiance(Geometry geometry,Material material,inout ReflectedLight reflectedLight){\n#ifdef O3_DIRECT_LIGHT_COUNT\nDirectLight directionalLight;for(int i=0;i<O3_DIRECT_LIGHT_COUNT;i++){directionalLight.color=u_directLightColor[i];directionalLight.direction=u_directLightDirection[i];addDirectionalDirectLightRadiance(directionalLight,geometry,material,reflectedLight);}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nPointLight pointLight;for(int i=0;i<O3_POINT_LIGHT_COUNT;i++){pointLight.color=u_pointLightColor[i];pointLight.position=u_pointLightPosition[i];pointLight.distance=u_pointLightDistance[i];addPointDirectLightRadiance(pointLight,geometry,material,reflectedLight);}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nSpotLight spotLight;for(int i=0;i<O3_SPOT_LIGHT_COUNT;i++){spotLight.color=u_spotLightColor[i];spotLight.position=u_spotLightPosition[i];spotLight.direction=u_spotLightDirection[i];spotLight.distance=u_spotLightDistance[i];spotLight.angleCos=u_spotLightAngleCos[i];spotLight.penumbraCos=u_spotLightPenumbraCos[i];addSpotDirectLightRadiance(spotLight,geometry,material,reflectedLight);}\n#endif\n}";
    var ibl_frag_define = "#define GLSLIFY 1\nvec3 getLightProbeIrradiance(vec3 sh[9],vec3 normal){normal.x=-normal.x;vec3 result=sh[0]+sh[1]*(normal.y)+sh[2]*(normal.z)+sh[3]*(normal.x)+sh[4]*(normal.y*normal.x)+sh[5]*(normal.y*normal.z)+sh[6]*(3.0*normal.z*normal.z-1.0)+sh[7]*(normal.z*normal.x)+sh[8]*(normal.x*normal.x-normal.y*normal.y);return max(result,vec3(0.0));}vec3 envBRDFApprox(vec3 specularColor,float roughness,float dotNV){const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}float getSpecularMIPLevel(float roughness,int maxMIPLevel){return roughness*float(maxMIPLevel);}vec3 getLightProbeRadiance(vec3 viewDir,vec3 normal,float roughness,int maxMIPLevel,float specularIntensity){\n#ifndef O3_USE_SPECULAR_ENV\nreturn vec3(0);\n#else\nvec3 reflectVec=reflect(-viewDir,normal);reflectVec.x=-reflectVec.x;float specularMIPLevel=getSpecularMIPLevel(roughness,maxMIPLevel);\n#ifdef HAS_TEX_LOD\nvec4 envMapColor=textureCubeLodEXT(u_env_specularSampler,reflectVec,specularMIPLevel);\n#else\nvec4 envMapColor=textureCube(u_env_specularSampler,reflectVec,specularMIPLevel);\n#endif\n#ifdef O3_DECODE_ENV_RGBM\nenvMapColor.rgb=RGBMToLinear(envMapColor,5.0).rgb;\n#ifdef OASIS_COLORSPACE_GAMMA\nenvMapColor=linearToGamma(envMapColor);\n#endif\n#else\n#ifndef OASIS_COLORSPACE_GAMMA\nenvMapColor=gammaToLinear(envMapColor);\n#endif\n#endif\nreturn envMapColor.rgb*specularIntensity;\n#endif\n}";
    var pbr_frag = "#define GLSLIFY 1\nGeometry geometry;Material material;ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));initGeometry(geometry);initMaterial(material,geometry);addTotalDirectRadiance(geometry,material,reflectedLight);\n#ifdef O3_USE_SH\nvec3 irradiance=getLightProbeIrradiance(u_env_sh,geometry.normal);\n#ifdef OASIS_COLORSPACE_GAMMA\nirradiance=linearToGamma(vec4(irradiance,1.0)).rgb;\n#endif\nirradiance*=u_envMapLight.diffuseIntensity;\n#else\nvec3 irradiance=u_envMapLight.diffuse*u_envMapLight.diffuseIntensity;irradiance*=PI;\n#endif\nreflectedLight.indirectDiffuse+=irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);vec3 radiance=getLightProbeRadiance(geometry.viewDir,geometry.normal,material.roughness,int(u_envMapLight.mipMapLevel),u_envMapLight.specularIntensity);float radianceAttenuation=1.0;\n#ifdef CLEARCOAT\nvec3 clearCoatRadiance=getLightProbeRadiance(geometry.viewDir,geometry.clearCoatNormal,material.clearCoatRoughness,int(u_envMapLight.mipMapLevel),u_envMapLight.specularIntensity);reflectedLight.indirectSpecular+=clearCoatRadiance*material.clearCoat*envBRDFApprox(vec3(0.04),material.clearCoatRoughness,geometry.clearCoatDotNV);radianceAttenuation-=material.clearCoat*F_Schlick(geometry.clearCoatDotNV);\n#endif\nreflectedLight.indirectSpecular+=radianceAttenuation*radiance*envBRDFApprox(material.specularColor,material.roughness,geometry.dotNV);\n#ifdef OCCLUSIONTEXTURE\nvec2 aoUV=v_uv;\n#ifdef O3_HAS_UV1\nif(u_occlusionTextureCoord==1.0){aoUV=v_uv1;}\n#endif\nfloat ambientOcclusion=(texture2D(u_occlusionTexture,aoUV).r-1.0)*u_occlusionIntensity+1.0;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#ifdef O3_USE_SPECULAR_ENV\nreflectedLight.indirectSpecular*=computeSpecularOcclusion(ambientOcclusion,material.roughness,geometry.dotNV);\n#endif\n#endif\nvec3 emissiveRadiance=u_emissiveColor;\n#ifdef EMISSIVETEXTURE\nvec4 emissiveColor=texture2D(u_emissiveTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\nemissiveColor=gammaToLinear(emissiveColor);\n#endif\nemissiveRadiance*=emissiveColor.rgb;\n#endif\nvec3 totalRadiance=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+emissiveRadiance;vec4 targetColor=vec4(totalRadiance,material.opacity);\n#ifndef OASIS_COLORSPACE_GAMMA\ntargetColor=linearToGamma(targetColor);\n#endif\ngl_FragColor=targetColor;";
    var PBRShaderLib = {
      pbr_frag_define,
      pbr_helper,
      brdf,
      direct_irradiance_frag_define,
      ibl_frag_define,
      pbr_frag
    };
    var normal_get = "#define GLSLIFY 1\nvec3 getNormal(){\n#ifdef O3_HAS_NORMAL\nvec3 normal=normalize(v_normal);\n#elif defined(HAS_DERIVATIVES)\nvec3 pos_dx=dFdx(v_pos);vec3 pos_dy=dFdy(v_pos);vec3 normal=normalize(cross(pos_dx,pos_dy));\n#else\nvec3 normal=vec3(0,0,1);\n#endif\nnormal*=float(gl_FrontFacing)*2.0-1.0;return normal;}vec3 getNormalByNormalTexture(mat3 tbn,sampler2D normalTexture,float normalIntensity,vec2 uv){vec3 normal=texture2D(normalTexture,uv).rgb;normal=normalize(tbn*((2.0*normal-1.0)*vec3(normalIntensity,normalIntensity,1.0)));normal*=float(gl_FrontFacing)*2.0-1.0;return normal;}mat3 getTBN(){\n#if defined(O3_HAS_NORMAL) && defined(O3_HAS_TANGENT) && ( defined(NORMALTEXTURE) || defined(HAS_CLEARCOATNORMALTEXTURE) )\nmat3 tbn=v_TBN;\n#else\nvec3 normal=getNormal();vec3 position=v_pos;vec2 uv=gl_FrontFacing? v_uv:-v_uv;\n#ifdef HAS_DERIVATIVES\nvec3 dp1=dFdx(position);vec3 dp2=dFdy(position);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));mat3 tbn=mat3(tangent*invmax,binormal*invmax,normal);\n#else\nmat3 tbn=mat3(vec3(0.0),vec3(0.0),normal);\n#endif\n#endif\nreturn tbn;}";
    var ShaderLib = _objectSpread22(_objectSpread22({
      common,
      common_vert,
      common_frag,
      color_share,
      normal_share,
      uv_share,
      worldpos_share,
      shadow_share,
      fog_share,
      begin_normal_vert,
      begin_position_vert,
      position_vert,
      color_vert,
      normal_vert,
      skinning_vert,
      blendShape_input,
      blendShape_vert,
      uv_vert,
      worldpos_vert,
      shadow_vert,
      fog_vert,
      light_frag_define,
      mobile_material_frag,
      fog_frag,
      begin_mobile_frag,
      begin_viewdir_frag,
      mobile_blinnphong_frag,
      noise_common,
      noise_cellular_2D,
      noise_cellular_2x2,
      noise_cellular_2x2x2,
      noise_cellular_3D,
      noise_cellular,
      noise_perlin_2D,
      noise_perlin_3D,
      noise_perlin_4D,
      noise_perlin,
      noise_psrd_2D,
      noise_simplex_2D,
      noise_simplex_3D_grad,
      noise_simplex_3D,
      noise_simplex_4D,
      noise_simplex
    }, PBRShaderLib), {}, {
      normal_get
    });
    var ShaderFactory = /* @__PURE__ */ function() {
      function ShaderFactory2() {
      }
      ShaderFactory2.parseCustomMacros = function parseCustomMacros(macros) {
        return macros.map(function(m) {
          return "#define " + m + "\n";
        }).join("");
      };
      ShaderFactory2.parseIncludes = function parseIncludes(src) {
        var regex = /^[ \t]*#include +<([\w\d.]+)>/gm;
        function replace(match, slice) {
          var replace2 = ShaderLib[slice];
          if (replace2 === void 0) {
            Logger.error('Shader slice "' + match.trim() + '" not founded.');
            return "";
          }
          return ShaderFactory2.parseIncludes(replace2);
        }
        return src.replace(regex, replace);
      };
      ShaderFactory2.parseExtension = function parseExtension(extensions) {
        return extensions.map(function(e) {
          return "#extension " + e + " : enable\n";
        }).join("");
      };
      ShaderFactory2.convertTo300 = function convertTo300(shader, isFrag) {
        shader = shader.replace(/\battribute\b/g, "in");
        shader = shader.replace(/\bvarying\b/g, isFrag ? "in" : "out");
        shader = shader.replace(/\btexture(2D|Cube)\b/g, "texture");
        shader = shader.replace(/\btexture(2D|Cube)LodEXT\b/g, "textureLod");
        if (isFrag) {
          var isMRT = /\bgl_FragData\[.+?\]/g.test(shader);
          if (isMRT) {
            shader = shader.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
            var result = shader.match(/\bgl_FragData\[.+?\]/g);
            shader = this._replaceMRTShader(shader, result);
          } else {
            shader = shader.replace(/void\s+?main\s*\(/g, "out vec4 glFragColor;\nvoid main(");
            shader = shader.replace(/\bgl_FragColor\b/g, "glFragColor");
          }
        }
        return shader;
      };
      ShaderFactory2._replaceMRTShader = function _replaceMRTShader(shader, result) {
        var declaration = "";
        var mrtIndexSet = /* @__PURE__ */ new Set();
        for (var i = 0; i < result.length; i++) {
          var res = result[i].match(/\bgl_FragData\[(.+?)\]/);
          mrtIndexSet.add(res[1]);
        }
        mrtIndexSet.forEach(function(index) {
          declaration += "layout(location=" + index + ") out vec4 fragOutColor" + index + ";\n";
        });
        declaration += "void main(";
        shader = shader.replace(/\bgl_FragData\[(.+?)\]/g, "fragOutColor$1");
        shader = shader.replace(/void\s+?main\s*\(/g, declaration);
        return shader;
      };
      return ShaderFactory2;
    }();
    var ShaderMacro = function ShaderMacro2(name, value, maskIndex, maskValue) {
      this.name = void 0;
      this.value = void 0;
      this._nameId = void 0;
      this._maskIndex = void 0;
      this._maskValue = void 0;
      this.name = name;
      this._maskIndex = maskIndex;
      this._maskValue = maskValue;
      this.value = value;
      var macroNameIDMap = ShaderMacro2._macroNameIdMap;
      var nameID = macroNameIDMap[name];
      if (macroNameIDMap[name] === void 0) {
        macroNameIDMap[name] = nameID = ShaderMacro2._macroNameCounter++;
      }
      this._nameId = nameID;
    };
    ShaderMacro._macroNameIdMap = /* @__PURE__ */ Object.create(null);
    ShaderMacro._macroNameCounter = 0;
    exports3.ColorSpace = void 0;
    (function(ColorSpace) {
      ColorSpace[ColorSpace["Linear"] = 0] = "Linear";
      ColorSpace[ColorSpace["Gamma"] = 1] = "Gamma";
    })(exports3.ColorSpace || (exports3.ColorSpace = {}));
    var ShaderUniform = /* @__PURE__ */ function() {
      function ShaderUniform2(engine) {
        this.name = void 0;
        this.propertyId = void 0;
        this.location = void 0;
        this.applyFunc = void 0;
        this.cacheValue = void 0;
        this.textureIndex = void 0;
        this.textureDefault = void 0;
        this._rhi = void 0;
        this._gl = void 0;
        this._colorSpace = void 0;
        var rhi = engine._hardwareRenderer;
        this._rhi = rhi;
        this._gl = rhi.gl;
        this._colorSpace = engine.settings.colorSpace;
      }
      var _proto = ShaderUniform2.prototype;
      _proto.upload1f = function upload1f(shaderUniform, value) {
        if (this.cacheValue !== value) {
          this._gl.uniform1f(shaderUniform.location, value);
          this.cacheValue = value;
        }
      };
      _proto.upload1fv = function upload1fv(shaderUniform, value) {
        this._gl.uniform1fv(shaderUniform.location, value);
      };
      _proto.upload2f = function upload2f(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== void 0) {
          if (cacheValue.x !== value.r || cacheValue.y !== value.g) {
            if (this._colorSpace === exports3.ColorSpace.Linear) {
              this._gl.uniform2f(shaderUniform.location, miniprogram2.Color.gammaToLinearSpace(value.r), miniprogram2.Color.gammaToLinearSpace(value.g));
            } else {
              this._gl.uniform2f(shaderUniform.location, value.r, value.g);
            }
            cacheValue.x = value.r;
            cacheValue.y = value.g;
          }
        } else {
          if (cacheValue.x !== value.x || cacheValue.y !== value.y) {
            this._gl.uniform2f(shaderUniform.location, value.x, value.y);
            cacheValue.x = value.x;
            cacheValue.y = value.y;
          }
        }
      };
      _proto.upload2fv = function upload2fv(shaderUniform, value) {
        this._gl.uniform2fv(shaderUniform.location, value);
      };
      _proto.upload3f = function upload3f(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== void 0) {
          if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b) {
            if (this._colorSpace === exports3.ColorSpace.Linear) {
              this._gl.uniform3f(shaderUniform.location, miniprogram2.Color.gammaToLinearSpace(value.r), miniprogram2.Color.gammaToLinearSpace(value.g), miniprogram2.Color.gammaToLinearSpace(value.b));
            } else {
              this._gl.uniform3f(shaderUniform.location, value.r, value.g, value.b);
            }
            cacheValue.x = value.r;
            cacheValue.y = value.g;
            cacheValue.z = value.b;
          }
        } else {
          if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z) {
            this._gl.uniform3f(shaderUniform.location, value.x, value.y, value.z);
            cacheValue.x = value.x;
            cacheValue.y = value.y;
            cacheValue.z = value.z;
          }
        }
      };
      _proto.upload3fv = function upload3fv(shaderUniform, value) {
        this._gl.uniform3fv(shaderUniform.location, value);
      };
      _proto.upload4f = function upload4f(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== void 0) {
          if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b || cacheValue.w !== value.a) {
            if (this._colorSpace === exports3.ColorSpace.Linear) {
              this._gl.uniform4f(shaderUniform.location, miniprogram2.Color.gammaToLinearSpace(value.r), miniprogram2.Color.gammaToLinearSpace(value.g), miniprogram2.Color.gammaToLinearSpace(value.b), value.a);
            } else {
              this._gl.uniform4f(shaderUniform.location, value.r, value.g, value.b, value.a);
            }
            cacheValue.x = value.r;
            cacheValue.y = value.g;
            cacheValue.z = value.b;
            cacheValue.w = value.a;
          }
        } else {
          if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z || cacheValue.w !== value.w) {
            this._gl.uniform4f(shaderUniform.location, value.x, value.y, value.z, value.w);
            cacheValue.x = value.x;
            cacheValue.y = value.y;
            cacheValue.z = value.z;
            cacheValue.w = value.w;
          }
        }
      };
      _proto.upload4fv = function upload4fv(shaderUniform, value) {
        this._gl.uniform4fv(shaderUniform.location, value);
      };
      _proto.upload1i = function upload1i(shaderUniform, value) {
        if (this.cacheValue !== value) {
          this._gl.uniform1i(shaderUniform.location, value);
          this.cacheValue = value;
        }
      };
      _proto.upload1iv = function upload1iv(shaderUniform, value) {
        this._gl.uniform1iv(shaderUniform.location, value);
      };
      _proto.upload2i = function upload2i(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== void 0) {
          if (cacheValue.x !== value.r || cacheValue.y !== value.g) {
            this._gl.uniform2i(shaderUniform.location, value.r, value.g);
            cacheValue.x = value.r;
            cacheValue.y = value.g;
          }
        } else {
          if (cacheValue.x !== value.x || cacheValue.y !== value.y) {
            this._gl.uniform2i(shaderUniform.location, value.x, value.y);
            cacheValue.x = value.x;
            cacheValue.y = value.y;
          }
        }
      };
      _proto.upload2iv = function upload2iv(shaderUniform, value) {
        this._gl.uniform2iv(shaderUniform.location, value);
      };
      _proto.upload3i = function upload3i(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== void 0) {
          if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b) {
            this._gl.uniform3i(shaderUniform.location, value.r, value.g, value.b);
            cacheValue.x = value.r;
            cacheValue.y = value.g;
            cacheValue.z = value.b;
          }
        } else {
          if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z) {
            this._gl.uniform3i(shaderUniform.location, value.x, value.y, value.z);
            cacheValue.x = value.x;
            cacheValue.y = value.y;
            cacheValue.z = value.z;
          }
        }
      };
      _proto.upload3iv = function upload3iv(shaderUniform, value) {
        this._gl.uniform3iv(shaderUniform.location, value);
      };
      _proto.upload4i = function upload4i(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== void 0) {
          if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b || cacheValue.w !== value.a) {
            this._gl.uniform4i(shaderUniform.location, value.r, value.g, value.b, value.a);
            cacheValue.x = value.r;
            cacheValue.y = value.g;
            cacheValue.z = value.b;
            cacheValue.w = value.a;
          }
        } else {
          if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z || cacheValue.w !== value.w) {
            this._gl.uniform4i(shaderUniform.location, value.x, value.y, value.z, value.w);
            cacheValue.x = value.x;
            cacheValue.y = value.y;
            cacheValue.z = value.z;
            cacheValue.w = value.w;
          }
        }
      };
      _proto.upload4iv = function upload4iv(shaderUniform, value) {
        this._gl.uniform4iv(shaderUniform.location, value);
      };
      _proto.uploadMat4 = function uploadMat4(shaderUniform, value) {
        this._gl.uniformMatrix4fv(shaderUniform.location, false, value.elements);
      };
      _proto.uploadMat4v = function uploadMat4v(shaderUniform, value) {
        this._gl.uniformMatrix4fv(shaderUniform.location, false, value);
      };
      _proto.uploadTexture = function uploadTexture(shaderUniform, value) {
        var rhi = this._rhi;
        rhi.activeTexture(shaderUniform.textureIndex);
        rhi.bindTexture(value._platformTexture);
      };
      _proto.uploadTextureArray = function uploadTextureArray(shaderUniform, value) {
        var rhi = this._rhi;
        var textureIndices = shaderUniform.textureIndex;
        for (var i = 0; i < value.length; i++) {
          var texture = value[i];
          rhi.activeTexture(textureIndices[i]);
          rhi.bindTexture(texture._platformTexture);
        }
      };
      return ShaderUniform2;
    }();
    var ShaderUniformBlock = function ShaderUniformBlock2() {
      this.constUniforms = [];
      this.textureUniforms = [];
    };
    var ShaderProgram = /* @__PURE__ */ function() {
      ShaderProgram2._addLineNum = function _addLineNum(str) {
        var lines = str.split("\n");
        var limitLength = (lines.length + 1).toString().length + 6;
        var prefix;
        return lines.map(function(line, index) {
          prefix = "0:" + (index + 1);
          if (prefix.length >= limitLength)
            return prefix.substring(0, limitLength) + line;
          for (var i = 0; i < limitLength - prefix.length; i++) {
            prefix += " ";
          }
          return prefix + line;
        }).join("\n");
      };
      function ShaderProgram2(engine, vertexSource, fragmentSource) {
        this.id = void 0;
        this.sceneUniformBlock = new ShaderUniformBlock();
        this.cameraUniformBlock = new ShaderUniformBlock();
        this.rendererUniformBlock = new ShaderUniformBlock();
        this.materialUniformBlock = new ShaderUniformBlock();
        this.otherUniformBlock = new ShaderUniformBlock();
        this._uploadRenderCount = -1;
        this._uploadCamera = void 0;
        this._uploadRenderer = void 0;
        this._uploadMaterial = void 0;
        this.attributeLocation = /* @__PURE__ */ Object.create(null);
        this._isValid = void 0;
        this._engine = void 0;
        this._gl = void 0;
        this._vertexShader = void 0;
        this._fragmentShader = void 0;
        this._glProgram = void 0;
        this._activeTextureUint = 0;
        this._engine = engine;
        this._gl = engine._hardwareRenderer.gl;
        this._glProgram = this._createProgram(vertexSource, fragmentSource);
        if (this._glProgram) {
          this._isValid = true;
          this._recordLocation();
        } else {
          this._isValid = false;
        }
        this.id = ShaderProgram2._counter++;
      }
      var _proto = ShaderProgram2.prototype;
      _proto.uploadAll = function uploadAll(uniformBlock, shaderData) {
        this.uploadUniforms(uniformBlock, shaderData);
        this.uploadTextures(uniformBlock, shaderData);
      };
      _proto.uploadUniforms = function uploadUniforms(uniformBlock, shaderData) {
        var propertyValueMap = shaderData._propertyValueMap;
        var constUniforms = uniformBlock.constUniforms;
        for (var i = 0, n = constUniforms.length; i < n; i++) {
          var uniform = constUniforms[i];
          var data = propertyValueMap[uniform.propertyId];
          data != null && uniform.applyFunc(uniform, data);
        }
      };
      _proto.uploadTextures = function uploadTextures(uniformBlock, shaderData) {
        var propertyValueMap = shaderData._propertyValueMap;
        var textureUniforms = uniformBlock.textureUniforms;
        if (textureUniforms) {
          for (var i = 0, n = textureUniforms.length; i < n; i++) {
            var uniform = textureUniforms[i];
            var texture = propertyValueMap[uniform.propertyId];
            if (texture && !texture.destroyed) {
              uniform.applyFunc(uniform, texture);
            } else {
              uniform.applyFunc(uniform, uniform.textureDefault);
            }
          }
        }
      };
      _proto.uploadUnGroupTextures = function uploadUnGroupTextures() {
        var textureUniforms = this.otherUniformBlock.textureUniforms;
        if (textureUniforms) {
          for (var i = 0, n = textureUniforms.length; i < n; i++) {
            var uniform = textureUniforms[i];
            uniform.applyFunc(uniform, uniform.textureDefault);
          }
        }
      };
      _proto.groupingOtherUniformBlock = function groupingOtherUniformBlock() {
        var _this$otherUniformBlo = this.otherUniformBlock, constUniforms = _this$otherUniformBlo.constUniforms, textureUniforms = _this$otherUniformBlo.textureUniforms;
        constUniforms.length > 0 && this._groupingSubOtherUniforms(constUniforms, false);
        textureUniforms.length > 0 && this._groupingSubOtherUniforms(textureUniforms, true);
      };
      _proto.bind = function bind() {
        var rhi = this._engine._hardwareRenderer;
        if (rhi._currentBind !== this) {
          this._gl.useProgram(this._glProgram);
          rhi._currentBind = this;
          return true;
        } else {
          return false;
        }
      };
      _proto.destroy = function destroy() {
        var gl = this._gl;
        this._vertexShader && gl.deleteShader(this._vertexShader);
        this._fragmentShader && gl.deleteShader(this._fragmentShader);
        this._glProgram && gl.deleteProgram(this._glProgram);
      };
      _proto._groupingSubOtherUniforms = function _groupingSubOtherUniforms(uniforms, isTexture) {
        for (var i = uniforms.length - 1; i >= 0; i--) {
          var uniform = uniforms[i];
          var group = Shader._getShaderPropertyGroup(uniform.name);
          if (group !== void 0) {
            uniforms.splice(uniforms.indexOf(uniform), 1);
            this._groupingUniform(uniform, group, isTexture);
          }
        }
      };
      _proto._groupingUniform = function _groupingUniform(uniform, group, isTexture) {
        switch (group) {
          case ShaderDataGroup.Scene:
            if (isTexture) {
              this.sceneUniformBlock.textureUniforms.push(uniform);
            } else {
              this.sceneUniformBlock.constUniforms.push(uniform);
            }
            break;
          case ShaderDataGroup.Camera:
            if (isTexture) {
              this.cameraUniformBlock.textureUniforms.push(uniform);
            } else {
              this.cameraUniformBlock.constUniforms.push(uniform);
            }
            break;
          case ShaderDataGroup.Renderer:
            if (isTexture) {
              this.rendererUniformBlock.textureUniforms.push(uniform);
            } else {
              this.rendererUniformBlock.constUniforms.push(uniform);
            }
            break;
          case ShaderDataGroup.Material:
            if (isTexture) {
              this.materialUniformBlock.textureUniforms.push(uniform);
            } else {
              this.materialUniformBlock.constUniforms.push(uniform);
            }
            break;
          default:
            if (isTexture) {
              this.otherUniformBlock.textureUniforms.push(uniform);
            } else {
              this.otherUniformBlock.constUniforms.push(uniform);
            }
        }
      };
      _proto._createProgram = function _createProgram(vertexSource, fragmentSource) {
        var gl = this._gl;
        var vertexShader = this._createShader(gl.VERTEX_SHADER, vertexSource);
        if (!vertexShader) {
          return null;
        }
        var fragmentShader = this._createShader(gl.FRAGMENT_SHADER, fragmentSource);
        if (!fragmentShader) {
          return null;
        }
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.validateProgram(program);
        if (gl.isContextLost()) {
          Logger.error("Context lost while linking program.");
          gl.deleteShader(vertexShader);
          gl.deleteShader(fragmentShader);
          return null;
        }
        if (Logger.isEnabled && !gl.getProgramParameter(program, gl.LINK_STATUS)) {
          Logger.error("Could not link WebGL program. \n" + gl.getProgramInfoLog(program));
          gl.deleteProgram(program);
          return null;
        }
        this._vertexShader = vertexShader;
        this._fragmentShader = fragmentShader;
        return program;
      };
      _proto._createShader = function _createShader(shaderType, shaderSource) {
        var gl = this._gl;
        var shader = gl.createShader(shaderType);
        if (!shader) {
          Logger.error("Context lost while create shader.");
          return null;
        }
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        if (gl.isContextLost()) {
          Logger.error("Context lost while compiling shader.");
          gl.deleteShader(shader);
          return null;
        }
        if (Logger.isEnabled && !gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          Logger.error("Could not compile WebGL shader.\n" + gl.getShaderInfoLog(shader), ShaderProgram2._addLineNum(shaderSource));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      };
      _proto._recordLocation = function _recordLocation() {
        var _this = this;
        var gl = this._gl;
        var program = this._glProgram;
        var uniformInfos = this._getUniformInfos();
        var attributeInfos = this._getAttributeInfos();
        uniformInfos.forEach(function(_ref) {
          var name = _ref.name, size = _ref.size, type = _ref.type;
          var shaderUniform = new ShaderUniform(_this._engine);
          var isArray = false;
          var isTexture = false;
          if (name.indexOf("[0]") > 0) {
            name = name.substr(0, name.length - 3);
            isArray = true;
          }
          var location = gl.getUniformLocation(program, name);
          shaderUniform.name = name;
          shaderUniform.propertyId = Shader.getPropertyByName(name)._uniqueId;
          shaderUniform.location = location;
          switch (type) {
            case gl.FLOAT:
              if (isArray) {
                shaderUniform.applyFunc = shaderUniform.upload1fv;
              } else {
                shaderUniform.applyFunc = shaderUniform.upload1f;
                shaderUniform.cacheValue = 0;
              }
              break;
            case gl.FLOAT_VEC2:
              if (isArray) {
                shaderUniform.applyFunc = shaderUniform.upload2fv;
              } else {
                shaderUniform.applyFunc = shaderUniform.upload2f;
                shaderUniform.cacheValue = new miniprogram2.Vector2(0, 0);
              }
              break;
            case gl.FLOAT_VEC3:
              if (isArray) {
                shaderUniform.applyFunc = shaderUniform.upload3fv;
              } else {
                shaderUniform.applyFunc = shaderUniform.upload3f;
                shaderUniform.cacheValue = new miniprogram2.Vector3(0, 0, 0);
              }
              break;
            case gl.FLOAT_VEC4:
              if (isArray) {
                shaderUniform.applyFunc = shaderUniform.upload4fv;
              } else {
                shaderUniform.applyFunc = shaderUniform.upload4f;
                shaderUniform.cacheValue = new miniprogram2.Vector4(0, 0, 0, 0);
              }
              break;
            case gl.BOOL:
            case gl.INT:
              if (isArray) {
                shaderUniform.applyFunc = shaderUniform.upload1iv;
              } else {
                shaderUniform.applyFunc = shaderUniform.upload1i;
                shaderUniform.cacheValue = 0;
              }
              break;
            case gl.BOOL_VEC2:
            case gl.INT_VEC2:
              if (isArray) {
                shaderUniform.applyFunc = shaderUniform.upload2iv;
              } else {
                shaderUniform.applyFunc = shaderUniform.upload2i;
                shaderUniform.cacheValue = new miniprogram2.Vector2(0, 0);
              }
              break;
            case gl.BOOL_VEC3:
            case gl.INT_VEC3:
              shaderUniform.applyFunc = isArray ? shaderUniform.upload3iv : shaderUniform.upload3i;
              shaderUniform.cacheValue = new miniprogram2.Vector3(0, 0, 0);
              break;
            case gl.BOOL_VEC4:
            case gl.INT_VEC4:
              if (isArray) {
                shaderUniform.applyFunc = shaderUniform.upload4iv;
              } else {
                shaderUniform.applyFunc = shaderUniform.upload4i;
                shaderUniform.cacheValue = new miniprogram2.Vector4(0, 0, 0);
              }
              break;
            case gl.FLOAT_MAT4:
              shaderUniform.applyFunc = isArray ? shaderUniform.uploadMat4v : shaderUniform.uploadMat4;
              break;
            case gl.SAMPLER_2D:
            case gl.SAMPLER_CUBE:
            case gl.SAMPLER_2D_ARRAY:
              var defaultTexture;
              switch (type) {
                case gl.SAMPLER_2D:
                  defaultTexture = _this._engine._magentaTexture2D;
                  break;
                case gl.SAMPLER_CUBE:
                  defaultTexture = _this._engine._magentaTextureCube;
                  break;
                case gl.SAMPLER_2D_ARRAY:
                  defaultTexture = _this._engine._magentaTexture2DArray;
                  break;
                default:
                  throw new Error("Unsupported texture type.");
              }
              isTexture = true;
              if (isArray) {
                var defaultTextures = new Array(size);
                var textureIndices = new Int32Array(size);
                var glTextureIndices = new Array(size);
                for (var i = 0; i < size; i++) {
                  defaultTextures[i] = defaultTexture;
                  textureIndices[i] = _this._activeTextureUint;
                  glTextureIndices[i] = gl.TEXTURE0 + _this._activeTextureUint++;
                }
                shaderUniform.textureDefault = defaultTextures;
                shaderUniform.textureIndex = glTextureIndices;
                shaderUniform.applyFunc = shaderUniform.uploadTextureArray;
                _this.bind();
                gl.uniform1iv(location, textureIndices);
                shaderUniform.uploadTextureArray(shaderUniform, defaultTextures);
              } else {
                var textureIndex = gl.TEXTURE0 + _this._activeTextureUint;
                shaderUniform.textureDefault = defaultTexture;
                shaderUniform.textureIndex = textureIndex;
                shaderUniform.applyFunc = shaderUniform.uploadTexture;
                _this.bind();
                gl.uniform1i(location, _this._activeTextureUint++);
                shaderUniform.uploadTexture(shaderUniform, defaultTexture);
              }
              break;
          }
          var group = Shader._getShaderPropertyGroup(name);
          _this._groupingUniform(shaderUniform, group, isTexture);
        });
        attributeInfos.forEach(function(_ref2) {
          var name = _ref2.name;
          _this.attributeLocation[name] = gl.getAttribLocation(program, name);
        });
      };
      _proto._getUniformInfos = function _getUniformInfos() {
        var gl = this._gl;
        var program = this._glProgram;
        var uniformInfos = new Array();
        var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (var i = 0; i < uniformCount; ++i) {
          var info2 = gl.getActiveUniform(program, i);
          uniformInfos[i] = info2;
        }
        return uniformInfos;
      };
      _proto._getAttributeInfos = function _getAttributeInfos() {
        var gl = this._gl;
        var program = this._glProgram;
        var attributeInfos = new Array();
        var attributeCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < attributeCount; ++i) {
          var info2 = gl.getActiveAttrib(program, i);
          attributeInfos[i] = info2;
        }
        return attributeInfos;
      };
      _createClass2(ShaderProgram2, [{
        key: "isValid",
        get: function get() {
          return this._isValid;
        }
      }]);
      return ShaderProgram2;
    }();
    ShaderProgram._counter = 0;
    var ShaderProperty = /* @__PURE__ */ function() {
      function ShaderProperty2(name) {
        this._uniqueId = void 0;
        this._group = void 0;
        this._type = void 0;
        this.name = void 0;
        this.name = name;
        this._uniqueId = ShaderProperty2._propertyNameCounter++;
      }
      _createClass2(ShaderProperty2, [{
        key: "type",
        get: function get() {
          return this._type;
        }
      }]);
      return ShaderProperty2;
    }();
    ShaderProperty._propertyNameCounter = 0;
    var Shader = /* @__PURE__ */ function() {
      Shader2.create = function create(name, vertexSource, fragmentSource) {
        var shaderMap = Shader2._shaderMap;
        if (shaderMap[name]) {
          throw 'Shader named "' + name + '" already exists.';
        }
        return shaderMap[name] = new Shader2(name, vertexSource, fragmentSource);
      };
      Shader2.find = function find(name) {
        return Shader2._shaderMap[name];
      };
      Shader2.getMacroByName = function getMacroByName(name, value) {
        var key = value ? name + " " + value : name;
        var macro = Shader2._macroMap[key];
        if (!macro) {
          var maskMap = Shader2._macroMaskMap;
          var counter = Shader2._macroCounter;
          var index = Math.floor(counter / 32);
          var bit = counter % 32;
          macro = new ShaderMacro(name, value, index, 1 << bit);
          Shader2._macroMap[key] = macro;
          if (index == maskMap.length) {
            maskMap.length++;
            maskMap[index] = new Array(32);
          }
          maskMap[index][bit] = key;
          Shader2._macroCounter++;
        }
        return macro;
      };
      Shader2.getPropertyByName = function getPropertyByName(name) {
        var propertyNameMap = Shader2._propertyNameMap;
        if (propertyNameMap[name] != null) {
          return propertyNameMap[name];
        } else {
          var property = new ShaderProperty(name);
          propertyNameMap[name] = property;
          Shader2._propertyIdMap[property._uniqueId] = property;
          return property;
        }
      };
      Shader2._getShaderPropertyGroup = function _getShaderPropertyGroup(propertyName) {
        var shaderProperty = Shader2._propertyNameMap[propertyName];
        return shaderProperty === null || shaderProperty === void 0 ? void 0 : shaderProperty._group;
      };
      Shader2._getNamesByMacros = function _getNamesByMacros(macros, out) {
        var maskMap = Shader2._macroMaskMap;
        var mask = macros._mask;
        out.length = 0;
        for (var i = 0, n = macros._length; i < n; i++) {
          var subMaskMap = maskMap[i];
          var subMask = mask[i];
          var _n = subMask < 0 ? 32 : Math.floor(Math.log2(subMask)) + 1;
          for (var j = 0; j < _n; j++) {
            if (subMask & 1 << j) {
              out.push(subMaskMap[j]);
            }
          }
        }
      };
      function Shader2(name, vertexSource, fragmentSource) {
        this.name = void 0;
        this._shaderId = 0;
        this._vertexSource = void 0;
        this._fragmentSource = void 0;
        this._shaderId = Shader2._shaderCounter++;
        this.name = name;
        this._vertexSource = vertexSource;
        this._fragmentSource = fragmentSource;
      }
      var _proto = Shader2.prototype;
      _proto.compileVariant = function compileVariant(engine, macros) {
        var compileMacros = Shader2._compileMacros;
        compileMacros.clear();
        for (var i = 0, n = macros.length; i < n; i++) {
          compileMacros.enable(Shader2.getMacroByName(macros[i]));
        }
        return this._getShaderProgram(engine, compileMacros).isValid;
      };
      _proto._getShaderProgram = function _getShaderProgram(engine, macroCollection) {
        var shaderProgramPool = engine._getShaderProgramPool(this);
        var shaderProgram = shaderProgramPool.get(macroCollection);
        if (shaderProgram) {
          return shaderProgram;
        }
        var isWebGL2 = engine._hardwareRenderer.isWebGL2;
        var macroNameList = [];
        Shader2._getNamesByMacros(macroCollection, macroNameList);
        var macroNameStr = ShaderFactory.parseCustomMacros(macroNameList);
        var versionStr = isWebGL2 ? "#version 300 es" : "#version 100";
        var precisionStr = "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      precision highp int;\n    #else\n      precision mediump float;\n      precision mediump int;\n    #endif\n    ";
        if (engine._hardwareRenderer.canIUse(exports3.GLCapabilityType.shaderTextureLod)) {
          precisionStr += "#define HAS_TEX_LOD\n";
        }
        if (engine._hardwareRenderer.canIUse(exports3.GLCapabilityType.standardDerivatives)) {
          precisionStr += "#define HAS_DERIVATIVES\n";
        }
        var vertexSource = ShaderFactory.parseIncludes(" " + versionStr + "\n        " + precisionStr + "\n        " + macroNameStr + "\n        " + this._vertexSource);
        var fragmentSource = ShaderFactory.parseIncludes(" " + versionStr + "\n        " + (isWebGL2 ? "" : ShaderFactory.parseExtension(Shader2._shaderExtension)) + "\n        " + precisionStr + "\n        " + macroNameStr + "\n      " + this._fragmentSource);
        if (isWebGL2) {
          vertexSource = ShaderFactory.convertTo300(vertexSource);
          fragmentSource = ShaderFactory.convertTo300(fragmentSource, true);
        }
        shaderProgram = new ShaderProgram(engine, vertexSource, fragmentSource);
        shaderProgramPool.cache(shaderProgram);
        return shaderProgram;
      };
      return Shader2;
    }();
    Shader._compileMacros = new ShaderMacroCollection();
    Shader._propertyIdMap = /* @__PURE__ */ Object.create(null);
    Shader._shaderCounter = 0;
    Shader._shaderMap = /* @__PURE__ */ Object.create(null);
    Shader._propertyNameMap = /* @__PURE__ */ Object.create(null);
    Shader._macroMaskMap = [];
    Shader._macroCounter = 0;
    Shader._macroMap = /* @__PURE__ */ Object.create(null);
    Shader._shaderExtension = ["GL_EXT_shader_texture_lod", "GL_OES_standard_derivatives", "GL_EXT_draw_buffers"];
    var ShaderData = /* @__PURE__ */ function() {
      function ShaderData2(group) {
        this._group = void 0;
        this._propertyValueMap = /* @__PURE__ */ Object.create(null);
        this._macroCollection = new ShaderMacroCollection();
        this._macroMap = /* @__PURE__ */ Object.create(null);
        this._refCount = 0;
        this._group = group;
      }
      var _proto = ShaderData2.prototype;
      _proto.getFloat = function getFloat(property) {
        return this.getPropertyValue(property);
      };
      _proto.setFloat = function setFloat(property, value) {
        this._setPropertyValue(property, exports3.ShaderPropertyType.Float, value);
      };
      _proto.getInt = function getInt(property) {
        return this.getPropertyValue(property);
      };
      _proto.setInt = function setInt(property, value) {
        this._setPropertyValue(property, exports3.ShaderPropertyType.Int, value);
      };
      _proto.getFloatArray = function getFloatArray(property) {
        return this.getPropertyValue(property);
      };
      _proto.setFloatArray = function setFloatArray(property, value) {
        this._setPropertyValue(property, exports3.ShaderPropertyType.FloatArray, value);
      };
      _proto.getIntArray = function getIntArray(property) {
        return this.getPropertyValue(property);
      };
      _proto.setIntArray = function setIntArray(property, value) {
        this._setPropertyValue(property, exports3.ShaderPropertyType.IntArray, value);
      };
      _proto.getVector2 = function getVector2(property) {
        return this.getPropertyValue(property);
      };
      _proto.setVector2 = function setVector2(property, value) {
        this._setPropertyValue(property, exports3.ShaderPropertyType.Vector2, value);
      };
      _proto.getVector3 = function getVector3(property) {
        return this.getPropertyValue(property);
      };
      _proto.setVector3 = function setVector3(property, value) {
        this._setPropertyValue(property, exports3.ShaderPropertyType.Vector3, value);
      };
      _proto.getVector4 = function getVector4(property) {
        return this.getPropertyValue(property);
      };
      _proto.setVector4 = function setVector4(property, value) {
        this._setPropertyValue(property, exports3.ShaderPropertyType.Vector4, value);
      };
      _proto.getMatrix = function getMatrix(property) {
        return this.getPropertyValue(property);
      };
      _proto.setMatrix = function setMatrix(property, value) {
        this._setPropertyValue(property, exports3.ShaderPropertyType.Matrix, value);
      };
      _proto.getColor = function getColor(property) {
        return this.getPropertyValue(property);
      };
      _proto.setColor = function setColor(property, value) {
        this._setPropertyValue(property, exports3.ShaderPropertyType.Color, value);
      };
      _proto.getTexture = function getTexture(property) {
        return this.getPropertyValue(property);
      };
      _proto.setTexture = function setTexture(property, value) {
        if (this._getRefCount() > 0) {
          var lastValue = this.getPropertyValue(property);
          lastValue && lastValue._addRefCount(-1);
          value && value._addRefCount(1);
        }
        this._setPropertyValue(property, exports3.ShaderPropertyType.Texture, value);
      };
      _proto.getTextureArray = function getTextureArray(property) {
        return this.getPropertyValue(property);
      };
      _proto.setTextureArray = function setTextureArray(property, value) {
        if (this._getRefCount() > 0) {
          var lastValue = this.getPropertyValue(property);
          if (lastValue) {
            for (var i = 0, n = lastValue.length; i < n; i++) {
              lastValue[i]._addRefCount(-1);
            }
          }
          if (value) {
            for (var _i = 0, _n = value.length; _i < _n; _i++) {
              value[_i]._addRefCount(1);
            }
          }
        }
        this._setPropertyValue(property, exports3.ShaderPropertyType.TextureArray, value);
      };
      _proto.getPropertyValue = function getPropertyValue(property) {
        if (typeof property === "string") {
          property = Shader.getPropertyByName(property);
        }
        return this._propertyValueMap[property._uniqueId];
      };
      _proto.enableMacro = function enableMacro(macro, value) {
        if (typeof macro === "string") {
          macro = Shader.getMacroByName(macro, value);
        }
        var nameID = macro._nameId;
        var lastMacro = this._macroMap[nameID];
        if (lastMacro !== macro) {
          var macroCollection = this._macroCollection;
          lastMacro && macroCollection.disable(lastMacro);
          macroCollection.enable(macro);
          this._macroMap[nameID] = macro;
        }
      };
      _proto.disableMacro = function disableMacro(macro) {
        var nameID;
        if (typeof macro === "string") {
          nameID = ShaderMacro._macroNameIdMap[macro];
          if (nameID === void 0) {
            return;
          }
        } else {
          nameID = macro._nameId;
        }
        var currentMacro = this._macroMap[nameID];
        if (currentMacro) {
          this._macroCollection.disable(currentMacro);
          delete this._macroMap[nameID];
        }
      };
      _proto.getMacros = function getMacros(out) {
        if (out) {
          var macroMap = this._macroMap;
          out.length = 0;
          for (var key in macroMap) {
            out.push(macroMap[key]);
          }
        } else {
          return Object.values(this._macroMap);
        }
      };
      _proto.getProperties = function getProperties(out) {
        var properties;
        if (out) {
          out.length = 0;
          properties = out;
        } else {
          properties = [];
        }
        var propertyValueMap = this._propertyValueMap;
        var propertyIdMap = Shader._propertyIdMap;
        for (var key in propertyValueMap) {
          properties.push(propertyIdMap[key]);
        }
        if (!out) {
          return properties;
        }
      };
      _proto.clone = function clone() {
        var shaderData = new ShaderData2(this._group);
        this.cloneTo(shaderData);
        return shaderData;
      };
      _proto.cloneTo = function cloneTo(target) {
        CloneManager.deepCloneObject(this._macroCollection, target._macroCollection);
        _extends(target._macroMap, this._macroMap);
        var propertyValueMap = this._propertyValueMap;
        var targetPropertyValueMap = target._propertyValueMap;
        var keys = Object.keys(propertyValueMap);
        for (var i = 0, n = keys.length; i < n; i++) {
          var k = keys[i];
          var _property = propertyValueMap[k];
          if (_property != null) {
            if (typeof _property === "number") {
              targetPropertyValueMap[k] = _property;
            } else if (_property instanceof Texture) {
              targetPropertyValueMap[k] = _property;
            } else if (_property instanceof Array || _property instanceof Float32Array || _property instanceof Int32Array) {
              targetPropertyValueMap[k] = _property.slice();
            } else {
              var targetProperty = targetPropertyValueMap[k];
              if (targetProperty) {
                targetProperty.copyFrom(_property);
              } else {
                targetPropertyValueMap[k] = _property.clone();
              }
            }
          } else {
            targetPropertyValueMap[k] = _property;
          }
        }
      };
      _proto._setPropertyValue = function _setPropertyValue(property, type, value) {
        if (typeof property === "string") {
          property = Shader.getPropertyByName(property);
        }
        if (property._group !== this._group) {
          if (property._group === void 0) {
            property._group = this._group;
          } else {
            throw "Shader property " + property.name + " has been used as " + ShaderDataGroup[property._group] + " group.";
          }
        }
        if (property._type !== type) {
          if (property._type === void 0) {
            property._type = type;
          } else {
            throw "Shader property " + property.name + " has been used as " + exports3.ShaderPropertyType[property._type] + " type.";
          }
        }
        this._propertyValueMap[property._uniqueId] = value;
      };
      _proto._getRefCount = function _getRefCount() {
        return this._refCount;
      };
      _proto._addRefCount = function _addRefCount(value) {
        this._refCount += value;
        var properties = this._propertyValueMap;
        for (var k in properties) {
          var _property2 = properties[k];
          if (_property2 && _property2 instanceof Texture) {
            _property2._addRefCount(value);
          }
        }
      };
      return ShaderData2;
    }();
    exports3.BlendFactor = void 0;
    (function(BlendFactor) {
      BlendFactor[BlendFactor["Zero"] = 0] = "Zero";
      BlendFactor[BlendFactor["One"] = 1] = "One";
      BlendFactor[BlendFactor["SourceColor"] = 2] = "SourceColor";
      BlendFactor[BlendFactor["OneMinusSourceColor"] = 3] = "OneMinusSourceColor";
      BlendFactor[BlendFactor["DestinationColor"] = 4] = "DestinationColor";
      BlendFactor[BlendFactor["OneMinusDestinationColor"] = 5] = "OneMinusDestinationColor";
      BlendFactor[BlendFactor["SourceAlpha"] = 6] = "SourceAlpha";
      BlendFactor[BlendFactor["OneMinusSourceAlpha"] = 7] = "OneMinusSourceAlpha";
      BlendFactor[BlendFactor["DestinationAlpha"] = 8] = "DestinationAlpha";
      BlendFactor[BlendFactor["OneMinusDestinationAlpha"] = 9] = "OneMinusDestinationAlpha";
      BlendFactor[BlendFactor["SourceAlphaSaturate"] = 10] = "SourceAlphaSaturate";
      BlendFactor[BlendFactor["BlendColor"] = 11] = "BlendColor";
      BlendFactor[BlendFactor["OneMinusBlendColor"] = 12] = "OneMinusBlendColor";
    })(exports3.BlendFactor || (exports3.BlendFactor = {}));
    exports3.BlendOperation = void 0;
    (function(BlendOperation) {
      BlendOperation[BlendOperation["Add"] = 0] = "Add";
      BlendOperation[BlendOperation["Subtract"] = 1] = "Subtract";
      BlendOperation[BlendOperation["ReverseSubtract"] = 2] = "ReverseSubtract";
      BlendOperation[BlendOperation["Min"] = 3] = "Min";
      BlendOperation[BlendOperation["Max"] = 4] = "Max";
    })(exports3.BlendOperation || (exports3.BlendOperation = {}));
    exports3.ColorWriteMask = void 0;
    (function(ColorWriteMask) {
      ColorWriteMask[ColorWriteMask["None"] = 0] = "None";
      ColorWriteMask[ColorWriteMask["Red"] = 1] = "Red";
      ColorWriteMask[ColorWriteMask["Green"] = 2] = "Green";
      ColorWriteMask[ColorWriteMask["Blue"] = 4] = "Blue";
      ColorWriteMask[ColorWriteMask["Alpha"] = 8] = "Alpha";
      ColorWriteMask[ColorWriteMask["All"] = 15] = "All";
    })(exports3.ColorWriteMask || (exports3.ColorWriteMask = {}));
    var RenderTargetBlendState = function RenderTargetBlendState2() {
      this.enabled = false;
      this.colorBlendOperation = exports3.BlendOperation.Add;
      this.alphaBlendOperation = exports3.BlendOperation.Add;
      this.sourceColorBlendFactor = exports3.BlendFactor.One;
      this.sourceAlphaBlendFactor = exports3.BlendFactor.One;
      this.destinationColorBlendFactor = exports3.BlendFactor.Zero;
      this.destinationAlphaBlendFactor = exports3.BlendFactor.Zero;
      this.colorWriteMask = exports3.ColorWriteMask.All;
    };
    var BlendState = /* @__PURE__ */ function() {
      function BlendState2() {
        this.targetBlendState = new RenderTargetBlendState();
        this.blendColor = new miniprogram2.Color(0, 0, 0, 0);
        this.alphaToCoverage = false;
      }
      BlendState2._getGLBlendFactor = function _getGLBlendFactor(rhi, blendFactor) {
        var gl = rhi.gl;
        switch (blendFactor) {
          case exports3.BlendFactor.Zero:
            return gl.ZERO;
          case exports3.BlendFactor.One:
            return gl.ONE;
          case exports3.BlendFactor.SourceColor:
            return gl.SRC_COLOR;
          case exports3.BlendFactor.OneMinusSourceColor:
            return gl.ONE_MINUS_SRC_COLOR;
          case exports3.BlendFactor.DestinationColor:
            return gl.DST_COLOR;
          case exports3.BlendFactor.OneMinusDestinationColor:
            return gl.ONE_MINUS_DST_COLOR;
          case exports3.BlendFactor.SourceAlpha:
            return gl.SRC_ALPHA;
          case exports3.BlendFactor.OneMinusSourceAlpha:
            return gl.ONE_MINUS_SRC_ALPHA;
          case exports3.BlendFactor.DestinationAlpha:
            return gl.DST_ALPHA;
          case exports3.BlendFactor.OneMinusDestinationAlpha:
            return gl.ONE_MINUS_DST_ALPHA;
          case exports3.BlendFactor.SourceAlphaSaturate:
            return gl.SRC_ALPHA_SATURATE;
          case exports3.BlendFactor.BlendColor:
            return gl.CONSTANT_COLOR;
          case exports3.BlendFactor.OneMinusBlendColor:
            return gl.ONE_MINUS_CONSTANT_COLOR;
        }
      };
      BlendState2._getGLBlendOperation = function _getGLBlendOperation(rhi, blendOperation) {
        var gl = rhi.gl;
        switch (blendOperation) {
          case exports3.BlendOperation.Add:
            return gl.FUNC_ADD;
          case exports3.BlendOperation.Subtract:
            return gl.FUNC_SUBTRACT;
          case exports3.BlendOperation.ReverseSubtract:
            return gl.FUNC_REVERSE_SUBTRACT;
          case exports3.BlendOperation.Min:
            if (!rhi.canIUse(exports3.GLCapabilityType.blendMinMax)) {
              throw new Error("BlendOperation.Min is not supported in this context");
            }
            return gl.MIN;
          case exports3.BlendOperation.Max:
            if (!rhi.canIUse(exports3.GLCapabilityType.blendMinMax)) {
              throw new Error("BlendOperation.Max is not supported in this context");
            }
            return gl.MAX;
        }
      };
      var _proto = BlendState2.prototype;
      _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
        this._platformApply(hardwareRenderer, lastRenderState.blendState);
      };
      _proto._platformApply = function _platformApply(rhi, lastState) {
        var gl = rhi.gl;
        var lastTargetBlendState = lastState.targetBlendState;
        var _this$targetBlendStat = this.targetBlendState, enabled = _this$targetBlendStat.enabled, colorBlendOperation = _this$targetBlendStat.colorBlendOperation, alphaBlendOperation = _this$targetBlendStat.alphaBlendOperation, sourceColorBlendFactor = _this$targetBlendStat.sourceColorBlendFactor, destinationColorBlendFactor = _this$targetBlendStat.destinationColorBlendFactor, sourceAlphaBlendFactor = _this$targetBlendStat.sourceAlphaBlendFactor, destinationAlphaBlendFactor = _this$targetBlendStat.destinationAlphaBlendFactor, colorWriteMask = _this$targetBlendStat.colorWriteMask;
        if (enabled !== lastTargetBlendState.enabled) {
          if (enabled) {
            gl.enable(gl.BLEND);
          } else {
            gl.disable(gl.BLEND);
          }
          lastTargetBlendState.enabled = enabled;
        }
        if (enabled) {
          if (sourceColorBlendFactor !== lastTargetBlendState.sourceColorBlendFactor || destinationColorBlendFactor !== lastTargetBlendState.destinationColorBlendFactor || sourceAlphaBlendFactor !== lastTargetBlendState.sourceAlphaBlendFactor || destinationAlphaBlendFactor !== lastTargetBlendState.destinationAlphaBlendFactor) {
            gl.blendFuncSeparate(BlendState2._getGLBlendFactor(rhi, sourceColorBlendFactor), BlendState2._getGLBlendFactor(rhi, destinationColorBlendFactor), BlendState2._getGLBlendFactor(rhi, sourceAlphaBlendFactor), BlendState2._getGLBlendFactor(rhi, destinationAlphaBlendFactor));
            lastTargetBlendState.sourceColorBlendFactor = sourceColorBlendFactor;
            lastTargetBlendState.destinationColorBlendFactor = destinationColorBlendFactor;
            lastTargetBlendState.sourceAlphaBlendFactor = sourceAlphaBlendFactor;
            lastTargetBlendState.destinationAlphaBlendFactor = destinationAlphaBlendFactor;
          }
          if (colorBlendOperation !== lastTargetBlendState.colorBlendOperation || alphaBlendOperation !== lastTargetBlendState.alphaBlendOperation) {
            gl.blendEquationSeparate(BlendState2._getGLBlendOperation(rhi, colorBlendOperation), BlendState2._getGLBlendOperation(rhi, alphaBlendOperation));
            lastTargetBlendState.colorBlendOperation = colorBlendOperation;
            lastTargetBlendState.alphaBlendOperation = alphaBlendOperation;
          }
          var blendColor = this.blendColor;
          if (!miniprogram2.Color.equals(lastState.blendColor, blendColor)) {
            gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendColor.a);
            lastState.blendColor.copyFrom(blendColor);
          }
        }
        if (colorWriteMask !== lastTargetBlendState.colorWriteMask) {
          gl.colorMask((colorWriteMask & exports3.ColorWriteMask.Red) !== 0, (colorWriteMask & exports3.ColorWriteMask.Green) !== 0, (colorWriteMask & exports3.ColorWriteMask.Blue) !== 0, (colorWriteMask & exports3.ColorWriteMask.Alpha) !== 0);
          lastTargetBlendState.colorWriteMask = colorWriteMask;
        }
        var alphaToCoverage = this.alphaToCoverage;
        if (alphaToCoverage !== lastState.alphaToCoverage) {
          if (alphaToCoverage) {
            gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
          } else {
            gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
          }
          lastState.alphaToCoverage = alphaToCoverage;
        }
      };
      return BlendState2;
    }();
    exports3.CompareFunction = void 0;
    (function(CompareFunction) {
      CompareFunction[CompareFunction["Never"] = 0] = "Never";
      CompareFunction[CompareFunction["Less"] = 1] = "Less";
      CompareFunction[CompareFunction["Equal"] = 2] = "Equal";
      CompareFunction[CompareFunction["LessEqual"] = 3] = "LessEqual";
      CompareFunction[CompareFunction["Greater"] = 4] = "Greater";
      CompareFunction[CompareFunction["NotEqual"] = 5] = "NotEqual";
      CompareFunction[CompareFunction["GreaterEqual"] = 6] = "GreaterEqual";
      CompareFunction[CompareFunction["Always"] = 7] = "Always";
    })(exports3.CompareFunction || (exports3.CompareFunction = {}));
    var DepthState = /* @__PURE__ */ function() {
      function DepthState2() {
        this.enabled = true;
        this.writeEnabled = true;
        this.compareFunction = exports3.CompareFunction.Less;
      }
      DepthState2._getGLCompareFunction = function _getGLCompareFunction(rhi, compareFunction) {
        var gl = rhi.gl;
        switch (compareFunction) {
          case exports3.CompareFunction.Never:
            return gl.NEVER;
          case exports3.CompareFunction.Less:
            return gl.LESS;
          case exports3.CompareFunction.Equal:
            return gl.EQUAL;
          case exports3.CompareFunction.LessEqual:
            return gl.LEQUAL;
          case exports3.CompareFunction.Greater:
            return gl.GREATER;
          case exports3.CompareFunction.NotEqual:
            return gl.NOTEQUAL;
          case exports3.CompareFunction.GreaterEqual:
            return gl.GEQUAL;
          case exports3.CompareFunction.Always:
            return gl.ALWAYS;
        }
      };
      var _proto = DepthState2.prototype;
      _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
        this._platformApply(hardwareRenderer, lastRenderState.depthState);
      };
      _proto._platformApply = function _platformApply(rhi, lastState) {
        var gl = rhi.gl;
        var enabled = this.enabled, compareFunction = this.compareFunction, writeEnabled = this.writeEnabled;
        if (enabled != lastState.enabled) {
          if (enabled) {
            gl.enable(gl.DEPTH_TEST);
          } else {
            gl.disable(gl.DEPTH_TEST);
          }
          lastState.enabled = enabled;
        }
        if (enabled) {
          if (compareFunction != lastState.compareFunction) {
            gl.depthFunc(DepthState2._getGLCompareFunction(rhi, compareFunction));
            lastState.compareFunction = compareFunction;
          }
          if (writeEnabled != lastState.writeEnabled) {
            gl.depthMask(writeEnabled);
            lastState.writeEnabled = writeEnabled;
          }
        }
      };
      return DepthState2;
    }();
    exports3.CullMode = void 0;
    (function(CullMode) {
      CullMode[CullMode["Off"] = 0] = "Off";
      CullMode[CullMode["Front"] = 1] = "Front";
      CullMode[CullMode["Back"] = 2] = "Back";
    })(exports3.CullMode || (exports3.CullMode = {}));
    var RasterState = /* @__PURE__ */ function() {
      function RasterState2() {
        this.cullMode = exports3.CullMode.Back;
        this.depthBias = 0;
        this.slopeScaledDepthBias = 0;
        this._cullFaceEnable = true;
        this._frontFaceInvert = false;
      }
      var _proto = RasterState2.prototype;
      _proto._apply = function _apply(hardwareRenderer, lastRenderState, frontFaceInvert) {
        this._platformApply(hardwareRenderer, lastRenderState.rasterState, frontFaceInvert);
      };
      _proto._platformApply = function _platformApply(rhi, lastState, frontFaceInvert) {
        var gl = rhi.gl;
        var cullMode = this.cullMode, depthBias = this.depthBias, slopeScaledDepthBias = this.slopeScaledDepthBias;
        var cullFaceEnable = cullMode !== exports3.CullMode.Off;
        if (cullFaceEnable !== lastState._cullFaceEnable) {
          if (cullFaceEnable) {
            gl.enable(gl.CULL_FACE);
          } else {
            gl.disable(gl.CULL_FACE);
          }
          lastState._cullFaceEnable = cullFaceEnable;
        }
        if (cullFaceEnable) {
          if (cullMode !== lastState.cullMode) {
            if (cullMode == exports3.CullMode.Back) {
              gl.cullFace(gl.BACK);
            } else {
              gl.cullFace(gl.FRONT);
            }
            lastState.cullMode = cullMode;
          }
        }
        if (frontFaceInvert !== lastState._frontFaceInvert) {
          if (frontFaceInvert) {
            gl.frontFace(gl.CW);
          } else {
            gl.frontFace(gl.CCW);
          }
          lastState._frontFaceInvert = frontFaceInvert;
        }
        if (depthBias !== lastState.depthBias || slopeScaledDepthBias !== lastState.slopeScaledDepthBias) {
          if (depthBias !== 0 || slopeScaledDepthBias !== 0) {
            gl.enable(gl.POLYGON_OFFSET_FILL);
            gl.polygonOffset(slopeScaledDepthBias, depthBias);
          } else {
            gl.disable(gl.POLYGON_OFFSET_FILL);
          }
          lastState.depthBias = depthBias;
          lastState.slopeScaledDepthBias = slopeScaledDepthBias;
        }
      };
      return RasterState2;
    }();
    exports3.StencilOperation = void 0;
    (function(StencilOperation) {
      StencilOperation[StencilOperation["Keep"] = 0] = "Keep";
      StencilOperation[StencilOperation["Zero"] = 1] = "Zero";
      StencilOperation[StencilOperation["Replace"] = 2] = "Replace";
      StencilOperation[StencilOperation["IncrementSaturate"] = 3] = "IncrementSaturate";
      StencilOperation[StencilOperation["DecrementSaturate"] = 4] = "DecrementSaturate";
      StencilOperation[StencilOperation["Invert"] = 5] = "Invert";
      StencilOperation[StencilOperation["IncrementWrap"] = 6] = "IncrementWrap";
      StencilOperation[StencilOperation["DecrementWrap"] = 7] = "DecrementWrap";
    })(exports3.StencilOperation || (exports3.StencilOperation = {}));
    var StencilState = /* @__PURE__ */ function() {
      function StencilState2() {
        this.enabled = false;
        this.referenceValue = 0;
        this.mask = 255;
        this.writeMask = 255;
        this.compareFunctionFront = exports3.CompareFunction.Always;
        this.compareFunctionBack = exports3.CompareFunction.Always;
        this.passOperationFront = exports3.StencilOperation.Keep;
        this.passOperationBack = exports3.StencilOperation.Keep;
        this.failOperationFront = exports3.StencilOperation.Keep;
        this.failOperationBack = exports3.StencilOperation.Keep;
        this.zFailOperationFront = exports3.StencilOperation.Keep;
        this.zFailOperationBack = exports3.StencilOperation.Keep;
      }
      StencilState2._getGLCompareFunction = function _getGLCompareFunction(rhi, compareFunction) {
        var gl = rhi.gl;
        switch (compareFunction) {
          case exports3.CompareFunction.Never:
            return gl.NEVER;
          case exports3.CompareFunction.Less:
            return gl.LESS;
          case exports3.CompareFunction.Equal:
            return gl.EQUAL;
          case exports3.CompareFunction.LessEqual:
            return gl.LEQUAL;
          case exports3.CompareFunction.Greater:
            return gl.GREATER;
          case exports3.CompareFunction.NotEqual:
            return gl.NOTEQUAL;
          case exports3.CompareFunction.GreaterEqual:
            return gl.GEQUAL;
          case exports3.CompareFunction.Always:
            return gl.ALWAYS;
        }
      };
      StencilState2._getGLStencilOperation = function _getGLStencilOperation(rhi, compareFunction) {
        var gl = rhi.gl;
        switch (compareFunction) {
          case exports3.StencilOperation.Keep:
            return gl.KEEP;
          case exports3.StencilOperation.Zero:
            return gl.ZERO;
          case exports3.StencilOperation.Replace:
            return gl.REPLACE;
          case exports3.StencilOperation.IncrementSaturate:
            return gl.INCR;
          case exports3.StencilOperation.DecrementSaturate:
            return gl.DECR;
          case exports3.StencilOperation.Invert:
            return gl.INVERT;
          case exports3.StencilOperation.IncrementWrap:
            return gl.INCR_WRAP;
          case exports3.StencilOperation.DecrementWrap:
            return gl.DECR_WRAP;
        }
      };
      var _proto = StencilState2.prototype;
      _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
        this._platformApply(hardwareRenderer, lastRenderState.stencilState);
      };
      _proto._platformApply = function _platformApply(rhi, lastState) {
        var gl = rhi.gl;
        var enabled = this.enabled, referenceValue = this.referenceValue, mask = this.mask, compareFunctionFront = this.compareFunctionFront, compareFunctionBack = this.compareFunctionBack, failOperationFront = this.failOperationFront, zFailOperationFront = this.zFailOperationFront, passOperationFront = this.passOperationFront, failOperationBack = this.failOperationBack, zFailOperationBack = this.zFailOperationBack, passOperationBack = this.passOperationBack, writeMask = this.writeMask;
        if (enabled != lastState.enabled) {
          if (enabled) {
            gl.enable(gl.STENCIL_TEST);
          } else {
            gl.disable(gl.STENCIL_TEST);
          }
          lastState.enabled = enabled;
        }
        if (enabled) {
          var referenceOrMaskChange = referenceValue !== lastState.referenceValue || mask !== lastState.mask;
          if (referenceOrMaskChange || compareFunctionFront !== lastState.compareFunctionFront) {
            gl.stencilFuncSeparate(gl.FRONT, StencilState2._getGLCompareFunction(rhi, compareFunctionFront), referenceValue, mask);
            lastState.compareFunctionFront = compareFunctionFront;
          }
          if (referenceOrMaskChange || compareFunctionBack !== lastState.compareFunctionBack) {
            gl.stencilFuncSeparate(gl.BACK, StencilState2._getGLCompareFunction(rhi, compareFunctionBack), referenceValue, mask);
            lastState.compareFunctionBack = this.compareFunctionBack;
          }
          if (referenceOrMaskChange) {
            lastState.referenceValue = this.referenceValue;
            lastState.mask = this.mask;
          }
          if (failOperationFront !== lastState.failOperationFront || zFailOperationFront !== lastState.zFailOperationFront || passOperationFront !== lastState.passOperationFront) {
            gl.stencilOpSeparate(gl.FRONT, StencilState2._getGLStencilOperation(rhi, failOperationFront), StencilState2._getGLStencilOperation(rhi, zFailOperationFront), StencilState2._getGLStencilOperation(rhi, passOperationFront));
            lastState.failOperationFront = failOperationFront;
            lastState.zFailOperationFront = zFailOperationFront;
            lastState.passOperationFront = passOperationFront;
          }
          if (failOperationBack !== lastState.failOperationBack || zFailOperationBack !== lastState.zFailOperationBack || passOperationBack !== lastState.passOperationBack) {
            gl.stencilOpSeparate(gl.BACK, StencilState2._getGLStencilOperation(rhi, failOperationBack), StencilState2._getGLStencilOperation(rhi, zFailOperationBack), StencilState2._getGLStencilOperation(rhi, passOperationBack));
            lastState.failOperationBack = failOperationBack;
            lastState.zFailOperationBack = zFailOperationBack;
            lastState.passOperationBack = passOperationBack;
          }
          if (writeMask !== lastState.writeMask) {
            gl.stencilMask(writeMask);
            lastState.writeMask = writeMask;
          }
        }
      };
      return StencilState2;
    }();
    var RenderState = /* @__PURE__ */ function() {
      function RenderState2() {
        this.blendState = new BlendState();
        this.depthState = new DepthState();
        this.stencilState = new StencilState();
        this.rasterState = new RasterState();
      }
      var _proto = RenderState2.prototype;
      _proto._apply = function _apply(engine, frontFaceInvert) {
        var hardwareRenderer = engine._hardwareRenderer;
        var lastRenderState = engine._lastRenderState;
        this.blendState._apply(hardwareRenderer, lastRenderState);
        this.depthState._apply(hardwareRenderer, lastRenderState);
        this.stencilState._apply(hardwareRenderer, lastRenderState);
        this.rasterState._apply(hardwareRenderer, lastRenderState, frontFaceInvert);
      };
      return RenderState2;
    }();
    var Material = /* @__PURE__ */ function(_RefObject) {
      _inheritsLoose2(Material2, _RefObject);
      function Material2(engine, shader) {
        var _this;
        _this = _RefObject.call(this, engine) || this;
        _this.name = void 0;
        _this.shader = void 0;
        _this.renderQueueType = exports3.RenderQueueType.Opaque;
        _this.shaderData = new ShaderData(ShaderDataGroup.Material);
        _this.renderState = new RenderState();
        _this.shader = shader;
        return _this;
      }
      var _proto = Material2.prototype;
      _proto.clone = function clone() {
        var dest = new Material2(this._engine, this.shader);
        this.cloneTo(dest);
        return dest;
      };
      _proto.cloneTo = function cloneTo(target) {
        target.shader = this.shader;
        target.renderQueueType = this.renderQueueType;
        this.shaderData.cloneTo(target.shaderData);
        CloneManager.deepCloneObject(this.renderState, target.renderState);
      };
      _proto._addRefCount = function _addRefCount(value) {
        _RefObject.prototype._addRefCount.call(this, value);
        this.shaderData._addRefCount(value);
      };
      _proto._preRender = function _preRender(renderElement) {
      };
      _proto._onDestroy = function _onDestroy() {
      };
      return Material2;
    }(RefObject);
    var ClassPool = /* @__PURE__ */ function() {
      function ClassPool2(type) {
        this._elementPoolIndex = 0;
        this._elementPool = [];
        this._type = void 0;
        this._type = type;
      }
      var _proto = ClassPool2.prototype;
      _proto.getFromPool = function getFromPool() {
        var index = this._elementPoolIndex, pool = this._elementPool;
        this._elementPoolIndex++;
        if (pool.length === index) {
          var element = new this._type();
          pool.push(element);
          return element;
        } else {
          return pool[index];
        }
      };
      _proto.resetPool = function resetPool() {
        this._elementPoolIndex = 0;
      };
      return ClassPool2;
    }();
    var RenderElement = function RenderElement2() {
      this.component = void 0;
      this.material = void 0;
      this.multiRenderData = void 0;
    };
    var MeshRenderElement = /* @__PURE__ */ function(_RenderElement) {
      _inheritsLoose2(MeshRenderElement2, _RenderElement);
      function MeshRenderElement2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _RenderElement.call.apply(_RenderElement, [this].concat(args)) || this;
        _this.mesh = void 0;
        _this.subMesh = void 0;
        return _this;
      }
      var _proto = MeshRenderElement2.prototype;
      _proto.setValue = function setValue(component, mesh, subMesh, material) {
        this.component = component;
        this.mesh = mesh;
        this.subMesh = subMesh;
        this.material = material;
      };
      return MeshRenderElement2;
    }(RenderElement);
    var RenderContext = /* @__PURE__ */ function() {
      function RenderContext2() {
        this._camera = void 0;
        this._viewProjectMatrix = new miniprogram2.Matrix();
      }
      var _proto = RenderContext2.prototype;
      _proto._setContext = function _setContext(camera) {
        this._camera = camera;
        miniprogram2.Matrix.multiply(camera.projectionMatrix, camera.viewMatrix, this._viewProjectMatrix);
      };
      return RenderContext2;
    }();
    var SpriteElement = /* @__PURE__ */ function(_RenderElement) {
      _inheritsLoose2(SpriteElement2, _RenderElement);
      function SpriteElement2() {
        var _this;
        _this = _RenderElement.call(this) || this;
        _this.renderData = void 0;
        _this.texture = void 0;
        _this.multiRenderData = false;
        return _this;
      }
      var _proto = SpriteElement2.prototype;
      _proto.setValue = function setValue(component, renderDate, material, texture) {
        this.component = component;
        this.renderData = renderDate;
        this.material = material;
        this.texture = texture;
      };
      return SpriteElement2;
    }(RenderElement);
    var SpriteMaskElement = /* @__PURE__ */ function(_RenderElement) {
      _inheritsLoose2(SpriteMaskElement2, _RenderElement);
      function SpriteMaskElement2() {
        var _this;
        _this = _RenderElement.call(this) || this;
        _this.renderData = void 0;
        _this.isAdd = true;
        _this.multiRenderData = false;
        return _this;
      }
      var _proto = SpriteMaskElement2.prototype;
      _proto.setValue = function setValue(component, renderData, material) {
        this.component = component;
        this.renderData = renderData;
        this.material = material;
      };
      return SpriteMaskElement2;
    }(RenderElement);
    exports3.SpriteMaskInteraction = void 0;
    (function(SpriteMaskInteraction) {
      SpriteMaskInteraction[SpriteMaskInteraction["None"] = 0] = "None";
      SpriteMaskInteraction[SpriteMaskInteraction["VisibleInsideMask"] = 1] = "VisibleInsideMask";
      SpriteMaskInteraction[SpriteMaskInteraction["VisibleOutsideMask"] = 2] = "VisibleOutsideMask";
    })(exports3.SpriteMaskInteraction || (exports3.SpriteMaskInteraction = {}));
    var _dec$32, _class$a2, _class2$9, _descriptor$8, _descriptor2$8, _descriptor3$7, _descriptor4$7, _descriptor5$7, _descriptor6$7, _descriptor7$7, _descriptor8$7, _descriptor9$6, _descriptor10$3, _descriptor11$3, _descriptor12$3, _descriptor13$2, _descriptor14$1, _descriptor15$1, _descriptor16$1, _class3$1;
    var Renderer = (_dec$32 = dependentComponents(Transform), _dec$32(_class$a2 = (_class2$9 = (_class3$1 = /* @__PURE__ */ function(_Component) {
      _inheritsLoose2(Renderer2, _Component);
      function Renderer2(entity) {
        var _this;
        _this = _Component.call(this, entity) || this;
        _initializerDefineProperty(_this, "shaderData", _descriptor$8, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "isCulled", _descriptor2$8, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_distanceForSort", _descriptor3$7, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_onUpdateIndex", _descriptor4$7, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_rendererIndex", _descriptor5$7, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_globalShaderMacro", _descriptor6$7, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_transformChangeFlag", _descriptor7$7, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_bounds", _descriptor8$7, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_overrideUpdate", _descriptor9$6, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_materials", _descriptor10$3, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_mvMatrix", _descriptor11$3, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_mvpMatrix", _descriptor12$3, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_mvInvMatrix", _descriptor13$2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_normalMatrix", _descriptor14$1, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_materialsInstanced", _descriptor15$1, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_priority", _descriptor16$1, _assertThisInitialized(_this));
        var prototype = Renderer2.prototype;
        _this._overrideUpdate = _this.update !== prototype.update;
        _this._transformChangeFlag = _this.entity.transform.registerWorldChangeFlag();
        _this.shaderData._addRefCount(1);
        return _this;
      }
      var _proto = Renderer2.prototype;
      _proto.getInstanceMaterial = function getInstanceMaterial(index) {
        if (index === void 0) {
          index = 0;
        }
        var materials = this._materials;
        if (materials.length > index) {
          var _material = materials[index];
          if (_material) {
            if (this._materialsInstanced[index]) {
              return _material;
            } else {
              return this._createInstanceMaterial(_material, index);
            }
          }
        }
        return null;
      };
      _proto.getMaterial = function getMaterial(index) {
        if (index === void 0) {
          index = 0;
        }
        return this._materials[index] || null;
      };
      _proto.setMaterial = function setMaterial(indexOrMaterial, material) {
        if (material === void 0) {
          material = null;
        }
        if (typeof indexOrMaterial === "number") {
          this._setMaterial(indexOrMaterial, material);
        } else {
          this._setMaterial(0, indexOrMaterial);
        }
      };
      _proto.getInstanceMaterials = function getInstanceMaterials() {
        var materials = this._materials;
        var materialsInstance = this._materialsInstanced;
        for (var i = 0, n = materials.length; i < n; i++) {
          if (!materialsInstance[i]) {
            this._createInstanceMaterial(this._materials[i], i);
          }
        }
        return materials;
      };
      _proto.getMaterials = function getMaterials() {
        return this._materials;
      };
      _proto.setMaterials = function setMaterials(materials) {
        var count = materials.length;
        var internalMaterials = this._materials;
        var materialsInstanced = this._materialsInstanced;
        for (var i = count, n = internalMaterials.length; i < n; i++) {
          var internalMaterial = internalMaterials[i];
          internalMaterial && internalMaterial._addRefCount(-1);
        }
        internalMaterials.length !== count && (internalMaterials.length = count);
        materialsInstanced.length !== 0 && (materialsInstanced.length = 0);
        for (var _i = 0; _i < count; _i++) {
          var _internalMaterial = internalMaterials[_i];
          var _material2 = materials[_i];
          if (_internalMaterial !== _material2) {
            internalMaterials[_i] = _material2;
            _internalMaterial && _internalMaterial._addRefCount(-1);
            _material2 && _material2._addRefCount(1);
          }
        }
      };
      _proto.update = function update(deltaTime) {
      };
      _proto._updateShaderData = function _updateShaderData(context) {
        var shaderData = this.shaderData;
        var worldMatrix = this.entity.transform.worldMatrix;
        var mvMatrix = this._mvMatrix;
        var mvpMatrix = this._mvpMatrix;
        var mvInvMatrix = this._mvInvMatrix;
        var normalMatrix = this._normalMatrix;
        miniprogram2.Matrix.multiply(context._camera.viewMatrix, worldMatrix, mvMatrix);
        miniprogram2.Matrix.multiply(context._viewProjectMatrix, worldMatrix, mvpMatrix);
        miniprogram2.Matrix.invert(mvMatrix, mvInvMatrix);
        miniprogram2.Matrix.invert(worldMatrix, normalMatrix);
        normalMatrix.transpose();
        shaderData.setMatrix(Renderer2._localMatrixProperty, this.entity.transform.localMatrix);
        shaderData.setMatrix(Renderer2._worldMatrixProperty, worldMatrix);
        shaderData.setMatrix(Renderer2._mvMatrixProperty, mvMatrix);
        shaderData.setMatrix(Renderer2._mvpMatrixProperty, mvpMatrix);
        shaderData.setMatrix(Renderer2._mvInvMatrixProperty, mvInvMatrix);
        shaderData.setMatrix(Renderer2._normalMatrixProperty, normalMatrix);
      };
      _proto._onEnable = function _onEnable() {
        var componentsManager = this.engine._componentsManager;
        if (this._overrideUpdate) {
          componentsManager.addOnUpdateRenderers(this);
        }
        componentsManager.addRenderer(this);
      };
      _proto._onDisable = function _onDisable() {
        var componentsManager = this.engine._componentsManager;
        if (this._overrideUpdate) {
          componentsManager.removeOnUpdateRenderers(this);
        }
        componentsManager.removeRenderer(this);
      };
      _proto._render = function _render(camera) {
        throw "not implement";
      };
      _proto._onDestroy = function _onDestroy() {
        var flag = this._transformChangeFlag;
        if (flag) {
          flag.destroy();
          this._transformChangeFlag = null;
        }
        this.shaderData._addRefCount(-1);
        var materials = this._materials;
        for (var i = 0, n = materials.length; i < n; i++) {
          var _materials$i;
          (_materials$i = materials[i]) === null || _materials$i === void 0 ? void 0 : _materials$i._addRefCount(-1);
        }
      };
      _proto._updateBounds = function _updateBounds(worldBounds) {
      };
      _proto._createInstanceMaterial = function _createInstanceMaterial(material, index) {
        var insMaterial = material.clone();
        insMaterial.name = insMaterial.name + "(Instance)";
        material._addRefCount(-1);
        insMaterial._addRefCount(1);
        this._materialsInstanced[index] = true;
        this._materials[index] = insMaterial;
        return insMaterial;
      };
      _proto._setMaterial = function _setMaterial(index, material) {
        var materials = this._materials;
        if (index >= materials.length) {
          materials.length = index + 1;
        }
        var internalMaterial = materials[index];
        if (internalMaterial !== material) {
          var materialsInstance = this._materialsInstanced;
          index < materialsInstance.length && (materialsInstance[index] = false);
          internalMaterial && internalMaterial._addRefCount(-1);
          material && material._addRefCount(1);
          materials[index] = material;
        }
      };
      _createClass2(Renderer2, [{
        key: "materialCount",
        get: function get() {
          return this._materials.length;
        },
        set: function set(value) {
          var materials = this._materials;
          var materialsInstanced = this._materialsInstanced;
          materials.length !== value && (materials.length = value);
          materialsInstanced.length > value && (materialsInstanced.length = value);
        }
      }, {
        key: "bounds",
        get: function get() {
          var changeFlag = this._transformChangeFlag;
          if (changeFlag.flag) {
            this._updateBounds(this._bounds);
            changeFlag.flag = false;
          }
          return this._bounds;
        }
      }, {
        key: "priority",
        get: function get() {
          return this._priority;
        },
        set: function set(value) {
          this._priority = value;
        }
      }]);
      return Renderer2;
    }(Component), _class3$1._localMatrixProperty = Shader.getPropertyByName("u_localMat"), _class3$1._worldMatrixProperty = Shader.getPropertyByName("u_modelMat"), _class3$1._mvMatrixProperty = Shader.getPropertyByName("u_MVMat"), _class3$1._mvpMatrixProperty = Shader.getPropertyByName("u_MVPMat"), _class3$1._mvInvMatrixProperty = Shader.getPropertyByName("u_MVInvMat"), _class3$1._normalMatrixProperty = Shader.getPropertyByName("u_normalMat"), _class3$1), _descriptor$8 = _applyDecoratedDescriptor(_class2$9.prototype, "shaderData", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new ShaderData(ShaderDataGroup.Renderer);
      }
    }), _descriptor2$8 = _applyDecoratedDescriptor(_class2$9.prototype, "isCulled", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor3$7 = _applyDecoratedDescriptor(_class2$9.prototype, "_distanceForSort", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor4$7 = _applyDecoratedDescriptor(_class2$9.prototype, "_onUpdateIndex", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return -1;
      }
    }), _descriptor5$7 = _applyDecoratedDescriptor(_class2$9.prototype, "_rendererIndex", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return -1;
      }
    }), _descriptor6$7 = _applyDecoratedDescriptor(_class2$9.prototype, "_globalShaderMacro", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new ShaderMacroCollection();
      }
    }), _descriptor7$7 = _applyDecoratedDescriptor(_class2$9.prototype, "_transformChangeFlag", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor8$7 = _applyDecoratedDescriptor(_class2$9.prototype, "_bounds", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.BoundingBox();
      }
    }), _descriptor9$6 = _applyDecoratedDescriptor(_class2$9.prototype, "_overrideUpdate", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor10$3 = _applyDecoratedDescriptor(_class2$9.prototype, "_materials", [shallowClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return [];
      }
    }), _descriptor11$3 = _applyDecoratedDescriptor(_class2$9.prototype, "_mvMatrix", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Matrix();
      }
    }), _descriptor12$3 = _applyDecoratedDescriptor(_class2$9.prototype, "_mvpMatrix", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Matrix();
      }
    }), _descriptor13$2 = _applyDecoratedDescriptor(_class2$9.prototype, "_mvInvMatrix", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Matrix();
      }
    }), _descriptor14$1 = _applyDecoratedDescriptor(_class2$9.prototype, "_normalMatrix", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Matrix();
      }
    }), _descriptor15$1 = _applyDecoratedDescriptor(_class2$9.prototype, "_materialsInstanced", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return [];
      }
    }), _descriptor16$1 = _applyDecoratedDescriptor(_class2$9.prototype, "_priority", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _class2$9)) || _class$a2);
    function StaticInterfaceImplement2() {
      return function(constructor) {
      };
    }
    var _dec$22, _class$92, _class2$8;
    var SimpleSpriteAssembler = (_dec$22 = StaticInterfaceImplement2(), _dec$22(_class$92 = (_class2$8 = /* @__PURE__ */ function() {
      function SimpleSpriteAssembler2() {
      }
      SimpleSpriteAssembler2.resetData = function resetData(renderer) {
        var renderData = renderer._renderData;
        var vertexCount = renderData.vertexCount = 4;
        var positions = renderData.positions, uvs = renderData.uvs;
        if (positions.length < vertexCount) {
          for (var i = positions.length; i < vertexCount; i++) {
            positions.push(new miniprogram2.Vector3());
            uvs.push(new miniprogram2.Vector2());
          }
        }
        renderData.triangles = SimpleSpriteAssembler2._rectangleTriangles;
      };
      SimpleSpriteAssembler2.updatePositions = function updatePositions(renderer) {
        var width = renderer.width, height = renderer.height, sprite = renderer.sprite;
        var _sprite$pivot = sprite.pivot, pivotX = _sprite$pivot.x, pivotY = _sprite$pivot.y;
        var worldMatrix = SimpleSpriteAssembler2._worldMatrix;
        var wE = worldMatrix.elements;
        var pWE = renderer.entity.transform.worldMatrix.elements;
        var sx = renderer.flipX ? -width : width;
        var sy = renderer.flipY ? -height : height;
        wE[0] = pWE[0] * sx, wE[1] = pWE[1] * sx, wE[2] = pWE[2] * sx;
        wE[4] = pWE[4] * sy, wE[5] = pWE[5] * sy, wE[6] = pWE[6] * sy;
        wE[8] = pWE[8], wE[9] = pWE[9], wE[10] = pWE[10];
        wE[12] = pWE[12] - pivotX * wE[0] - pivotY * wE[4];
        wE[13] = pWE[13] - pivotX * wE[1] - pivotY * wE[5];
        wE[14] = pWE[14] - pivotX * wE[2] - pivotY * wE[6];
        var spritePositions = sprite._getPositions();
        var positions = renderer._renderData.positions;
        for (var i = 0; i < 4; i++) {
          var _spritePositions$i = spritePositions[i], x = _spritePositions$i.x, y = _spritePositions$i.y;
          positions[i].set(wE[0] * x + wE[4] * y + wE[12], wE[1] * x + wE[5] * y + wE[13], wE[2] * x + wE[6] * y + wE[14]);
        }
        miniprogram2.BoundingBox.transform(sprite._getBounds(), worldMatrix, renderer._bounds);
      };
      SimpleSpriteAssembler2.updateUVs = function updateUVs(renderer) {
        var spriteUVs = renderer.sprite._getUVs();
        var renderUVs = renderer._renderData.uvs;
        var _spriteUVs$ = spriteUVs[0], left = _spriteUVs$.x, bottom = _spriteUVs$.y;
        var _spriteUVs$2 = spriteUVs[3], right = _spriteUVs$2.x, top = _spriteUVs$2.y;
        renderUVs[0].set(left, bottom);
        renderUVs[1].set(right, bottom);
        renderUVs[2].set(left, top);
        renderUVs[3].set(right, top);
      };
      return SimpleSpriteAssembler2;
    }(), _class2$8._rectangleTriangles = [0, 1, 2, 2, 1, 3], _class2$8._worldMatrix = new miniprogram2.Matrix(), _class2$8)) || _class$92);
    var RenderData2D = function RenderData2D2(vertexCount, positions, uvs, triangles, color) {
      if (triangles === void 0) {
        triangles = null;
      }
      if (color === void 0) {
        color = null;
      }
      this.vertexCount = vertexCount;
      this.positions = positions;
      this.uvs = uvs;
      this.triangles = triangles;
      this.color = color;
    };
    var SpritePropertyDirtyFlag;
    (function(SpritePropertyDirtyFlag2) {
      SpritePropertyDirtyFlag2[SpritePropertyDirtyFlag2["texture"] = 1] = "texture";
      SpritePropertyDirtyFlag2[SpritePropertyDirtyFlag2["size"] = 2] = "size";
      SpritePropertyDirtyFlag2[SpritePropertyDirtyFlag2["atlasRotate"] = 4] = "atlasRotate";
      SpritePropertyDirtyFlag2[SpritePropertyDirtyFlag2["atlasRegion"] = 8] = "atlasRegion";
      SpritePropertyDirtyFlag2[SpritePropertyDirtyFlag2["atlasRegionOffset"] = 16] = "atlasRegionOffset";
      SpritePropertyDirtyFlag2[SpritePropertyDirtyFlag2["region"] = 32] = "region";
      SpritePropertyDirtyFlag2[SpritePropertyDirtyFlag2["pivot"] = 64] = "pivot";
      SpritePropertyDirtyFlag2[SpritePropertyDirtyFlag2["border"] = 128] = "border";
    })(SpritePropertyDirtyFlag || (SpritePropertyDirtyFlag = {}));
    exports3.SpriteMaskLayer = void 0;
    (function(SpriteMaskLayer) {
      SpriteMaskLayer[SpriteMaskLayer["Layer0"] = 1] = "Layer0";
      SpriteMaskLayer[SpriteMaskLayer["Layer1"] = 2] = "Layer1";
      SpriteMaskLayer[SpriteMaskLayer["Layer2"] = 4] = "Layer2";
      SpriteMaskLayer[SpriteMaskLayer["Layer3"] = 8] = "Layer3";
      SpriteMaskLayer[SpriteMaskLayer["Layer4"] = 16] = "Layer4";
      SpriteMaskLayer[SpriteMaskLayer["Layer5"] = 32] = "Layer5";
      SpriteMaskLayer[SpriteMaskLayer["Layer6"] = 64] = "Layer6";
      SpriteMaskLayer[SpriteMaskLayer["Layer7"] = 128] = "Layer7";
      SpriteMaskLayer[SpriteMaskLayer["Layer8"] = 256] = "Layer8";
      SpriteMaskLayer[SpriteMaskLayer["Layer9"] = 512] = "Layer9";
      SpriteMaskLayer[SpriteMaskLayer["Layer10"] = 1024] = "Layer10";
      SpriteMaskLayer[SpriteMaskLayer["Layer11"] = 2048] = "Layer11";
      SpriteMaskLayer[SpriteMaskLayer["Layer12"] = 4096] = "Layer12";
      SpriteMaskLayer[SpriteMaskLayer["Layer13"] = 8192] = "Layer13";
      SpriteMaskLayer[SpriteMaskLayer["Layer14"] = 16384] = "Layer14";
      SpriteMaskLayer[SpriteMaskLayer["Layer15"] = 32768] = "Layer15";
      SpriteMaskLayer[SpriteMaskLayer["Layer16"] = 65536] = "Layer16";
      SpriteMaskLayer[SpriteMaskLayer["Layer17"] = 131072] = "Layer17";
      SpriteMaskLayer[SpriteMaskLayer["Layer18"] = 262144] = "Layer18";
      SpriteMaskLayer[SpriteMaskLayer["Layer19"] = 524288] = "Layer19";
      SpriteMaskLayer[SpriteMaskLayer["Layer20"] = 1048576] = "Layer20";
      SpriteMaskLayer[SpriteMaskLayer["Layer21"] = 2097152] = "Layer21";
      SpriteMaskLayer[SpriteMaskLayer["Layer22"] = 4194304] = "Layer22";
      SpriteMaskLayer[SpriteMaskLayer["Layer23"] = 8388608] = "Layer23";
      SpriteMaskLayer[SpriteMaskLayer["Layer24"] = 16777216] = "Layer24";
      SpriteMaskLayer[SpriteMaskLayer["Layer25"] = 33554432] = "Layer25";
      SpriteMaskLayer[SpriteMaskLayer["Layer26"] = 67108864] = "Layer26";
      SpriteMaskLayer[SpriteMaskLayer["Layer27"] = 134217728] = "Layer27";
      SpriteMaskLayer[SpriteMaskLayer["Layer28"] = 268435456] = "Layer28";
      SpriteMaskLayer[SpriteMaskLayer["Layer29"] = 536870912] = "Layer29";
      SpriteMaskLayer[SpriteMaskLayer["Layer30"] = 1073741824] = "Layer30";
      SpriteMaskLayer[SpriteMaskLayer["Layer31"] = 2147483648] = "Layer31";
      SpriteMaskLayer[SpriteMaskLayer["Everything"] = 4294967295] = "Everything";
    })(exports3.SpriteMaskLayer || (exports3.SpriteMaskLayer = {}));
    var _class$82, _descriptor$7, _descriptor2$7, _descriptor3$6, _descriptor4$6, _descriptor5$6, _descriptor6$6, _descriptor7$6, _descriptor8$6, _descriptor9$5, _class2$7;
    var SpriteMask = (_class$82 = (_class2$7 = /* @__PURE__ */ function(_Renderer) {
      _inheritsLoose2(SpriteMask2, _Renderer);
      function SpriteMask2(entity) {
        var _this;
        _this = _Renderer.call(this, entity) || this;
        _initializerDefineProperty(_this, "influenceLayers", _descriptor$7, _assertThisInitialized(_this));
        _this._maskElement = void 0;
        _this._renderData = void 0;
        _initializerDefineProperty(_this, "_sprite", _descriptor2$7, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_width", _descriptor3$6, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_height", _descriptor4$6, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_flipX", _descriptor5$6, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_flipY", _descriptor6$6, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_alphaCutoff", _descriptor7$6, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_dirtyFlag", _descriptor8$6, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_spriteChangeFlag", _descriptor9$5, _assertThisInitialized(_this));
        _this._renderData = new RenderData2D(4, [], []);
        SimpleSpriteAssembler.resetData(_assertThisInitialized(_this));
        _this.setMaterial(_this._engine._spriteMaskDefaultMaterial);
        _this.shaderData.setFloat(SpriteMask2._alphaCutoffProperty, _this._alphaCutoff);
        _this._onSpriteChange = _this._onSpriteChange.bind(_assertThisInitialized(_this));
        return _this;
      }
      var _proto = SpriteMask2.prototype;
      _proto._onDestroy = function _onDestroy() {
        this._sprite = null;
        this._renderData = null;
        if (this._spriteChangeFlag) {
          this._spriteChangeFlag.destroy();
          this._spriteChangeFlag = null;
        }
        _Renderer.prototype._onDestroy.call(this);
      };
      _proto._render = function _render(camera) {
        var _this$sprite;
        if (!((_this$sprite = this.sprite) !== null && _this$sprite !== void 0 && _this$sprite.texture) || !this.width || !this.height) {
          return;
        }
        if (this._transformChangeFlag.flag || this._dirtyFlag & DirtyFlag$3.Position) {
          SimpleSpriteAssembler.updatePositions(this);
          this._dirtyFlag &= ~DirtyFlag$3.Position;
          this._transformChangeFlag.flag = false;
        }
        if (this._dirtyFlag & DirtyFlag$3.UV) {
          SimpleSpriteAssembler.updateUVs(this);
          this._dirtyFlag &= ~DirtyFlag$3.UV;
        }
        var spriteMaskElementPool = this._engine._spriteMaskElementPool;
        var maskElement = spriteMaskElementPool.getFromPool();
        maskElement.setValue(this, this._renderData, this.getMaterial());
        camera._renderPipeline._allSpriteMasks.add(this);
        this._maskElement = maskElement;
      };
      _proto._cloneTo = function _cloneTo(target) {
        target.sprite = this._sprite;
      };
      _proto._onSpriteChange = function _onSpriteChange(dirtyFlag) {
        switch (dirtyFlag) {
          case SpritePropertyDirtyFlag.texture:
            this.shaderData.setTexture(SpriteMask2._textureProperty, this.sprite.texture);
            break;
          case SpritePropertyDirtyFlag.region:
          case SpritePropertyDirtyFlag.atlasRegionOffset:
            this._dirtyFlag |= DirtyFlag$3.All;
            break;
          case SpritePropertyDirtyFlag.atlasRegion:
            this._dirtyFlag |= DirtyFlag$3.UV;
            break;
        }
      };
      _createClass2(SpriteMask2, [{
        key: "width",
        get: function get() {
          if (this._width === void 0 && this._sprite) {
            this.width = this._sprite.width;
          }
          return this._width;
        },
        set: function set(value) {
          if (this._width !== value) {
            this._width = value;
            this._dirtyFlag |= DirtyFlag$3.Position;
          }
        }
      }, {
        key: "height",
        get: function get() {
          if (this._height === void 0 && this._sprite) {
            this.height = this._sprite.height;
          }
          return this._height;
        },
        set: function set(value) {
          if (this._height !== value) {
            this._height = value;
            this._dirtyFlag |= DirtyFlag$3.Position;
          }
        }
      }, {
        key: "flipX",
        get: function get() {
          return this._flipX;
        },
        set: function set(value) {
          if (this._flipX !== value) {
            this._flipX = value;
            this._dirtyFlag |= DirtyFlag$3.Position;
          }
        }
      }, {
        key: "flipY",
        get: function get() {
          return this._flipY;
        },
        set: function set(value) {
          if (this._flipY !== value) {
            this._flipY = value;
            this._dirtyFlag |= DirtyFlag$3.Position;
          }
        }
      }, {
        key: "sprite",
        get: function get() {
          return this._sprite;
        },
        set: function set(value) {
          if (this._sprite !== value) {
            this._sprite = value;
            this._spriteChangeFlag && this._spriteChangeFlag.destroy();
            if (value) {
              this._spriteChangeFlag = value._registerUpdateFlag();
              this._spriteChangeFlag.listener = this._onSpriteChange;
              this._dirtyFlag |= DirtyFlag$3.All;
              this.shaderData.setTexture(SpriteMask2._textureProperty, value.texture);
            } else {
              this._spriteChangeFlag = null;
              this.shaderData.setTexture(SpriteMask2._textureProperty, null);
            }
          }
        }
      }, {
        key: "alphaCutoff",
        get: function get() {
          return this._alphaCutoff;
        },
        set: function set(value) {
          if (this._alphaCutoff !== value) {
            this._alphaCutoff = value;
            this.shaderData.setFloat(SpriteMask2._alphaCutoffProperty, value);
          }
        }
      }, {
        key: "bounds",
        get: function get() {
          var _this$sprite2;
          if (!((_this$sprite2 = this.sprite) !== null && _this$sprite2 !== void 0 && _this$sprite2.texture) || !this.width || !this.height) {
            return Engine._defaultBoundingBox;
          } else if (this._transformChangeFlag.flag || this._dirtyFlag & DirtyFlag$3.Position) {
            SimpleSpriteAssembler.updatePositions(this);
            this._dirtyFlag &= ~DirtyFlag$3.Position;
            this._transformChangeFlag.flag = false;
          }
          return this._bounds;
        }
      }]);
      return SpriteMask2;
    }(Renderer), _class2$7._textureProperty = Shader.getPropertyByName("u_maskTexture"), _class2$7._alphaCutoffProperty = Shader.getPropertyByName("u_maskAlphaCutoff"), _class2$7), _descriptor$7 = _applyDecoratedDescriptor(_class$82.prototype, "influenceLayers", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return exports3.SpriteMaskLayer.Everything;
      }
    }), _descriptor2$7 = _applyDecoratedDescriptor(_class$82.prototype, "_sprite", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return null;
      }
    }), _descriptor3$6 = _applyDecoratedDescriptor(_class$82.prototype, "_width", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return void 0;
      }
    }), _descriptor4$6 = _applyDecoratedDescriptor(_class$82.prototype, "_height", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return void 0;
      }
    }), _descriptor5$6 = _applyDecoratedDescriptor(_class$82.prototype, "_flipX", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor6$6 = _applyDecoratedDescriptor(_class$82.prototype, "_flipY", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor7$6 = _applyDecoratedDescriptor(_class$82.prototype, "_alphaCutoff", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0.5;
      }
    }), _descriptor8$6 = _applyDecoratedDescriptor(_class$82.prototype, "_dirtyFlag", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _descriptor9$5 = _applyDecoratedDescriptor(_class$82.prototype, "_spriteChangeFlag", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return null;
      }
    }), _class$82);
    var DirtyFlag$3;
    (function(DirtyFlag2) {
      DirtyFlag2[DirtyFlag2["Position"] = 1] = "Position";
      DirtyFlag2[DirtyFlag2["UV"] = 2] = "UV";
      DirtyFlag2[DirtyFlag2["All"] = 3] = "All";
    })(DirtyFlag$3 || (DirtyFlag$3 = {}));
    exports3.VertexElementFormat = void 0;
    (function(VertexElementFormat) {
      VertexElementFormat[VertexElementFormat["Float"] = 0] = "Float";
      VertexElementFormat[VertexElementFormat["Vector2"] = 1] = "Vector2";
      VertexElementFormat[VertexElementFormat["Vector3"] = 2] = "Vector3";
      VertexElementFormat[VertexElementFormat["Vector4"] = 3] = "Vector4";
      VertexElementFormat[VertexElementFormat["Byte4"] = 4] = "Byte4";
      VertexElementFormat[VertexElementFormat["UByte4"] = 5] = "UByte4";
      VertexElementFormat[VertexElementFormat["NormalizedByte4"] = 6] = "NormalizedByte4";
      VertexElementFormat[VertexElementFormat["NormalizedUByte4"] = 7] = "NormalizedUByte4";
      VertexElementFormat[VertexElementFormat["Short2"] = 8] = "Short2";
      VertexElementFormat[VertexElementFormat["UShort2"] = 9] = "UShort2";
      VertexElementFormat[VertexElementFormat["NormalizedShort2"] = 10] = "NormalizedShort2";
      VertexElementFormat[VertexElementFormat["NormalizedUShort2"] = 11] = "NormalizedUShort2";
      VertexElementFormat[VertexElementFormat["Short4"] = 12] = "Short4";
      VertexElementFormat[VertexElementFormat["UShort4"] = 13] = "UShort4";
      VertexElementFormat[VertexElementFormat["NormalizedShort4"] = 14] = "NormalizedShort4";
      VertexElementFormat[VertexElementFormat["NormalizedUShort4"] = 15] = "NormalizedUShort4";
    })(exports3.VertexElementFormat || (exports3.VertexElementFormat = {}));
    exports3.BufferUsage = void 0;
    (function(BufferUsage) {
      BufferUsage[BufferUsage["Static"] = 0] = "Static";
      BufferUsage[BufferUsage["Dynamic"] = 1] = "Dynamic";
      BufferUsage[BufferUsage["Stream"] = 2] = "Stream";
    })(exports3.BufferUsage || (exports3.BufferUsage = {}));
    exports3.IndexFormat = void 0;
    (function(IndexFormat) {
      IndexFormat[IndexFormat["UInt8"] = 0] = "UInt8";
      IndexFormat[IndexFormat["UInt16"] = 1] = "UInt16";
      IndexFormat[IndexFormat["UInt32"] = 2] = "UInt32";
    })(exports3.IndexFormat || (exports3.IndexFormat = {}));
    var BufferUtil = /* @__PURE__ */ function() {
      function BufferUtil2() {
      }
      BufferUtil2._getGLBufferUsage = function _getGLBufferUsage(gl, bufferUsage) {
        switch (bufferUsage) {
          case exports3.BufferUsage.Static:
            return gl.STATIC_DRAW;
          case exports3.BufferUsage.Dynamic:
            return gl.DYNAMIC_DRAW;
          case exports3.BufferUsage.Stream:
            return gl.STREAM_DRAW;
        }
      };
      BufferUtil2._getGLIndexType = function _getGLIndexType(indexFormat) {
        switch (indexFormat) {
          case exports3.IndexFormat.UInt8:
            return exports3.DataType.UNSIGNED_BYTE;
          case exports3.IndexFormat.UInt16:
            return exports3.DataType.UNSIGNED_SHORT;
          case exports3.IndexFormat.UInt32:
            return exports3.DataType.UNSIGNED_INT;
        }
      };
      BufferUtil2._getGLIndexByteCount = function _getGLIndexByteCount(indexFormat) {
        switch (indexFormat) {
          case exports3.IndexFormat.UInt8:
            return 1;
          case exports3.IndexFormat.UInt16:
            return 2;
          case exports3.IndexFormat.UInt32:
            return 4;
        }
      };
      BufferUtil2._getElementInfo = function _getElementInfo(format) {
        var size;
        var type;
        var normalized = false;
        switch (format) {
          case exports3.VertexElementFormat.Float:
            size = 1;
            type = exports3.DataType.FLOAT;
            break;
          case exports3.VertexElementFormat.Vector2:
            size = 2;
            type = exports3.DataType.FLOAT;
            break;
          case exports3.VertexElementFormat.Vector3:
            size = 3;
            type = exports3.DataType.FLOAT;
            break;
          case exports3.VertexElementFormat.Vector4:
            size = 4;
            type = exports3.DataType.FLOAT;
            break;
          case exports3.VertexElementFormat.Byte4:
            size = 4;
            type = exports3.DataType.BYTE;
            break;
          case exports3.VertexElementFormat.UByte4:
            size = 4;
            type = exports3.DataType.UNSIGNED_BYTE;
            break;
          case exports3.VertexElementFormat.NormalizedByte4:
            size = 4;
            type = exports3.DataType.BYTE;
            normalized = true;
            break;
          case exports3.VertexElementFormat.NormalizedUByte4:
            size = 4;
            type = exports3.DataType.UNSIGNED_BYTE;
            normalized = true;
            break;
          case exports3.VertexElementFormat.Short2:
            size = 2;
            type = exports3.DataType.SHORT;
            break;
          case exports3.VertexElementFormat.UShort2:
            size = 2;
            type = exports3.DataType.UNSIGNED_SHORT;
            break;
          case exports3.VertexElementFormat.NormalizedShort2:
            size = 2;
            type = exports3.DataType.SHORT;
            normalized = true;
            break;
          case exports3.VertexElementFormat.NormalizedUShort2:
            size = 2;
            type = exports3.DataType.UNSIGNED_SHORT;
            normalized = true;
            break;
          case exports3.VertexElementFormat.Short4:
            size = 4;
            type = exports3.DataType.SHORT;
            break;
          case exports3.VertexElementFormat.UShort4:
            size = 4;
            type = exports3.DataType.UNSIGNED_SHORT;
            break;
          case exports3.VertexElementFormat.NormalizedShort4:
            size = 4;
            type = exports3.DataType.SHORT;
            normalized = true;
            break;
          case exports3.VertexElementFormat.NormalizedUShort4:
            size = 4;
            type = exports3.DataType.UNSIGNED_SHORT;
            normalized = true;
            break;
        }
        return {
          size,
          type,
          normalized
        };
      };
      return BufferUtil2;
    }();
    var VertexElement = /* @__PURE__ */ function() {
      function VertexElement2(semantic, offset, format, bindingIndex, instanceStepRate) {
        if (instanceStepRate === void 0) {
          instanceStepRate = 0;
        }
        this._glElementInfo = void 0;
        this._semantic = void 0;
        this._offset = void 0;
        this._format = void 0;
        this._bindingIndex = void 0;
        this._instanceStepRate = void 0;
        this._semantic = semantic;
        this._offset = offset;
        this._format = format;
        this._bindingIndex = bindingIndex;
        this._glElementInfo = BufferUtil._getElementInfo(this.format);
        this._instanceStepRate = Math.floor(instanceStepRate);
      }
      _createClass2(VertexElement2, [{
        key: "semantic",
        get: function get() {
          return this._semantic;
        }
      }, {
        key: "offset",
        get: function get() {
          return this._offset;
        },
        set: function set(value) {
          this._offset = value;
        }
      }, {
        key: "format",
        get: function get() {
          return this._format;
        }
      }, {
        key: "bindingIndex",
        get: function get() {
          return this._bindingIndex;
        },
        set: function set(value) {
          this._bindingIndex = value;
        }
      }, {
        key: "instanceStepRate",
        get: function get() {
          return this._instanceStepRate;
        }
      }]);
      return VertexElement2;
    }();
    exports3.BufferBindFlag = void 0;
    (function(BufferBindFlag) {
      BufferBindFlag[BufferBindFlag["VertexBuffer"] = 0] = "VertexBuffer";
      BufferBindFlag[BufferBindFlag["IndexBuffer"] = 1] = "IndexBuffer";
    })(exports3.BufferBindFlag || (exports3.BufferBindFlag = {}));
    exports3.SetDataOptions = void 0;
    (function(SetDataOptions) {
      SetDataOptions[SetDataOptions["None"] = 0] = "None";
      SetDataOptions[SetDataOptions["Discard"] = 1] = "Discard";
    })(exports3.SetDataOptions || (exports3.SetDataOptions = {}));
    var Buffer2 = /* @__PURE__ */ function(_RefObject) {
      _inheritsLoose2(Buffer3, _RefObject);
      function Buffer3(engine, type, byteLengthOrData, bufferUsage) {
        var _this;
        if (bufferUsage === void 0) {
          bufferUsage = exports3.BufferUsage.Static;
        }
        _this = _RefObject.call(this, engine) || this;
        _this._glBindTarget = void 0;
        _this._glBufferUsage = void 0;
        _this._nativeBuffer = void 0;
        _this._hardwareRenderer = void 0;
        _this._type = void 0;
        _this._byteLength = void 0;
        _this._bufferUsage = void 0;
        _this._engine = engine;
        _this._type = type;
        _this._bufferUsage = bufferUsage;
        var hardwareRenderer = engine._hardwareRenderer;
        var gl = hardwareRenderer.gl;
        var glBufferUsage = BufferUtil._getGLBufferUsage(gl, bufferUsage);
        var glBindTarget = type === exports3.BufferBindFlag.VertexBuffer ? gl.ARRAY_BUFFER : gl.ELEMENT_ARRAY_BUFFER;
        _this._nativeBuffer = gl.createBuffer();
        _this._hardwareRenderer = hardwareRenderer;
        _this._glBufferUsage = glBufferUsage;
        _this._glBindTarget = glBindTarget;
        _this.bind();
        if (typeof byteLengthOrData === "number") {
          _this._byteLength = byteLengthOrData;
          gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
        } else {
          _this._byteLength = byteLengthOrData.byteLength;
          gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
        }
        gl.bindBuffer(glBindTarget, null);
        return _this;
      }
      var _proto = Buffer3.prototype;
      _proto.bind = function bind() {
        var gl = this._hardwareRenderer.gl;
        gl.bindBuffer(this._glBindTarget, this._nativeBuffer);
      };
      _proto.setData = function setData(data, bufferByteOffset, dataOffset, dataLength, options) {
        if (bufferByteOffset === void 0) {
          bufferByteOffset = 0;
        }
        if (dataOffset === void 0) {
          dataOffset = 0;
        }
        if (options === void 0) {
          options = exports3.SetDataOptions.None;
        }
        var gl = this._hardwareRenderer.gl;
        var isWebGL2 = this._hardwareRenderer.isWebGL2;
        var glBindTarget = this._glBindTarget;
        this.bind();
        if (options === exports3.SetDataOptions.Discard) {
          gl.bufferData(glBindTarget, this._byteLength, this._glBufferUsage);
        }
        var byteSize = data.BYTES_PER_ELEMENT || 1;
        var dataByteLength = dataLength ? byteSize * dataLength : data.byteLength;
        if (dataOffset !== 0 || dataByteLength < data.byteLength) {
          var isArrayBufferView = data.byteOffset !== void 0;
          if (isWebGL2 && isArrayBufferView) {
            gl.bufferSubData(glBindTarget, bufferByteOffset, data, dataOffset, dataByteLength / byteSize);
          } else {
            var subData = new Uint8Array(isArrayBufferView ? data.buffer : data, dataOffset * byteSize, dataByteLength);
            gl.bufferSubData(glBindTarget, bufferByteOffset, subData);
          }
        } else {
          gl.bufferSubData(glBindTarget, bufferByteOffset, data);
        }
        gl.bindBuffer(glBindTarget, null);
      };
      _proto.getData = function getData(data, bufferByteOffset, dataOffset, dataLength) {
        if (bufferByteOffset === void 0) {
          bufferByteOffset = 0;
        }
        if (dataOffset === void 0) {
          dataOffset = 0;
        }
        var isWebGL2 = this._hardwareRenderer.isWebGL2;
        if (isWebGL2) {
          var gl = this._hardwareRenderer.gl;
          this.bind();
          gl.getBufferSubData(this._glBindTarget, bufferByteOffset, data, dataOffset, dataLength);
        } else {
          throw "Buffer is write-only on WebGL1.0 platforms.";
        }
      };
      _proto._onDestroy = function _onDestroy() {
        var gl = this._hardwareRenderer.gl;
        gl.deleteBuffer(this._nativeBuffer);
        this._nativeBuffer = null;
        this._hardwareRenderer = null;
      };
      _proto.resize = function resize(dataLength) {
        this.bind();
        var gl = this._hardwareRenderer.gl;
        gl.bufferData(this._glBindTarget, dataLength, this._glBufferUsage);
        this._byteLength = dataLength;
      };
      _createClass2(Buffer3, [{
        key: "type",
        get: function get() {
          return this._type;
        }
      }, {
        key: "byteLength",
        get: function get() {
          return this._byteLength;
        }
      }, {
        key: "bufferUsage",
        get: function get() {
          return this._bufferUsage;
        }
      }]);
      return Buffer3;
    }(RefObject);
    exports3.MeshTopology = void 0;
    (function(MeshTopology) {
      MeshTopology[MeshTopology["Points"] = 0] = "Points";
      MeshTopology[MeshTopology["Lines"] = 1] = "Lines";
      MeshTopology[MeshTopology["LineLoop"] = 2] = "LineLoop";
      MeshTopology[MeshTopology["LineStrip"] = 3] = "LineStrip";
      MeshTopology[MeshTopology["Triangles"] = 4] = "Triangles";
      MeshTopology[MeshTopology["TriangleStrip"] = 5] = "TriangleStrip";
      MeshTopology[MeshTopology["TriangleFan"] = 6] = "TriangleFan";
    })(exports3.MeshTopology || (exports3.MeshTopology = {}));
    var IndexBufferBinding = /* @__PURE__ */ function() {
      function IndexBufferBinding2(buffer, format) {
        this._buffer = void 0;
        this._format = void 0;
        this._buffer = buffer;
        this._format = format;
      }
      _createClass2(IndexBufferBinding2, [{
        key: "buffer",
        get: function get() {
          return this._buffer;
        }
      }, {
        key: "format",
        get: function get() {
          return this._format;
        }
      }]);
      return IndexBufferBinding2;
    }();
    var SubMesh = function SubMesh2(start2, count, topology) {
      if (start2 === void 0) {
        start2 = 0;
      }
      if (count === void 0) {
        count = 0;
      }
      if (topology === void 0) {
        topology = exports3.MeshTopology.Triangles;
      }
      this.start = void 0;
      this.count = void 0;
      this.topology = void 0;
      this.start = start2;
      this.count = count;
      this.topology = topology;
    };
    var Mesh = /* @__PURE__ */ function(_RefObject) {
      _inheritsLoose2(Mesh2, _RefObject);
      function Mesh2(engine, name) {
        var _this;
        _this = _RefObject.call(this, engine) || this;
        _this.name = void 0;
        _this.bounds = new miniprogram2.BoundingBox();
        _this._vertexElementMap = {};
        _this._glIndexType = void 0;
        _this._glIndexByteCount = void 0;
        _this._platformPrimitive = void 0;
        _this._instanceCount = 0;
        _this._vertexBufferBindings = [];
        _this._indexBufferBinding = null;
        _this._vertexElements = [];
        _this._enableVAO = true;
        _this._subMeshes = [];
        _this._updateFlagManager = new UpdateFlagManager();
        _this.name = name;
        _this._platformPrimitive = _this._engine._hardwareRenderer.createPlatformPrimitive(_assertThisInitialized(_this));
        return _this;
      }
      var _proto = Mesh2.prototype;
      _proto.addSubMesh = function addSubMesh(startOrSubMesh, count, topology) {
        if (topology === void 0) {
          topology = exports3.MeshTopology.Triangles;
        }
        if (typeof startOrSubMesh === "number") {
          startOrSubMesh = new SubMesh(startOrSubMesh, count, topology);
        }
        this._subMeshes.push(startOrSubMesh);
        return startOrSubMesh;
      };
      _proto.removeSubMesh = function removeSubMesh(subMesh) {
        var subMeshes = this._subMeshes;
        var index = subMeshes.indexOf(subMesh);
        if (index !== -1) {
          subMeshes.splice(index, 1);
        }
      };
      _proto.clearSubMesh = function clearSubMesh() {
        this._subMeshes.length = 0;
      };
      _proto.registerUpdateFlag = function registerUpdateFlag() {
        return this._updateFlagManager.createFlag(BoolUpdateFlag);
      };
      _proto._clearVertexElements = function _clearVertexElements() {
        this._vertexElements.length = 0;
        var vertexElementMap = this._vertexElementMap;
        for (var k in vertexElementMap) {
          delete vertexElementMap[k];
        }
      };
      _proto._addVertexElement = function _addVertexElement(element) {
        var semantic = element.semantic;
        this._vertexElementMap[semantic] = element;
        this._vertexElements.push(element);
        this._updateFlagManager.dispatch();
      };
      _proto._setVertexBufferBinding = function _setVertexBufferBinding(index, binding) {
        if (this._getRefCount() > 0) {
          var lastBinding = this._vertexBufferBindings[index];
          lastBinding && lastBinding._buffer._addRefCount(-1);
          binding._buffer._addRefCount(1);
        }
        this._vertexBufferBindings[index] = binding;
      };
      _proto._draw = function _draw(shaderProgram, subMesh) {
        this._platformPrimitive.draw(shaderProgram, subMesh);
      };
      _proto._addRefCount = function _addRefCount(value) {
        _RefObject.prototype._addRefCount.call(this, value);
        var vertexBufferBindings = this._vertexBufferBindings;
        for (var i = 0, n = vertexBufferBindings.length; i < n; i++) {
          vertexBufferBindings[i]._buffer._addRefCount(value);
        }
      };
      _proto._onDestroy = function _onDestroy() {
        this._vertexBufferBindings = null;
        this._indexBufferBinding = null;
        this._vertexElements = null;
        this._vertexElementMap = null;
        this._platformPrimitive.destroy();
      };
      _proto._setVertexElements = function _setVertexElements(elements) {
        this._clearVertexElements();
        for (var i = 0, n = elements.length; i < n; i++) {
          this._addVertexElement(elements[i]);
        }
      };
      _proto._setIndexBufferBinding = function _setIndexBufferBinding(binding) {
        if (binding) {
          this._indexBufferBinding = binding;
          this._glIndexType = BufferUtil._getGLIndexType(binding.format);
          this._glIndexByteCount = BufferUtil._getGLIndexByteCount(binding.format);
        } else {
          this._indexBufferBinding = null;
          this._glIndexType = void 0;
        }
      };
      _createClass2(Mesh2, [{
        key: "subMesh",
        get: function get() {
          return this._subMeshes[0] || null;
        }
      }, {
        key: "subMeshes",
        get: function get() {
          return this._subMeshes;
        }
      }]);
      return Mesh2;
    }(RefObject);
    var VertexBufferBinding = /* @__PURE__ */ function() {
      function VertexBufferBinding2(buffer, stride) {
        this._buffer = void 0;
        this._stride = void 0;
        this._buffer = buffer;
        this._stride = stride;
      }
      _createClass2(VertexBufferBinding2, [{
        key: "buffer",
        get: function get() {
          return this._buffer;
        }
      }, {
        key: "stride",
        get: function get() {
          return this._stride;
        }
      }]);
      return VertexBufferBinding2;
    }();
    exports3.RenderBufferDepthFormat = void 0;
    (function(RenderBufferDepthFormat) {
      RenderBufferDepthFormat[RenderBufferDepthFormat["Depth"] = 0] = "Depth";
      RenderBufferDepthFormat[RenderBufferDepthFormat["DepthStencil"] = 1] = "DepthStencil";
      RenderBufferDepthFormat[RenderBufferDepthFormat["Stencil"] = 2] = "Stencil";
      RenderBufferDepthFormat[RenderBufferDepthFormat["Depth16"] = 3] = "Depth16";
      RenderBufferDepthFormat[RenderBufferDepthFormat["Depth24"] = 4] = "Depth24";
      RenderBufferDepthFormat[RenderBufferDepthFormat["Depth32"] = 5] = "Depth32";
      RenderBufferDepthFormat[RenderBufferDepthFormat["Depth24Stencil8"] = 6] = "Depth24Stencil8";
      RenderBufferDepthFormat[RenderBufferDepthFormat["Depth32Stencil8"] = 7] = "Depth32Stencil8";
    })(exports3.RenderBufferDepthFormat || (exports3.RenderBufferDepthFormat = {}));
    exports3.TextureCubeFace = void 0;
    (function(TextureCubeFace) {
      TextureCubeFace[TextureCubeFace["PositiveX"] = 0] = "PositiveX";
      TextureCubeFace[TextureCubeFace["NegativeX"] = 1] = "NegativeX";
      TextureCubeFace[TextureCubeFace["PositiveY"] = 2] = "PositiveY";
      TextureCubeFace[TextureCubeFace["NegativeY"] = 3] = "NegativeY";
      TextureCubeFace[TextureCubeFace["PositiveZ"] = 4] = "PositiveZ";
      TextureCubeFace[TextureCubeFace["NegativeZ"] = 5] = "NegativeZ";
    })(exports3.TextureCubeFace || (exports3.TextureCubeFace = {}));
    exports3.TextureFilterMode = void 0;
    (function(TextureFilterMode) {
      TextureFilterMode[TextureFilterMode["Point"] = 0] = "Point";
      TextureFilterMode[TextureFilterMode["Bilinear"] = 1] = "Bilinear";
      TextureFilterMode[TextureFilterMode["Trilinear"] = 2] = "Trilinear";
    })(exports3.TextureFilterMode || (exports3.TextureFilterMode = {}));
    exports3.TextureFormat = void 0;
    (function(TextureFormat) {
      TextureFormat[TextureFormat["R8G8B8"] = 0] = "R8G8B8";
      TextureFormat[TextureFormat["R8G8B8A8"] = 1] = "R8G8B8A8";
      TextureFormat[TextureFormat["R4G4B4A4"] = 2] = "R4G4B4A4";
      TextureFormat[TextureFormat["R5G5B5A1"] = 3] = "R5G5B5A1";
      TextureFormat[TextureFormat["R5G6B5"] = 4] = "R5G6B5";
      TextureFormat[TextureFormat["Alpha8"] = 5] = "Alpha8";
      TextureFormat[TextureFormat["LuminanceAlpha"] = 6] = "LuminanceAlpha";
      TextureFormat[TextureFormat["R16G16B16A16"] = 7] = "R16G16B16A16";
      TextureFormat[TextureFormat["R32G32B32A32"] = 8] = "R32G32B32A32";
      TextureFormat[TextureFormat["DXT1"] = 9] = "DXT1";
      TextureFormat[TextureFormat["DXT5"] = 10] = "DXT5";
      TextureFormat[TextureFormat["ETC1_RGB"] = 11] = "ETC1_RGB";
      TextureFormat[TextureFormat["ETC2_RGB"] = 12] = "ETC2_RGB";
      TextureFormat[TextureFormat["ETC2_RGBA5"] = 13] = "ETC2_RGBA5";
      TextureFormat[TextureFormat["ETC2_RGBA8"] = 14] = "ETC2_RGBA8";
      TextureFormat[TextureFormat["PVRTC_RGB2"] = 15] = "PVRTC_RGB2";
      TextureFormat[TextureFormat["PVRTC_RGBA2"] = 16] = "PVRTC_RGBA2";
      TextureFormat[TextureFormat["PVRTC_RGB4"] = 17] = "PVRTC_RGB4";
      TextureFormat[TextureFormat["PVRTC_RGBA4"] = 18] = "PVRTC_RGBA4";
      TextureFormat[TextureFormat["ASTC_4x4"] = 19] = "ASTC_4x4";
      TextureFormat[TextureFormat["ASTC_5x5"] = 20] = "ASTC_5x5";
      TextureFormat[TextureFormat["ASTC_6x6"] = 21] = "ASTC_6x6";
      TextureFormat[TextureFormat["ASTC_8x8"] = 22] = "ASTC_8x8";
      TextureFormat[TextureFormat["ASTC_10x10"] = 23] = "ASTC_10x10";
      TextureFormat[TextureFormat["ASTC_12x12"] = 24] = "ASTC_12x12";
      TextureFormat[TextureFormat["Depth"] = 25] = "Depth";
      TextureFormat[TextureFormat["DepthStencil"] = 26] = "DepthStencil";
      TextureFormat[TextureFormat["Stencil"] = 27] = "Stencil";
      TextureFormat[TextureFormat["Depth16"] = 28] = "Depth16";
      TextureFormat[TextureFormat["Depth24"] = 29] = "Depth24";
      TextureFormat[TextureFormat["Depth32"] = 30] = "Depth32";
      TextureFormat[TextureFormat["Depth24Stencil8"] = 31] = "Depth24Stencil8";
      TextureFormat[TextureFormat["Depth32Stencil8"] = 32] = "Depth32Stencil8";
    })(exports3.TextureFormat || (exports3.TextureFormat = {}));
    exports3.TextureWrapMode = void 0;
    (function(TextureWrapMode2) {
      TextureWrapMode2[TextureWrapMode2["Clamp"] = 0] = "Clamp";
      TextureWrapMode2[TextureWrapMode2["Repeat"] = 1] = "Repeat";
      TextureWrapMode2[TextureWrapMode2["Mirror"] = 2] = "Mirror";
    })(exports3.TextureWrapMode || (exports3.TextureWrapMode = {}));
    var RenderTarget = /* @__PURE__ */ function(_EngineObject) {
      _inheritsLoose2(RenderTarget2, _EngineObject);
      function RenderTarget2(engine, width, height, renderTexture, depth, antiAliasing) {
        var _this;
        if (depth === void 0) {
          depth = exports3.RenderBufferDepthFormat.Depth;
        }
        if (antiAliasing === void 0) {
          antiAliasing = 1;
        }
        _this = _EngineObject.call(this, engine) || this;
        _this._platformRenderTarget = void 0;
        _this._depth = void 0;
        _this._antiAliasing = void 0;
        _this._autoGenerateMipmaps = true;
        _this._width = void 0;
        _this._height = void 0;
        _this._colorTextures = void 0;
        _this._depthTexture = void 0;
        _this._width = width;
        _this._height = height;
        _this._antiAliasing = antiAliasing;
        _this._depth = depth;
        if (renderTexture) {
          _this._colorTextures = renderTexture instanceof Array ? renderTexture.slice() : [renderTexture];
        } else {
          _this._colorTextures = [];
        }
        if (depth instanceof Texture) {
          _this._depthTexture = depth;
        }
        _this._platformRenderTarget = engine._hardwareRenderer.createPlatformRenderTarget(_assertThisInitialized(_this));
        return _this;
      }
      var _proto = RenderTarget2.prototype;
      _proto.getColorTexture = function getColorTexture(index) {
        if (index === void 0) {
          index = 0;
        }
        return this._colorTextures[index];
      };
      _proto.generateMipmaps = function generateMipmaps() {
        if (this._autoGenerateMipmaps) {
          var _colorTextures = this._colorTextures;
          for (var i = 0, n = _colorTextures.length; i < n; i++) {
            var _colorTexture = _colorTextures[i];
            _colorTexture.generateMipmaps();
          }
          this._depthTexture && this._depthTexture.generateMipmaps();
        }
      };
      _proto.destroy = function destroy() {
        this._platformRenderTarget.destroy();
        this._colorTextures.length = 0;
        this._depthTexture = null;
        this._depth = null;
      };
      _proto._setRenderTargetInfo = function _setRenderTargetInfo(faceIndex, mipLevel) {
        this._platformRenderTarget.setRenderTargetInfo(faceIndex, mipLevel);
      };
      _proto._blitRenderTarget = function _blitRenderTarget() {
        this._platformRenderTarget.blitRenderTarget();
      };
      _createClass2(RenderTarget2, [{
        key: "autoGenerateMipmaps",
        get: function get() {
          return this._autoGenerateMipmaps;
        },
        set: function set(value) {
          this._autoGenerateMipmaps = value;
        }
      }, {
        key: "width",
        get: function get() {
          return this._width;
        }
      }, {
        key: "height",
        get: function get() {
          return this._height;
        }
      }, {
        key: "colorTextureCount",
        get: function get() {
          return this._colorTextures.length;
        }
      }, {
        key: "depthTexture",
        get: function get() {
          return this._depthTexture;
        }
      }, {
        key: "antiAliasing",
        get: function get() {
          return this._antiAliasing;
        }
      }]);
      return RenderTarget2;
    }(EngineObject);
    var Texture2D = /* @__PURE__ */ function(_Texture) {
      _inheritsLoose2(Texture2D2, _Texture);
      function Texture2D2(engine, width, height, format, mipmap) {
        var _this;
        if (format === void 0) {
          format = exports3.TextureFormat.R8G8B8A8;
        }
        if (mipmap === void 0) {
          mipmap = true;
        }
        _this = _Texture.call(this, engine) || this;
        _this._mipmap = mipmap;
        _this._width = width;
        _this._height = height;
        _this._format = format;
        _this._mipmapCount = _this._getMipmapCount();
        _this._platformTexture = engine._hardwareRenderer.createPlatformTexture2D(_assertThisInitialized(_this));
        _this.filterMode = exports3.TextureFilterMode.Bilinear;
        _this.wrapModeU = _this.wrapModeV = exports3.TextureWrapMode.Repeat;
        return _this;
      }
      var _proto = Texture2D2.prototype;
      _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
        if (mipLevel === void 0) {
          mipLevel = 0;
        }
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        this._platformTexture.setPixelBuffer(colorBuffer, mipLevel, x, y, width, height);
      };
      _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        if (mipLevel === void 0) {
          mipLevel = 0;
        }
        if (flipY === void 0) {
          flipY = false;
        }
        if (premultiplyAlpha === void 0) {
          premultiplyAlpha = false;
        }
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        this._platformTexture.setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
      };
      _proto.getPixelBuffer = function getPixelBuffer(xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out) {
        var argsLength = arguments.length;
        if (argsLength === 1) {
          this._platformTexture.getPixelBuffer(0, 0, this._width, this._height, 0, xOrMipLevelOrOut);
        } else if (argsLength === 2) {
          this._platformTexture.getPixelBuffer(0, 0, this._width >> xOrMipLevelOrOut, this._height >> xOrMipLevelOrOut, xOrMipLevelOrOut, yOrMipLevel);
        } else if (argsLength === 5) {
          this._platformTexture.getPixelBuffer(xOrMipLevelOrOut, yOrMipLevel, width, height, 0, mipLevelOrOut);
        } else if (argsLength === 6) {
          this._platformTexture.getPixelBuffer(xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out);
        }
      };
      return Texture2D2;
    }(Texture);
    var Texture2DArray = /* @__PURE__ */ function(_Texture) {
      _inheritsLoose2(Texture2DArray2, _Texture);
      function Texture2DArray2(engine, width, height, length2, format, mipmap) {
        var _this;
        if (format === void 0) {
          format = exports3.TextureFormat.R8G8B8A8;
        }
        if (mipmap === void 0) {
          mipmap = true;
        }
        _this = _Texture.call(this, engine) || this;
        _this._length = void 0;
        _this._mipmap = mipmap;
        _this._width = width;
        _this._height = height;
        _this._length = length2;
        _this._format = format;
        _this._mipmapCount = _this._getMipmapCount();
        _this._platformTexture = engine._hardwareRenderer.createPlatformTexture2DArray(_assertThisInitialized(_this));
        _this.filterMode = exports3.TextureFilterMode.Bilinear;
        _this.wrapModeU = _this.wrapModeV = exports3.TextureWrapMode.Repeat;
        return _this;
      }
      var _proto = Texture2DArray2.prototype;
      _proto.setPixelBuffer = function setPixelBuffer(offsetIndex, colorBuffer, mipLevel, x, y, width, height, length2) {
        if (mipLevel === void 0) {
          mipLevel = 0;
        }
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        this._platformTexture.setPixelBuffer(offsetIndex, colorBuffer, mipLevel, x, y, width, height, length2);
      };
      _proto.setImageSource = function setImageSource(elementIndex, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        if (mipLevel === void 0) {
          mipLevel = 0;
        }
        if (flipY === void 0) {
          flipY = false;
        }
        if (premultiplyAlpha === void 0) {
          premultiplyAlpha = false;
        }
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        this._platformTexture.setImageSource(elementIndex, imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
      };
      _proto.getPixelBuffer = function getPixelBuffer(elementIndex, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out) {
        var argsLength = arguments.length;
        if (argsLength === 1) {
          this._platformTexture.getPixelBuffer(elementIndex, 0, 0, this._width, this._height, 0, xOrMipLevelOrOut);
        } else if (argsLength === 2) {
          this._platformTexture.getPixelBuffer(elementIndex, 0, 0, this._width >> xOrMipLevelOrOut, this._height >> xOrMipLevelOrOut, xOrMipLevelOrOut, yOrMipLevel);
        } else if (argsLength === 5) {
          this._platformTexture.getPixelBuffer(elementIndex, xOrMipLevelOrOut, yOrMipLevel, width, height, 0, mipLevelOrOut);
        } else if (argsLength === 6) {
          this._platformTexture.getPixelBuffer(elementIndex, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out);
        }
      };
      _createClass2(Texture2DArray2, [{
        key: "length",
        get: function get() {
          return this._length;
        }
      }]);
      return Texture2DArray2;
    }(Texture);
    var TextureCube = /* @__PURE__ */ function(_Texture) {
      _inheritsLoose2(TextureCube2, _Texture);
      function TextureCube2(engine, size, format, mipmap) {
        var _this;
        if (format === void 0) {
          format = exports3.TextureFormat.R8G8B8A8;
        }
        if (mipmap === void 0) {
          mipmap = true;
        }
        _this = _Texture.call(this, engine) || this;
        _this._mipmap = mipmap;
        _this._width = size;
        _this._height = size;
        _this._format = format;
        _this._mipmapCount = _this._getMipmapCount();
        _this._platformTexture = engine._hardwareRenderer.createPlatformTextureCube(_assertThisInitialized(_this));
        _this.filterMode = exports3.TextureFilterMode.Bilinear;
        _this.wrapModeU = _this.wrapModeV = exports3.TextureWrapMode.Clamp;
        return _this;
      }
      var _proto = TextureCube2.prototype;
      _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
        if (mipLevel === void 0) {
          mipLevel = 0;
        }
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        this._platformTexture.setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height);
      };
      _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        if (mipLevel === void 0) {
          mipLevel = 0;
        }
        if (flipY === void 0) {
          flipY = false;
        }
        if (premultiplyAlpha === void 0) {
          premultiplyAlpha = false;
        }
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        this._platformTexture.setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
      };
      _proto.getPixelBuffer = function getPixelBuffer(face, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out) {
        var argsLength = arguments.length;
        if (argsLength === 2) {
          this._platformTexture.getPixelBuffer(face, 0, 0, this._width, this._height, 0, xOrMipLevelOrOut);
        } else if (argsLength === 3) {
          this._platformTexture.getPixelBuffer(face, 0, 0, this._width >> xOrMipLevelOrOut, this._height >> xOrMipLevelOrOut, xOrMipLevelOrOut, yOrMipLevel);
        } else if (argsLength === 6) {
          this._platformTexture.getPixelBuffer(face, xOrMipLevelOrOut, yOrMipLevel, width, height, 0, mipLevelOrOut);
        } else if (argsLength === 7) {
          this._platformTexture.getPixelBuffer(face, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out);
        }
      };
      return TextureCube2;
    }(Texture);
    var BlendShapeManager = /* @__PURE__ */ function() {
      function BlendShapeManager2(engine, modelMesh) {
        this._blendShapeCount = 0;
        this._blendShapes = [];
        this._blendShapeNames = void 0;
        this._layoutDirtyListener = new ListenerUpdateFlag();
        this._subDataDirtyFlags = [];
        this._vertexTexture = void 0;
        this._vertexBuffers = [];
        this._vertices = void 0;
        this._useBlendNormal = false;
        this._useBlendTangent = false;
        this._vertexElementCount = 0;
        this._vertexElementOffset = void 0;
        this._storeInVertexBufferInfo = [];
        this._maxCountSingleVertexBuffer = 0;
        this._engine = void 0;
        this._modelMesh = void 0;
        this._lastCreateHostInfo = new miniprogram2.Vector3(0, 0, 0);
        this._canUseTextureStoreData = true;
        this._dataTextureInfo = new miniprogram2.Vector3();
        this._engine = engine;
        this._modelMesh = modelMesh;
        this._canUseTextureStoreData = this._engine._hardwareRenderer.capability.canUseFloatTextureBlendShape;
        this._layoutDirtyListener.listener = this._updateLayoutChange.bind(this);
      }
      var _proto = BlendShapeManager2.prototype;
      _proto._addBlendShape = function _addBlendShape(blendShape) {
        this._blendShapes.push(blendShape);
        this._blendShapeCount++;
        blendShape._addLayoutChangeFlag(this._layoutDirtyListener);
        this._updateLayoutChange(blendShape);
        this._subDataDirtyFlags.push(blendShape._createSubDataDirtyFlag());
      };
      _proto._clearBlendShapes = function _clearBlendShapes() {
        this._useBlendNormal = false;
        this._useBlendTangent = false;
        this._vertexElementCount = 0;
        this._blendShapes.length = 0;
        this._blendShapeCount = 0;
        this._layoutDirtyListener.clearFromManagers();
        var subDataDirtyFlags = this._subDataDirtyFlags;
        for (var i = 0, n = subDataDirtyFlags.length; i < n; i++) {
          subDataDirtyFlags[i].destroy();
        }
        subDataDirtyFlags.length = 0;
      };
      _proto._updateShaderData = function _updateShaderData(shaderData, skinnedMeshRenderer) {
        var blendShapeCount = this._blendShapeCount;
        if (blendShapeCount > 0) {
          shaderData.enableMacro(BlendShapeManager2._blendShapeMacro);
          if (this._useTextureMode()) {
            shaderData.enableMacro(BlendShapeManager2._blendShapeTextureMacro);
            shaderData.setTexture(BlendShapeManager2._blendShapeTextureProperty, this._vertexTexture);
            shaderData.setVector3(BlendShapeManager2._blendShapeTextureInfoProperty, this._dataTextureInfo);
            shaderData.setFloatArray(BlendShapeManager2._blendShapeWeightsProperty, skinnedMeshRenderer.blendShapeWeights);
          } else {
            var maxBlendCount = this._getVertexBufferModeSupportCount();
            if (blendShapeCount > maxBlendCount) {
              var condensedBlendShapeWeights = skinnedMeshRenderer._condensedBlendShapeWeights;
              if (!condensedBlendShapeWeights) {
                condensedBlendShapeWeights = new Float32Array(maxBlendCount);
                skinnedMeshRenderer._condensedBlendShapeWeights = condensedBlendShapeWeights;
              }
              this._filterCondensedBlendShapeWeights(skinnedMeshRenderer.blendShapeWeights, condensedBlendShapeWeights);
              shaderData.setFloatArray(BlendShapeManager2._blendShapeWeightsProperty, condensedBlendShapeWeights);
              this._modelMesh._enableVAO = false;
              blendShapeCount = maxBlendCount;
            } else {
              shaderData.setFloatArray(BlendShapeManager2._blendShapeWeightsProperty, skinnedMeshRenderer.blendShapeWeights);
              this._modelMesh._enableVAO = true;
            }
            shaderData.disableMacro(BlendShapeManager2._blendShapeTextureMacro);
          }
          shaderData.enableMacro("OASIS_BLENDSHAPE_COUNT", blendShapeCount.toString());
          if (this._useBlendNormal) {
            shaderData.enableMacro(BlendShapeManager2._blendShapeNormalMacro);
          } else {
            shaderData.disableMacro(BlendShapeManager2._blendShapeNormalMacro);
          }
          if (this._useBlendTangent) {
            shaderData.enableMacro(BlendShapeManager2._blendShapeTangentMacro);
          } else {
            shaderData.disableMacro(BlendShapeManager2._blendShapeTangentMacro);
          }
        } else {
          shaderData.disableMacro(BlendShapeManager2._blendShapeMacro);
          shaderData.disableMacro("OASIS_BLENDSHAPE_COUNT");
        }
      };
      _proto._useTextureMode = function _useTextureMode() {
        if (!this._canUseTextureStoreData) {
          return false;
        }
        return this._blendShapeCount > this._getVertexBufferModeSupportCount();
      };
      _proto._layoutOrCountChange = function _layoutOrCountChange() {
        var last = this._lastCreateHostInfo;
        return last.x !== this._blendShapeCount || !!last.y !== this._useBlendNormal || !!last.z !== this._useBlendTangent;
      };
      _proto._vertexElementsNeedUpdate = function _vertexElementsNeedUpdate() {
        var maxSupportCount = this._getVertexBufferModeSupportCount();
        var info2 = this._lastCreateHostInfo;
        return Math.min(info2.x, maxSupportCount) !== Math.min(this._blendShapeCount, maxSupportCount) || !!info2.y !== this._useBlendNormal || !!info2.z !== this._useBlendTangent;
      };
      _proto._needUpdateData = function _needUpdateData() {
        var subDataDirtyFlags = this._subDataDirtyFlags;
        for (var i = 0, n = subDataDirtyFlags.length; i < n; i++) {
          if (subDataDirtyFlags[i].flag) {
            return true;
          }
        }
        return false;
      };
      _proto._addVertexElements = function _addVertexElements(modelMesh) {
        var offset = 0;
        this._vertexElementOffset = modelMesh._vertexElements.length;
        for (var i = 0, n = Math.min(this._blendShapeCount, this._getVertexBufferModeSupportCount()); i < n; i++) {
          modelMesh._addVertexElement(new VertexElement("POSITION_BS" + i, offset, exports3.VertexElementFormat.Vector3, 1));
          offset += 12;
          if (this._useBlendNormal) {
            modelMesh._addVertexElement(new VertexElement("NORMAL_BS" + i, offset, exports3.VertexElementFormat.Vector3, 1));
            offset += 12;
          }
          if (this._useBlendTangent) {
            modelMesh._addVertexElement(new VertexElement("TANGENT_BS" + i, offset, exports3.VertexElementFormat.Vector3, 1));
            offset += 12;
          }
        }
      };
      _proto._update = function _update(vertexCountChange, noLongerAccessible) {
        var vertexCount = this._modelMesh.vertexCount;
        var useTexture = this._useTextureMode();
        var createHost = this._layoutOrCountChange() || vertexCountChange;
        if (createHost) {
          if (useTexture) {
            this._createTextureArray(vertexCount);
          } else {
            this._createVertexBuffers(vertexCount, noLongerAccessible);
          }
          this._lastCreateHostInfo.set(this._blendShapeCount, +this._useBlendNormal, +this._useBlendTangent);
        }
        if (this._needUpdateData()) {
          if (useTexture) {
            this._updateTextureArray(vertexCount, createHost);
          } else {
            this._updateVertexBuffers(vertexCount, createHost);
          }
        }
      };
      _proto._releaseMemoryCache = function _releaseMemoryCache() {
        var blendShapes = this._blendShapes;
        var blendShapeCount = blendShapes.length;
        var blendShapeNamesMap = new Array(blendShapeCount);
        for (var i = 0; i < blendShapeCount; i++) {
          blendShapeNamesMap[i] = blendShapes[i].name;
        }
        this._blendShapeNames = blendShapeNamesMap;
        this._layoutDirtyListener.destroy();
        var dataChangedFlags = this._subDataDirtyFlags;
        for (var _i = 0, n = dataChangedFlags.length; _i < n; _i++) {
          dataChangedFlags[_i].destroy();
        }
        this._layoutDirtyListener = null;
        this._subDataDirtyFlags = null;
        this._blendShapes = null;
        this._vertices = null;
      };
      _proto._createVertexBuffers = function _createVertexBuffers(vertexCount, noLongerAccessible) {
        var engine = this._engine, modelMesh = this._modelMesh, blendShapeCount = this._blendShapeCount, vertexBuffers = this._vertexBuffers;
        var vertexFloatCount = this._vertexElementCount * 3;
        var vertexByteCount = vertexFloatCount * 4;
        var maxCountSingleBuffer = Math.floor(255 / vertexByteCount);
        var bufferCount = Math.ceil(blendShapeCount / maxCountSingleBuffer);
        var floatCount = vertexFloatCount * vertexCount * Math.min(maxCountSingleBuffer, blendShapeCount);
        vertexBuffers.length = bufferCount;
        this._vertices = new Float32Array(floatCount);
        this._maxCountSingleVertexBuffer = maxCountSingleBuffer;
        this._storeInVertexBufferInfo.length = blendShapeCount;
        for (var i = 0; i < bufferCount; i++) {
          var lastIndex = bufferCount - 1;
          var containCount = i === lastIndex ? blendShapeCount - lastIndex * maxCountSingleBuffer : maxCountSingleBuffer;
          var stride = containCount * vertexByteCount;
          var byteLength = stride * vertexCount;
          var usage = noLongerAccessible ? exports3.BufferUsage.Static : exports3.BufferUsage.Dynamic;
          var blendShapeBuffer = new Buffer2(engine, exports3.BufferBindFlag.VertexBuffer, byteLength, usage);
          modelMesh._setVertexBufferBinding(i + 1, new VertexBufferBinding(blendShapeBuffer, stride));
          vertexBuffers[i] = blendShapeBuffer;
        }
      };
      _proto._createTextureArray = function _createTextureArray(vertexCount) {
        var maxTextureSize = this._engine._hardwareRenderer.capability.maxTextureSize;
        var vertexPixelStride = this._vertexElementCount;
        var textureWidth = vertexPixelStride * vertexCount;
        var textureHeight = 1;
        if (textureWidth > maxTextureSize) {
          textureHeight = Math.ceil(textureWidth / maxTextureSize);
          textureWidth = maxTextureSize;
        }
        var blendShapeDataTexture = this._vertexTexture;
        var blendShapeCount = this._blendShapes.length;
        blendShapeDataTexture && blendShapeDataTexture.destroy();
        blendShapeDataTexture = new Texture2DArray(this._engine, textureWidth, textureHeight, blendShapeCount, exports3.TextureFormat.R32G32B32A32, false);
        blendShapeDataTexture.filterMode = exports3.TextureFilterMode.Point;
        this._vertices = new Float32Array(blendShapeCount * textureWidth * textureHeight * 4);
        this._vertexTexture = blendShapeDataTexture;
        this._dataTextureInfo.set(vertexPixelStride, textureWidth, textureHeight);
      };
      _proto._updateVertexBuffers = function _updateVertexBuffers(vertexCount, force) {
        var blendShapes = this._blendShapes, maxCountSingleBuffer = this._maxCountSingleVertexBuffer;
        var vertices = this._vertices, vertexBuffers = this._vertexBuffers, storeInfos = this._storeInVertexBufferInfo;
        var subDataDirtyFlags = this._subDataDirtyFlags;
        var blendShapeFloatStride = this._vertexElementCount * 3;
        var blendShapeByteStride = blendShapeFloatStride * 4;
        for (var i = 0, n = blendShapes.length; i < n; i++) {
          var dataChangedFlag = subDataDirtyFlags[i];
          if (force || dataChangedFlag.flag) {
            var frames = blendShapes[i].frames;
            var frameCount = frames.length;
            var endFrame = frames[frameCount - 1];
            if (frameCount > 0 && endFrame.deltaPositions.length !== vertexCount) {
              throw "BlendShape frame deltaPositions length must same with mesh vertexCount.";
            }
            var bufferIndex = Math.floor(i / maxCountSingleBuffer);
            var indexInBuffer = i % maxCountSingleBuffer;
            var buffer = vertexBuffers[bufferIndex];
            var bufferFloatStride = buffer.byteLength / (vertexCount * 4);
            var offset = indexInBuffer * blendShapeFloatStride;
            var storeInfo = storeInfos[i];
            storeInfo || (storeInfos[i] = storeInfo = new miniprogram2.Vector2());
            storeInfo.set(bufferIndex + 1, indexInBuffer * blendShapeByteStride);
            var _endFrame = endFrame, deltaPositions = _endFrame.deltaPositions;
            for (var j = 0; j < vertexCount; j++) {
              var start2 = offset + bufferFloatStride * j;
              var deltaPosition = deltaPositions[j];
              if (deltaPosition) {
                vertices[start2] = deltaPosition.x;
                vertices[start2 + 1] = deltaPosition.y;
                vertices[start2 + 2] = deltaPosition.z;
              }
            }
            offset += 3;
            if (this._useBlendNormal) {
              var _endFrame2 = endFrame, deltaNormals = _endFrame2.deltaNormals;
              if (deltaNormals) {
                for (var _j = 0; _j < vertexCount; _j++) {
                  var _start = offset + bufferFloatStride * _j;
                  var deltaNormal = deltaNormals[_j];
                  if (deltaNormal) {
                    vertices[_start] = deltaNormal.x;
                    vertices[_start + 1] = deltaNormal.y;
                    vertices[_start + 2] = deltaNormal.z;
                  }
                }
              }
              offset += 3;
            }
            if (this._useBlendTangent) {
              var _endFrame3 = endFrame, deltaTangents = _endFrame3.deltaTangents;
              if (deltaTangents) {
                for (var _j2 = 0; _j2 < vertexCount; _j2++) {
                  var _start2 = offset + bufferFloatStride * _j2;
                  var deltaTangent = deltaTangents[_j2];
                  if (deltaTangent) {
                    vertices[_start2] = deltaTangent.x;
                    vertices[_start2 + 1] = deltaTangent.y;
                    vertices[_start2 + 2] = deltaTangent.z;
                  }
                }
              }
              offset += 3;
            }
            if (indexInBuffer === maxCountSingleBuffer - 1 || i === n - 1) {
              buffer.setData(vertices, 0, 0, buffer.byteLength / 4);
            }
            dataChangedFlag.flag = false;
          }
        }
      };
      _proto._updateTextureArray = function _updateTextureArray(vertexCount, force) {
        var blendShapes = this._blendShapes, vertexTexture = this._vertexTexture, vertices = this._vertices, subDataDirtyFlags = this._subDataDirtyFlags;
        for (var i = 0, n = blendShapes.length; i < n; i++) {
          var subDirtyFlag = subDataDirtyFlags[i];
          var subBlendShapeDataStride = vertexTexture.width * vertexTexture.height * 4;
          if (force || subDirtyFlag.flag) {
            var frames = blendShapes[i].frames;
            var frameCount = frames.length;
            var endFrame = frames[frameCount - 1];
            if (frameCount > 0 && endFrame.deltaPositions.length !== vertexCount) {
              throw "BlendShape frame deltaPositions length must same with mesh vertexCount.";
            }
            var _endFrame4 = endFrame, deltaPositions = _endFrame4.deltaPositions, deltaNormals = _endFrame4.deltaNormals, deltaTangents = _endFrame4.deltaTangents;
            var offset = i * subBlendShapeDataStride;
            for (var j = 0; j < vertexCount; j++) {
              var position = deltaPositions[j];
              vertices[offset] = position.x;
              vertices[offset + 1] = position.y;
              vertices[offset + 2] = position.z;
              offset += 4;
              if (deltaNormals) {
                var normal = deltaNormals[j];
                vertices[offset] = normal.x;
                vertices[offset + 1] = normal.y;
                vertices[offset + 2] = normal.z;
                offset += 4;
              }
              if (deltaTangents) {
                var tangent = deltaTangents[j];
                vertices[offset] = tangent.x;
                vertices[offset + 1] = tangent.y;
                vertices[offset + 2] = tangent.z;
                offset += 4;
              }
            }
            subDirtyFlag.flag = false;
          }
        }
        vertexTexture.setPixelBuffer(0, vertices);
      };
      _proto._updateLayoutChange = function _updateLayoutChange(blendShape) {
        var notFirst = this._blendShapeCount > 1;
        var vertexElementCount = 1;
        var useBlendNormal = blendShape._useBlendShapeNormal;
        var useBlendTangent = blendShape._useBlendShapeTangent;
        if (notFirst) {
          useBlendNormal && (useBlendNormal = this._useBlendNormal);
          useBlendTangent && (useBlendTangent = this._useBlendTangent);
        }
        useBlendNormal && vertexElementCount++;
        useBlendTangent && vertexElementCount++;
        this._useBlendNormal = useBlendNormal;
        this._useBlendTangent = useBlendTangent;
        this._vertexElementCount = vertexElementCount;
      };
      _proto._attributeModeUpdateVertexElement = function _attributeModeUpdateVertexElement(vertexElements, vertexBufferStoreInfo, index, condensedIndex) {
        var elementOffset = this._vertexElementOffset + this._vertexElementCount * condensedIndex;
        var _vertexBufferStoreInf = vertexBufferStoreInfo[index], bufferIndex = _vertexBufferStoreInf.x, offset = _vertexBufferStoreInf.y;
        var vertexElement = vertexElements[elementOffset];
        vertexElement.bindingIndex = bufferIndex;
        vertexElement.offset = offset;
        if (this._useBlendNormal) {
          var _vertexElement = vertexElements[++elementOffset];
          offset += 12;
          _vertexElement.bindingIndex = bufferIndex;
          _vertexElement.offset = offset;
        }
        if (this._useBlendTangent) {
          var _vertexElement2 = vertexElements[++elementOffset];
          offset += 12;
          _vertexElement2.bindingIndex = bufferIndex;
          _vertexElement2.offset = offset;
        }
      };
      _proto._getVertexBufferModeSupportCount = function _getVertexBufferModeSupportCount() {
        if (this._useBlendNormal || this._useBlendTangent) {
          return 4;
        } else {
          return 8;
        }
      };
      _proto._filterCondensedBlendShapeWeights = function _filterCondensedBlendShapeWeights(blendShapeWeights, condensedBlendShapeWeights) {
        var condensedWeightsCount = condensedBlendShapeWeights.length;
        var vertexElements = this._modelMesh._vertexElements;
        var vertexBufferStoreInfo = this._storeInVertexBufferInfo;
        var thresholdWeight = Number.POSITIVE_INFINITY;
        var thresholdIndex;
        for (var i = 0, n = Math.min(blendShapeWeights.length, this._blendShapeCount); i < n; i++) {
          var weight = blendShapeWeights[i];
          if (i < condensedWeightsCount) {
            this._attributeModeUpdateVertexElement(vertexElements, vertexBufferStoreInfo, i, i);
            condensedBlendShapeWeights[i] = weight;
            if (weight < thresholdWeight) {
              thresholdWeight = weight;
              thresholdIndex = i;
            }
          } else if (weight > thresholdWeight) {
            this._attributeModeUpdateVertexElement(vertexElements, vertexBufferStoreInfo, i, thresholdIndex);
            condensedBlendShapeWeights[thresholdIndex] = weight;
            thresholdWeight = Number.POSITIVE_INFINITY;
            for (var j = 0; j < condensedWeightsCount; j++) {
              var condensedWeight = condensedBlendShapeWeights[j];
              if (condensedWeight < thresholdWeight) {
                thresholdWeight = condensedWeight;
                thresholdIndex = j;
              }
            }
          }
        }
      };
      return BlendShapeManager2;
    }();
    BlendShapeManager._blendShapeMacro = Shader.getMacroByName("OASIS_BLENDSHAPE");
    BlendShapeManager._blendShapeTextureMacro = Shader.getMacroByName("OASIS_BLENDSHAPE_TEXTURE");
    BlendShapeManager._blendShapeNormalMacro = Shader.getMacroByName("OASIS_BLENDSHAPE_NORMAL");
    BlendShapeManager._blendShapeTangentMacro = Shader.getMacroByName("OASIS_BLENDSHAPE_TANGENT");
    BlendShapeManager._blendShapeWeightsProperty = Shader.getPropertyByName("u_blendShapeWeights");
    BlendShapeManager._blendShapeTextureProperty = Shader.getPropertyByName("u_blendShapeTexture");
    BlendShapeManager._blendShapeTextureInfoProperty = Shader.getPropertyByName("u_blendShapeTextureInfo");
    var ModelMesh = /* @__PURE__ */ function(_Mesh) {
      _inheritsLoose2(ModelMesh2, _Mesh);
      function ModelMesh2(engine, name) {
        var _this;
        _this = _Mesh.call(this, engine) || this;
        _this._blendShapeManager = void 0;
        _this._vertexCount = 0;
        _this._accessible = true;
        _this._verticesFloat32 = null;
        _this._verticesUint8 = null;
        _this._indices = null;
        _this._indicesFormat = null;
        _this._vertexSlotChanged = true;
        _this._vertexChangeFlag = 0;
        _this._indicesChangeFlag = false;
        _this._vertexStrideFloat = 0;
        _this._lastUploadVertexCount = -1;
        _this._positions = [];
        _this._normals = null;
        _this._colors = null;
        _this._tangents = null;
        _this._uv = null;
        _this._uv1 = null;
        _this._uv2 = null;
        _this._uv3 = null;
        _this._uv4 = null;
        _this._uv5 = null;
        _this._uv6 = null;
        _this._uv7 = null;
        _this._boneWeights = null;
        _this._boneIndices = null;
        _this.name = name;
        _this._blendShapeManager = new BlendShapeManager(engine, _assertThisInitialized(_this));
        return _this;
      }
      var _proto = ModelMesh2.prototype;
      _proto.setPositions = function setPositions(positions) {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        this._positions = positions;
        this._vertexCount = positions.length;
        this._vertexChangeFlag |= ValueChanged.Position;
      };
      _proto.getPositions = function getPositions() {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        return this._positions;
      };
      _proto.setNormals = function setNormals(normals) {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        if (normals.length !== this._vertexCount) {
          throw "The array provided needs to be the same size as vertex count.";
        }
        this._vertexSlotChanged = !!this._normals !== !!normals;
        this._vertexChangeFlag |= ValueChanged.Normal;
        this._normals = normals;
      };
      _proto.getNormals = function getNormals() {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        return this._normals;
      };
      _proto.setColors = function setColors(colors) {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        if (colors.length !== this._vertexCount) {
          throw "The array provided needs to be the same size as vertex count.";
        }
        this._vertexSlotChanged = !!this._colors !== !!colors;
        this._vertexChangeFlag |= ValueChanged.Color;
        this._colors = colors;
      };
      _proto.getColors = function getColors() {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        return this._colors;
      };
      _proto.setBoneWeights = function setBoneWeights(boneWeights) {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        if (boneWeights.length !== this._vertexCount) {
          throw "The array provided needs to be the same size as vertex count.";
        }
        this._vertexSlotChanged = boneWeights != null;
        this._vertexChangeFlag |= ValueChanged.BoneWeight;
        this._boneWeights = boneWeights;
      };
      _proto.getBoneWeights = function getBoneWeights() {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        return this._boneWeights;
      };
      _proto.setBoneIndices = function setBoneIndices(boneIndices) {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        if (boneIndices.length !== this._vertexCount) {
          throw "The array provided needs to be the same size as vertex count.";
        }
        this._vertexSlotChanged = !!this._boneIndices !== !!boneIndices;
        this._vertexChangeFlag |= ValueChanged.BoneIndex;
        this._boneIndices = boneIndices;
      };
      _proto.getBoneIndices = function getBoneIndices() {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        return this._boneIndices;
      };
      _proto.setTangents = function setTangents(tangents) {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        if (tangents.length !== this._vertexCount) {
          throw "The array provided needs to be the same size as vertex count.";
        }
        this._vertexSlotChanged = !!this._tangents !== !!tangents;
        this._vertexChangeFlag |= ValueChanged.Tangent;
        this._tangents = tangents;
      };
      _proto.getTangents = function getTangents() {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        return this._tangents;
      };
      _proto.setUVs = function setUVs(uv, channelIndex) {
        var _channelIndex;
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        if (uv.length !== this._vertexCount) {
          throw "The array provided needs to be the same size as vertex count.";
        }
        channelIndex = (_channelIndex = channelIndex) != null ? _channelIndex : 0;
        switch (channelIndex) {
          case 0:
            this._vertexSlotChanged = !!this._uv !== !!uv;
            this._vertexChangeFlag |= ValueChanged.UV;
            this._uv = uv;
            break;
          case 1:
            this._vertexSlotChanged = !!this._uv1 !== !!uv;
            this._vertexChangeFlag |= ValueChanged.UV1;
            this._uv1 = uv;
            break;
          case 2:
            this._vertexSlotChanged = !!this._uv2 !== !!uv;
            this._vertexChangeFlag |= ValueChanged.UV2;
            this._uv2 = uv;
            break;
          case 3:
            this._vertexSlotChanged = !!this._uv3 !== !!uv;
            this._vertexChangeFlag |= ValueChanged.UV3;
            this._uv3 = uv;
            break;
          case 4:
            this._vertexSlotChanged = !!this._uv4 !== !!uv;
            this._vertexChangeFlag |= ValueChanged.UV4;
            this._uv4 = uv;
            break;
          case 5:
            this._vertexSlotChanged = !!this._uv5 !== !!uv;
            this._vertexChangeFlag |= ValueChanged.UV5;
            this._uv5 = uv;
            break;
          case 6:
            this._vertexSlotChanged = !!this._uv6 !== !!uv;
            this._vertexChangeFlag |= ValueChanged.UV6;
            this._uv6 = uv;
            break;
          case 7:
            this._vertexSlotChanged = !!this._uv7 !== !!uv;
            this._vertexChangeFlag |= ValueChanged.UV7;
            this._uv7 = uv;
            break;
          default:
            throw "The index of channel needs to be in range [0 - 7].";
        }
      };
      _proto.getUVs = function getUVs(channelIndex) {
        var _channelIndex2;
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        channelIndex = (_channelIndex2 = channelIndex) != null ? _channelIndex2 : 0;
        switch (channelIndex) {
          case 0:
            return this._uv;
          case 1:
            return this._uv1;
          case 2:
            return this._uv2;
          case 3:
            return this._uv3;
          case 4:
            return this._uv4;
          case 5:
            return this._uv5;
          case 6:
            return this._uv6;
          case 7:
            return this._uv7;
        }
        throw "The index of channel needs to be in range [0 - 7].";
      };
      _proto.setIndices = function setIndices(indices) {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        if (this._indices !== indices) {
          this._indices = indices;
          if (indices instanceof Uint8Array) {
            this._indicesFormat = exports3.IndexFormat.UInt8;
          } else if (indices instanceof Uint16Array) {
            this._indicesFormat = exports3.IndexFormat.UInt16;
          } else if (indices instanceof Uint32Array) {
            this._indicesFormat = exports3.IndexFormat.UInt32;
          }
        }
        this._indicesChangeFlag = true;
      };
      _proto.getIndices = function getIndices() {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        return this._indices;
      };
      _proto.addBlendShape = function addBlendShape(blendShape) {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        this._blendShapeManager._addBlendShape(blendShape);
      };
      _proto.clearBlendShapes = function clearBlendShapes() {
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        this._blendShapeManager._clearBlendShapes();
      };
      _proto.getBlendShapeName = function getBlendShapeName(index) {
        if (this._accessible) {
          var blendShapes = this._blendShapeManager._blendShapes;
          return blendShapes[index].name;
        } else {
          return this._blendShapeManager._blendShapeNames[index];
        }
      };
      _proto.uploadData = function uploadData(noLongerAccessible) {
        var _this$_vertexBufferBi, _this$_indexBufferBin;
        if (!this._accessible) {
          throw "Not allowed to access data while accessible is false.";
        }
        var vertexCount = this._vertexCount;
        var vertexElementChanged = this._updateVertexElements();
        var vertexCountChange = this._lastUploadVertexCount !== vertexCount;
        var vertexBuffer = (_this$_vertexBufferBi = this._vertexBufferBindings[0]) === null || _this$_vertexBufferBi === void 0 ? void 0 : _this$_vertexBufferBi._buffer;
        if (vertexCountChange) {
          vertexBuffer === null || vertexBuffer === void 0 ? void 0 : vertexBuffer.destroy();
          var elementCount = this._vertexStrideFloat;
          var vertexFloatCount = elementCount * vertexCount;
          var vertices = new Float32Array(vertexFloatCount);
          this._verticesFloat32 = vertices;
          this._verticesUint8 = new Uint8Array(vertices.buffer);
          this._updateVertices(vertices, true);
          var newVertexBuffer = new Buffer2(this._engine, exports3.BufferBindFlag.VertexBuffer, vertices, noLongerAccessible ? exports3.BufferUsage.Static : exports3.BufferUsage.Dynamic);
          this._setVertexBufferBinding(0, new VertexBufferBinding(newVertexBuffer, elementCount * 4));
          this._lastUploadVertexCount = vertexCount;
        } else {
          if (this._vertexChangeFlag & ValueChanged.All) {
            var _vertices = this._verticesFloat32;
            this._updateVertices(_vertices, vertexElementChanged);
            vertexBuffer.setData(_vertices);
          }
        }
        var indices = this._indices;
        var indexBuffer = (_this$_indexBufferBin = this._indexBufferBinding) === null || _this$_indexBufferBin === void 0 ? void 0 : _this$_indexBufferBin._buffer;
        if (indices) {
          if (!indexBuffer || indices.byteLength != indexBuffer.byteLength) {
            indexBuffer === null || indexBuffer === void 0 ? void 0 : indexBuffer.destroy();
            var newIndexBuffer = new Buffer2(this._engine, exports3.BufferBindFlag.IndexBuffer, indices);
            this._setIndexBufferBinding(new IndexBufferBinding(newIndexBuffer, this._indicesFormat));
            this._indicesChangeFlag = false;
          } else if (this._indicesChangeFlag) {
            indexBuffer.setData(indices);
            if (this._indexBufferBinding._format !== this._indicesFormat) {
              this._setIndexBufferBinding(new IndexBufferBinding(indexBuffer, this._indicesFormat));
            }
            this._indicesChangeFlag = false;
          }
        } else if (indexBuffer) {
          indexBuffer.destroy();
          this._setIndexBufferBinding(null);
        }
        var blendShapeManager = this._blendShapeManager;
        blendShapeManager._blendShapeCount > 0 && blendShapeManager._update(vertexCountChange, noLongerAccessible);
        if (noLongerAccessible) {
          this._accessible = false;
          this._releaseCache();
        }
      };
      _proto._onDestroy = function _onDestroy() {
        _Mesh.prototype._onDestroy.call(this);
        this._accessible && this._releaseCache();
      };
      _proto._updateVertexElements = function _updateVertexElements() {
        var blendShapeManager = this._blendShapeManager;
        var attributeMode = !blendShapeManager._useTextureMode();
        if (this._vertexSlotChanged || attributeMode && blendShapeManager._vertexElementsNeedUpdate()) {
          var offset = 12;
          var elementCount = 3;
          this._clearVertexElements();
          this._addVertexElement(POSITION_VERTEX_ELEMENT);
          if (this._normals) {
            this._addVertexElement(new VertexElement("NORMAL", offset, exports3.VertexElementFormat.Vector3, 0));
            offset += 12;
            elementCount += 3;
          }
          if (this._colors) {
            this._addVertexElement(new VertexElement("COLOR_0", offset, exports3.VertexElementFormat.Vector4, 0));
            offset += 16;
            elementCount += 4;
          }
          if (this._boneWeights) {
            this._addVertexElement(new VertexElement("WEIGHTS_0", offset, exports3.VertexElementFormat.Vector4, 0));
            offset += 16;
            elementCount += 4;
          }
          if (this._boneIndices) {
            this._addVertexElement(new VertexElement("JOINTS_0", offset, exports3.VertexElementFormat.UByte4, 0));
            offset += 4;
            elementCount += 1;
          }
          if (this._tangents) {
            this._addVertexElement(new VertexElement("TANGENT", offset, exports3.VertexElementFormat.Vector4, 0));
            offset += 16;
            elementCount += 4;
          }
          if (this._uv) {
            this._addVertexElement(new VertexElement("TEXCOORD_0", offset, exports3.VertexElementFormat.Vector2, 0));
            offset += 8;
            elementCount += 2;
          }
          if (this._uv1) {
            this._addVertexElement(new VertexElement("TEXCOORD_1", offset, exports3.VertexElementFormat.Vector2, 0));
            offset += 8;
            elementCount += 2;
          }
          if (this._uv2) {
            this._addVertexElement(new VertexElement("TEXCOORD_2", offset, exports3.VertexElementFormat.Vector2, 0));
            offset += 8;
            elementCount += 2;
          }
          if (this._uv3) {
            this._addVertexElement(new VertexElement("TEXCOORD_3", offset, exports3.VertexElementFormat.Vector2, 0));
            offset += 8;
            elementCount += 2;
          }
          if (this._uv4) {
            this._addVertexElement(new VertexElement("TEXCOORD_4", offset, exports3.VertexElementFormat.Vector2, 0));
            offset += 8;
            elementCount += 2;
          }
          if (this._uv5) {
            this._addVertexElement(new VertexElement("TEXCOORD_5", offset, exports3.VertexElementFormat.Vector2, 0));
            offset += 8;
            elementCount += 2;
          }
          if (this._uv6) {
            this._addVertexElement(new VertexElement("TEXCOORD_6", offset, exports3.VertexElementFormat.Vector2, 0));
            offset += 8;
            elementCount += 2;
          }
          if (this._uv7) {
            this._addVertexElement(new VertexElement("TEXCOORD_7", offset, exports3.VertexElementFormat.Vector2, 0));
            offset += 8;
            elementCount += 2;
          }
          if (attributeMode) {
            blendShapeManager._blendShapeCount > 0 && blendShapeManager._addVertexElements(this);
          }
          this._vertexSlotChanged = false;
          this._vertexStrideFloat = elementCount;
          return true;
        }
        return false;
      };
      _proto._updateVertices = function _updateVertices(vertices, force) {
        var _vertexStrideFloat = this._vertexStrideFloat, _vertexCount = this._vertexCount, _positions = this._positions, _normals = this._normals, _colors = this._colors, _vertexChangeFlag = this._vertexChangeFlag, _boneWeights = this._boneWeights, _boneIndices = this._boneIndices, _tangents = this._tangents, _uv = this._uv, _uv1 = this._uv1, _uv2 = this._uv2, _uv3 = this._uv3, _uv4 = this._uv4, _uv5 = this._uv5, _uv6 = this._uv6, _uv7 = this._uv7;
        force && (this._vertexChangeFlag = ValueChanged.All);
        if (_vertexChangeFlag & ValueChanged.Position) {
          for (var i = 0; i < _vertexCount; i++) {
            var start2 = _vertexStrideFloat * i;
            var position = _positions[i];
            vertices[start2] = position.x;
            vertices[start2 + 1] = position.y;
            vertices[start2 + 2] = position.z;
          }
        }
        var offset = 3;
        if (_normals) {
          if (_vertexChangeFlag & ValueChanged.Normal) {
            for (var _i = 0; _i < _vertexCount; _i++) {
              var _start = _vertexStrideFloat * _i + offset;
              var normal = _normals[_i];
              if (normal) {
                vertices[_start] = normal.x;
                vertices[_start + 1] = normal.y;
                vertices[_start + 2] = normal.z;
              }
            }
          }
          offset += 3;
        }
        if (_colors) {
          if (_vertexChangeFlag & ValueChanged.Color) {
            for (var _i2 = 0; _i2 < _vertexCount; _i2++) {
              var _start2 = _vertexStrideFloat * _i2 + offset;
              var color = _colors[_i2];
              if (color) {
                vertices[_start2] = color.r;
                vertices[_start2 + 1] = color.g;
                vertices[_start2 + 2] = color.b;
                vertices[_start2 + 3] = color.a;
              }
            }
          }
          offset += 4;
        }
        if (_boneWeights) {
          if (_vertexChangeFlag & ValueChanged.BoneWeight) {
            for (var _i3 = 0; _i3 < _vertexCount; _i3++) {
              var _start3 = _vertexStrideFloat * _i3 + offset;
              var weight = _boneWeights[_i3];
              if (weight) {
                vertices[_start3] = weight.x;
                vertices[_start3 + 1] = weight.y;
                vertices[_start3 + 2] = weight.z;
                vertices[_start3 + 3] = weight.w;
              }
            }
          }
          offset += 4;
        }
        if (_boneIndices) {
          if (_vertexChangeFlag & ValueChanged.BoneIndex) {
            var _verticesUint8 = this._verticesUint8;
            for (var _i4 = 0; _i4 < _vertexCount; _i4++) {
              var _start4 = _vertexStrideFloat * _i4 + offset;
              var joint = _boneIndices[_i4];
              if (joint) {
                var internalStart = _start4 * 4;
                _verticesUint8[internalStart] = joint.x;
                _verticesUint8[internalStart + 1] = joint.y;
                _verticesUint8[internalStart + 2] = joint.z;
                _verticesUint8[internalStart + 3] = joint.w;
              }
            }
          }
          offset += 1;
        }
        if (_tangents) {
          if (_vertexChangeFlag & ValueChanged.Tangent) {
            for (var _i5 = 0; _i5 < _vertexCount; _i5++) {
              var _start5 = _vertexStrideFloat * _i5 + offset;
              var tangent = _tangents[_i5];
              if (tangent) {
                vertices[_start5] = tangent.x;
                vertices[_start5 + 1] = tangent.y;
                vertices[_start5 + 2] = tangent.z;
                vertices[_start5 + 3] = tangent.w;
              }
            }
          }
          offset += 4;
        }
        if (_uv) {
          if (_vertexChangeFlag & ValueChanged.UV) {
            for (var _i6 = 0; _i6 < _vertexCount; _i6++) {
              var _start6 = _vertexStrideFloat * _i6 + offset;
              var _uv8 = _uv[_i6];
              if (_uv8) {
                vertices[_start6] = _uv8.x;
                vertices[_start6 + 1] = _uv8.y;
              }
            }
          }
          offset += 2;
        }
        if (_uv1) {
          if (_vertexChangeFlag & ValueChanged.UV1) {
            for (var _i7 = 0; _i7 < _vertexCount; _i7++) {
              var _start7 = _vertexStrideFloat * _i7 + offset;
              var _uv9 = _uv1[_i7];
              if (_uv9) {
                vertices[_start7] = _uv9.x;
                vertices[_start7 + 1] = _uv9.y;
              }
            }
          }
          offset += 2;
        }
        if (_uv2) {
          if (_vertexChangeFlag & ValueChanged.UV2) {
            for (var _i8 = 0; _i8 < _vertexCount; _i8++) {
              var _start8 = _vertexStrideFloat * _i8 + offset;
              var _uv10 = _uv2[_i8];
              if (_uv10) {
                vertices[_start8] = _uv10.x;
                vertices[_start8 + 1] = _uv10.y;
              }
            }
          }
          offset += 2;
        }
        if (_uv3) {
          if (_vertexChangeFlag & ValueChanged.UV3) {
            for (var _i9 = 0; _i9 < _vertexCount; _i9++) {
              var _start9 = _vertexStrideFloat * _i9 + offset;
              var _uv11 = _uv3[_i9];
              if (_uv11) {
                vertices[_start9] = _uv11.x;
                vertices[_start9 + 1] = _uv11.y;
              }
            }
          }
          offset += 2;
        }
        if (_uv4) {
          if (_vertexChangeFlag & ValueChanged.UV4) {
            for (var _i10 = 0; _i10 < _vertexCount; _i10++) {
              var _start10 = _vertexStrideFloat * _i10 + offset;
              var _uv12 = _uv4[_i10];
              if (_uv12) {
                vertices[_start10] = _uv12.x;
                vertices[_start10 + 1] = _uv12.y;
              }
            }
          }
          offset += 2;
        }
        if (_uv5) {
          if (_vertexChangeFlag & ValueChanged.UV5) {
            for (var _i11 = 0; _i11 < _vertexCount; _i11++) {
              var _start11 = _vertexStrideFloat * _i11 + offset;
              var _uv13 = _uv5[_i11];
              if (_uv13) {
                vertices[_start11] = _uv13.x;
                vertices[_start11 + 1] = _uv13.y;
              }
            }
          }
          offset += 2;
        }
        if (_uv6) {
          if (_vertexChangeFlag & ValueChanged.UV6) {
            for (var _i12 = 0; _i12 < _vertexCount; _i12++) {
              var _start12 = _vertexStrideFloat * _i12 + offset;
              var _uv14 = _uv6[_i12];
              if (_uv14) {
                vertices[_start12] = _uv14.x;
                vertices[_start12 + 1] = _uv14.y;
              }
            }
          }
          offset += 2;
        }
        if (_uv7) {
          if (_vertexChangeFlag & ValueChanged.UV7) {
            for (var _i13 = 0; _i13 < _vertexCount; _i13++) {
              var _start13 = _vertexStrideFloat * _i13 + offset;
              var _uv15 = _uv7[_i13];
              if (_uv15) {
                vertices[_start13] = _uv15.x;
                vertices[_start13 + 1] = _uv15.y;
              }
            }
          }
          offset += 2;
        }
        this._vertexChangeFlag = 0;
      };
      _proto._releaseCache = function _releaseCache() {
        this._verticesUint8 = null;
        this._indices = null;
        this._verticesFloat32 = null;
        this._positions.length = 0;
        this._tangents = null;
        this._normals = null;
        this._colors = null;
        this._uv = null;
        this._uv1 = null;
        this._uv2 = null;
        this._uv3 = null;
        this._uv4 = null;
        this._uv5 = null;
        this._uv6 = null;
        this._uv7 = null;
        this._blendShapeManager._releaseMemoryCache();
      };
      _createClass2(ModelMesh2, [{
        key: "accessible",
        get: function get() {
          return this._accessible;
        }
      }, {
        key: "vertexCount",
        get: function get() {
          return this._vertexCount;
        }
      }, {
        key: "blendShapes",
        get: function get() {
          if (!this._accessible) {
            throw "Not allowed to access data while accessible is false.";
          }
          return this._blendShapeManager._blendShapes;
        }
      }, {
        key: "blendShapeCount",
        get: function get() {
          return this._blendShapeManager._blendShapeCount;
        }
      }]);
      return ModelMesh2;
    }(Mesh);
    var POSITION_VERTEX_ELEMENT = new VertexElement("POSITION", 0, exports3.VertexElementFormat.Vector3, 0);
    var ValueChanged;
    (function(ValueChanged2) {
      ValueChanged2[ValueChanged2["Position"] = 1] = "Position";
      ValueChanged2[ValueChanged2["Normal"] = 2] = "Normal";
      ValueChanged2[ValueChanged2["Color"] = 4] = "Color";
      ValueChanged2[ValueChanged2["Tangent"] = 8] = "Tangent";
      ValueChanged2[ValueChanged2["BoneWeight"] = 16] = "BoneWeight";
      ValueChanged2[ValueChanged2["BoneIndex"] = 32] = "BoneIndex";
      ValueChanged2[ValueChanged2["UV"] = 64] = "UV";
      ValueChanged2[ValueChanged2["UV1"] = 128] = "UV1";
      ValueChanged2[ValueChanged2["UV2"] = 256] = "UV2";
      ValueChanged2[ValueChanged2["UV3"] = 512] = "UV3";
      ValueChanged2[ValueChanged2["UV4"] = 1024] = "UV4";
      ValueChanged2[ValueChanged2["UV5"] = 2048] = "UV5";
      ValueChanged2[ValueChanged2["UV6"] = 4096] = "UV6";
      ValueChanged2[ValueChanged2["UV7"] = 8192] = "UV7";
      ValueChanged2[ValueChanged2["All"] = 65535] = "All";
    })(ValueChanged || (ValueChanged = {}));
    var Skin = /* @__PURE__ */ function(_EngineObject) {
      _inheritsLoose2(Skin2, _EngineObject);
      function Skin2(name) {
        var _this;
        _this = _EngineObject.call(this, null) || this;
        _this.name = name;
        _this.inverseBindMatrices = void 0;
        _this.joints = void 0;
        _this.skeleton = void 0;
        _this.inverseBindMatrices = [];
        _this.joints = [];
        _this.skeleton = "none";
        return _this;
      }
      return Skin2;
    }(EngineObject);
    var _class$72, _descriptor$6, _descriptor2$6, _class2$6;
    var MeshRenderer = (_class$72 = (_class2$6 = /* @__PURE__ */ function(_Renderer) {
      _inheritsLoose2(MeshRenderer2, _Renderer);
      function MeshRenderer2(entity) {
        var _this;
        _this = _Renderer.call(this, entity) || this;
        _initializerDefineProperty(_this, "_mesh", _descriptor$6, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_meshUpdateFlag", _descriptor2$6, _assertThisInitialized(_this));
        return _this;
      }
      var _proto = MeshRenderer2.prototype;
      _proto._render = function _render(camera) {
        var mesh = this._mesh;
        if (mesh) {
          if (this._meshUpdateFlag.flag) {
            var shaderData = this.shaderData;
            var vertexElements = mesh._vertexElements;
            shaderData.disableMacro(MeshRenderer2._uvMacro);
            shaderData.disableMacro(MeshRenderer2._uv1Macro);
            shaderData.disableMacro(MeshRenderer2._normalMacro);
            shaderData.disableMacro(MeshRenderer2._tangentMacro);
            shaderData.disableMacro(MeshRenderer2._vertexColorMacro);
            for (var i = 0, n = vertexElements.length; i < n; i++) {
              var semantic = vertexElements[i].semantic;
              switch (semantic) {
                case "TEXCOORD_0":
                  shaderData.enableMacro(MeshRenderer2._uvMacro);
                  break;
                case "TEXCOORD_1":
                  shaderData.enableMacro(MeshRenderer2._uv1Macro);
                  break;
                case "NORMAL":
                  shaderData.enableMacro(MeshRenderer2._normalMacro);
                  break;
                case "TANGENT":
                  shaderData.enableMacro(MeshRenderer2._tangentMacro);
                  break;
                case "COLOR_0":
                  shaderData.enableMacro(MeshRenderer2._vertexColorMacro);
                  break;
              }
            }
            this._meshUpdateFlag.flag = false;
          }
          var subMeshes = mesh.subMeshes;
          var renderPipeline = camera._renderPipeline;
          var renderElementPool = this._engine._renderElementPool;
          for (var _i = 0, _n = subMeshes.length; _i < _n; _i++) {
            var material = this._materials[_i];
            if (material) {
              var element = renderElementPool.getFromPool();
              element.setValue(this, mesh, subMeshes[_i], material);
              renderPipeline.pushPrimitive(element);
            }
          }
        } else {
          Logger.error("mesh is null.");
        }
      };
      _proto._onDestroy = function _onDestroy() {
        _Renderer.prototype._onDestroy.call(this);
        var mesh = this._mesh;
        if (mesh && !mesh.destroyed) {
          mesh._addRefCount(-1);
          this._mesh = null;
        }
      };
      _proto._cloneTo = function _cloneTo(target) {
        target.mesh = this._mesh;
      };
      _proto._updateBounds = function _updateBounds(worldBounds) {
        var mesh = this._mesh;
        if (mesh) {
          var localBounds = mesh.bounds;
          var worldMatrix = this._entity.transform.worldMatrix;
          miniprogram2.BoundingBox.transform(localBounds, worldMatrix, worldBounds);
        } else {
          worldBounds.min.set(0, 0, 0);
          worldBounds.max.set(0, 0, 0);
        }
      };
      _proto._setMesh = function _setMesh(mesh) {
        var lastMesh = this._mesh;
        if (lastMesh) {
          lastMesh._addRefCount(-1);
          this._meshUpdateFlag.destroy();
        }
        if (mesh) {
          mesh._addRefCount(1);
          this._meshUpdateFlag = mesh.registerUpdateFlag();
        }
        this._mesh = mesh;
      };
      _createClass2(MeshRenderer2, [{
        key: "mesh",
        get: function get() {
          return this._mesh;
        },
        set: function set(mesh) {
          if (this._mesh !== mesh) {
            this._setMesh(mesh);
          }
        }
      }]);
      return MeshRenderer2;
    }(Renderer), _class2$6._uvMacro = Shader.getMacroByName("O3_HAS_UV"), _class2$6._uv1Macro = Shader.getMacroByName("O3_HAS_UV1"), _class2$6._normalMacro = Shader.getMacroByName("O3_HAS_NORMAL"), _class2$6._tangentMacro = Shader.getMacroByName("O3_HAS_TANGENT"), _class2$6._vertexColorMacro = Shader.getMacroByName("O3_HAS_VERTEXCOLOR"), _class2$6), _descriptor$6 = _applyDecoratedDescriptor(_class$72.prototype, "_mesh", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor2$6 = _applyDecoratedDescriptor(_class$72.prototype, "_meshUpdateFlag", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class$72);
    var _class$62, _descriptor$5, _descriptor2$5, _descriptor3$5, _descriptor4$5, _descriptor5$5, _descriptor6$5, _descriptor7$5, _descriptor8$5, _class2$5;
    var SkinnedMeshRenderer = (_class$62 = (_class2$5 = /* @__PURE__ */ function(_MeshRenderer) {
      _inheritsLoose2(SkinnedMeshRenderer2, _MeshRenderer);
      function SkinnedMeshRenderer2(entity) {
        var _this;
        _this = _MeshRenderer.call(this, entity) || this;
        _initializerDefineProperty(_this, "matrixPalette", _descriptor$5, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "jointNodes", _descriptor2$5, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "jointTexture", _descriptor3$5, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_hasInitJoints", _descriptor4$5, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_mat", _descriptor5$5, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_useJointTexture", _descriptor6$5, _assertThisInitialized(_this));
        _this._skin = void 0;
        _initializerDefineProperty(_this, "_blendShapeWeights", _descriptor7$5, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_condensedBlendShapeWeights", _descriptor8$5, _assertThisInitialized(_this));
        _this._mat = new miniprogram2.Matrix();
        _this._skin = null;
        return _this;
      }
      var _proto = SkinnedMeshRenderer2.prototype;
      _proto._updateShaderData = function _updateShaderData(context) {
        _MeshRenderer.prototype._updateShaderData.call(this, context);
        var shaderData = this.shaderData;
        if (!this._useJointTexture && this.matrixPalette) {
          shaderData.setFloatArray(SkinnedMeshRenderer2._jointMatrixProperty, this.matrixPalette);
        }
        var mesh = this.mesh;
        mesh._blendShapeManager._updateShaderData(shaderData, this);
      };
      _proto._initJoints = function _initJoints() {
        if (!this._skin)
          return;
        var skin = this._skin;
        var joints = skin.joints;
        var jointNodes = [];
        for (var i = joints.length - 1; i >= 0; i--) {
          jointNodes[i] = this.findByNodeName(this.entity, joints[i]);
        }
        this.matrixPalette = new Float32Array(jointNodes.length * 16);
        this.jointNodes = jointNodes;
        var rhi = this.entity.engine._hardwareRenderer;
        if (!rhi)
          return;
        var maxAttribUniformVec4 = rhi.renderStates.getParameter(rhi.gl.MAX_VERTEX_UNIFORM_VECTORS);
        var maxJoints = Math.floor((maxAttribUniformVec4 - 30) / 4);
        var shaderData = this.shaderData;
        var jointCount = jointNodes.length;
        if (jointCount) {
          shaderData.enableMacro("O3_HAS_SKIN");
          shaderData.setInt(SkinnedMeshRenderer2._jointCountProperty, jointCount);
          if (jointCount > maxJoints) {
            if (rhi.canIUseMoreJoints) {
              this._useJointTexture = true;
            } else {
              Logger.error("component's joints count(" + jointCount + ") greater than device's MAX_VERTEX_UNIFORM_VECTORS number " + maxAttribUniformVec4 + ", and don't support jointTexture in this device. suggest joint count less than " + maxJoints + ".", this);
            }
          } else {
            var _maxJoints = Math.max(SkinnedMeshRenderer2._maxJoints, jointCount);
            SkinnedMeshRenderer2._maxJoints = _maxJoints;
            shaderData.disableMacro("O3_USE_JOINT_TEXTURE");
            shaderData.enableMacro("O3_JOINTS_NUM", _maxJoints.toString());
          }
        } else {
          shaderData.disableMacro("O3_HAS_SKIN");
        }
      };
      _proto.findByNodeName = function findByNodeName(entity, nodeName) {
        if (!entity)
          return null;
        var n = entity.findByName(nodeName);
        if (n)
          return n;
        return this.findByNodeName(entity.parent, nodeName);
      };
      _proto.update = function update() {
        if (!this._hasInitJoints) {
          this._initJoints();
          this._hasInitJoints = true;
        }
        if (this._skin) {
          var joints = this.jointNodes;
          var ibms = this._skin.inverseBindMatrices;
          var matrixPalette = this.matrixPalette;
          var worldToLocal = this.entity.getInvModelMatrix();
          var mat = this._mat;
          for (var i = joints.length - 1; i >= 0; i--) {
            mat.identity();
            if (joints[i]) {
              miniprogram2.Matrix.multiply(joints[i].transform.worldMatrix, ibms[i], mat);
            } else {
              mat.copyFrom(ibms[i]);
            }
            miniprogram2.Matrix.multiply(worldToLocal, mat, mat);
            matrixPalette.set(mat.elements, i * 16);
          }
          if (this._useJointTexture) {
            this.createJointTexture();
          }
        }
      };
      _proto.createJointTexture = function createJointTexture() {
        if (!this.jointTexture) {
          var engine = this.engine;
          var rhi = engine._hardwareRenderer;
          if (!rhi)
            return;
          this.jointTexture = new Texture2D(engine, 4, this.jointNodes.length, exports3.TextureFormat.R32G32B32A32, false);
          this.jointTexture.filterMode = exports3.TextureFilterMode.Point;
          this.shaderData.enableMacro("O3_USE_JOINT_TEXTURE");
          this.shaderData.setTexture(SkinnedMeshRenderer2._jointSamplerProperty, this.jointTexture);
        }
        this.jointTexture.setPixelBuffer(this.matrixPalette);
      };
      _proto._cloneTo = function _cloneTo(target) {
        _MeshRenderer.prototype._cloneTo.call(this, target);
        this._blendShapeWeights && (target._blendShapeWeights = this._blendShapeWeights.slice());
      };
      _proto._checkBlendShapeWeightLength = function _checkBlendShapeWeightLength() {
        var mesh = this._mesh;
        var newBlendShapeCount = mesh ? mesh.blendShapeCount : 0;
        var lastBlendShapeWeights = this._blendShapeWeights;
        if (lastBlendShapeWeights) {
          if (lastBlendShapeWeights.length !== newBlendShapeCount) {
            var newBlendShapeWeights = new Float32Array(newBlendShapeCount);
            if (newBlendShapeCount > lastBlendShapeWeights.length) {
              newBlendShapeWeights.set(lastBlendShapeWeights);
            } else {
              for (var i = 0, n = lastBlendShapeWeights.length; i < n; i++) {
                lastBlendShapeWeights[i] = newBlendShapeWeights[i];
              }
            }
            this._blendShapeWeights = newBlendShapeWeights;
          }
        } else {
          this._blendShapeWeights = new Float32Array(newBlendShapeCount);
        }
      };
      _createClass2(SkinnedMeshRenderer2, [{
        key: "blendShapeWeights",
        get: function get() {
          this._checkBlendShapeWeightLength();
          return this._blendShapeWeights;
        },
        set: function set(value) {
          this._checkBlendShapeWeightLength();
          var blendShapeWeights = this._blendShapeWeights;
          if (value.length <= blendShapeWeights.length) {
            blendShapeWeights.set(value);
          } else {
            for (var i = 0, n = blendShapeWeights.length; i < n; i++) {
              blendShapeWeights[i] = value[i];
            }
          }
        }
      }, {
        key: "skin",
        get: function get() {
          return this._skin;
        },
        set: function set(skin) {
          this._skin = skin;
        }
      }]);
      return SkinnedMeshRenderer2;
    }(MeshRenderer), _class2$5._jointCountProperty = Shader.getPropertyByName("u_jointCount"), _class2$5._jointSamplerProperty = Shader.getPropertyByName("u_jointSampler"), _class2$5._jointMatrixProperty = Shader.getPropertyByName("u_jointMatrix"), _class2$5._maxJoints = 0, _class2$5), _descriptor$5 = _applyDecoratedDescriptor(_class$62.prototype, "matrixPalette", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor2$5 = _applyDecoratedDescriptor(_class$62.prototype, "jointNodes", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor3$5 = _applyDecoratedDescriptor(_class$62.prototype, "jointTexture", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor4$5 = _applyDecoratedDescriptor(_class$62.prototype, "_hasInitJoints", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor5$5 = _applyDecoratedDescriptor(_class$62.prototype, "_mat", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor6$5 = _applyDecoratedDescriptor(_class$62.prototype, "_useJointTexture", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor7$5 = _applyDecoratedDescriptor(_class$62.prototype, "_blendShapeWeights", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor8$5 = _applyDecoratedDescriptor(_class$62.prototype, "_condensedBlendShapeWeights", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class$62);
    var PrimitiveMesh = /* @__PURE__ */ function() {
      function PrimitiveMesh2() {
      }
      PrimitiveMesh2.createSphere = function createSphere(engine, radius, segments, noLongerAccessible) {
        if (radius === void 0) {
          radius = 0.5;
        }
        if (segments === void 0) {
          segments = 18;
        }
        if (noLongerAccessible === void 0) {
          noLongerAccessible = true;
        }
        var mesh = new ModelMesh(engine);
        segments = Math.max(2, Math.floor(segments));
        var count = segments + 1;
        var vertexCount = count * count;
        var rectangleCount = segments * segments;
        var indices = PrimitiveMesh2._generateIndices(engine, vertexCount, rectangleCount * 6);
        var thetaRange = Math.PI;
        var alphaRange = thetaRange * 2;
        var countReciprocal = 1 / count;
        var segmentsReciprocal = 1 / segments;
        var positions = new Array(vertexCount);
        var normals = new Array(vertexCount);
        var uvs = new Array(vertexCount);
        for (var i = 0; i < vertexCount; ++i) {
          var x = i % count;
          var y = i * countReciprocal | 0;
          var u = x * segmentsReciprocal;
          var v = y * segmentsReciprocal;
          var alphaDelta = u * alphaRange;
          var thetaDelta = v * thetaRange;
          var sinTheta = Math.sin(thetaDelta);
          var posX = -radius * Math.cos(alphaDelta) * sinTheta;
          var posY = radius * Math.cos(thetaDelta);
          var posZ = radius * Math.sin(alphaDelta) * sinTheta;
          positions[i] = new miniprogram2.Vector3(posX, posY, posZ);
          normals[i] = new miniprogram2.Vector3(posX, posY, posZ);
          uvs[i] = new miniprogram2.Vector2(u, v);
        }
        var offset = 0;
        for (var _i = 0; _i < rectangleCount; ++_i) {
          var _x = _i % segments;
          var _y = _i * segmentsReciprocal | 0;
          var a = _y * count + _x;
          var b = a + 1;
          var c = a + count;
          var d = c + 1;
          indices[offset++] = b;
          indices[offset++] = a;
          indices[offset++] = d;
          indices[offset++] = a;
          indices[offset++] = c;
          indices[offset++] = d;
        }
        var bounds = mesh.bounds;
        bounds.min.set(-radius, -radius, -radius);
        bounds.max.set(radius, radius, radius);
        PrimitiveMesh2._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
        return mesh;
      };
      PrimitiveMesh2.createCuboid = function createCuboid(engine, width, height, depth, noLongerAccessible) {
        if (width === void 0) {
          width = 1;
        }
        if (height === void 0) {
          height = 1;
        }
        if (depth === void 0) {
          depth = 1;
        }
        if (noLongerAccessible === void 0) {
          noLongerAccessible = true;
        }
        var mesh = new ModelMesh(engine);
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var halfDepth = depth / 2;
        var positions = new Array(24);
        var normals = new Array(24);
        var uvs = new Array(24);
        positions[0] = new miniprogram2.Vector3(-halfWidth, halfHeight, -halfDepth);
        positions[1] = new miniprogram2.Vector3(halfWidth, halfHeight, -halfDepth);
        positions[2] = new miniprogram2.Vector3(halfWidth, halfHeight, halfDepth);
        positions[3] = new miniprogram2.Vector3(-halfWidth, halfHeight, halfDepth);
        normals[0] = new miniprogram2.Vector3(0, 1, 0);
        normals[1] = new miniprogram2.Vector3(0, 1, 0);
        normals[2] = new miniprogram2.Vector3(0, 1, 0);
        normals[3] = new miniprogram2.Vector3(0, 1, 0);
        uvs[0] = new miniprogram2.Vector2(0, 0);
        uvs[1] = new miniprogram2.Vector2(1, 0);
        uvs[2] = new miniprogram2.Vector2(1, 1);
        uvs[3] = new miniprogram2.Vector2(0, 1);
        positions[4] = new miniprogram2.Vector3(-halfWidth, -halfHeight, -halfDepth);
        positions[5] = new miniprogram2.Vector3(halfWidth, -halfHeight, -halfDepth);
        positions[6] = new miniprogram2.Vector3(halfWidth, -halfHeight, halfDepth);
        positions[7] = new miniprogram2.Vector3(-halfWidth, -halfHeight, halfDepth);
        normals[4] = new miniprogram2.Vector3(0, -1, 0);
        normals[5] = new miniprogram2.Vector3(0, -1, 0);
        normals[6] = new miniprogram2.Vector3(0, -1, 0);
        normals[7] = new miniprogram2.Vector3(0, -1, 0);
        uvs[4] = new miniprogram2.Vector2(0, 1);
        uvs[5] = new miniprogram2.Vector2(1, 1);
        uvs[6] = new miniprogram2.Vector2(1, 0);
        uvs[7] = new miniprogram2.Vector2(0, 0);
        positions[8] = new miniprogram2.Vector3(-halfWidth, halfHeight, -halfDepth);
        positions[9] = new miniprogram2.Vector3(-halfWidth, halfHeight, halfDepth);
        positions[10] = new miniprogram2.Vector3(-halfWidth, -halfHeight, halfDepth);
        positions[11] = new miniprogram2.Vector3(-halfWidth, -halfHeight, -halfDepth);
        normals[8] = new miniprogram2.Vector3(-1, 0, 0);
        normals[9] = new miniprogram2.Vector3(-1, 0, 0);
        normals[10] = new miniprogram2.Vector3(-1, 0, 0);
        normals[11] = new miniprogram2.Vector3(-1, 0, 0);
        uvs[8] = new miniprogram2.Vector2(0, 0);
        uvs[9] = new miniprogram2.Vector2(1, 0);
        uvs[10] = new miniprogram2.Vector2(1, 1);
        uvs[11] = new miniprogram2.Vector2(0, 1);
        positions[12] = new miniprogram2.Vector3(halfWidth, halfHeight, -halfDepth);
        positions[13] = new miniprogram2.Vector3(halfWidth, halfHeight, halfDepth);
        positions[14] = new miniprogram2.Vector3(halfWidth, -halfHeight, halfDepth);
        positions[15] = new miniprogram2.Vector3(halfWidth, -halfHeight, -halfDepth);
        normals[12] = new miniprogram2.Vector3(1, 0, 0);
        normals[13] = new miniprogram2.Vector3(1, 0, 0);
        normals[14] = new miniprogram2.Vector3(1, 0, 0);
        normals[15] = new miniprogram2.Vector3(1, 0, 0);
        uvs[12] = new miniprogram2.Vector2(1, 0);
        uvs[13] = new miniprogram2.Vector2(0, 0);
        uvs[14] = new miniprogram2.Vector2(0, 1);
        uvs[15] = new miniprogram2.Vector2(1, 1);
        positions[16] = new miniprogram2.Vector3(-halfWidth, halfHeight, halfDepth);
        positions[17] = new miniprogram2.Vector3(halfWidth, halfHeight, halfDepth);
        positions[18] = new miniprogram2.Vector3(halfWidth, -halfHeight, halfDepth);
        positions[19] = new miniprogram2.Vector3(-halfWidth, -halfHeight, halfDepth);
        normals[16] = new miniprogram2.Vector3(0, 0, 1);
        normals[17] = new miniprogram2.Vector3(0, 0, 1);
        normals[18] = new miniprogram2.Vector3(0, 0, 1);
        normals[19] = new miniprogram2.Vector3(0, 0, 1);
        uvs[16] = new miniprogram2.Vector2(0, 0);
        uvs[17] = new miniprogram2.Vector2(1, 0);
        uvs[18] = new miniprogram2.Vector2(1, 1);
        uvs[19] = new miniprogram2.Vector2(0, 1);
        positions[20] = new miniprogram2.Vector3(-halfWidth, halfHeight, -halfDepth);
        positions[21] = new miniprogram2.Vector3(halfWidth, halfHeight, -halfDepth);
        positions[22] = new miniprogram2.Vector3(halfWidth, -halfHeight, -halfDepth);
        positions[23] = new miniprogram2.Vector3(-halfWidth, -halfHeight, -halfDepth);
        normals[20] = new miniprogram2.Vector3(0, 0, -1);
        normals[21] = new miniprogram2.Vector3(0, 0, -1);
        normals[22] = new miniprogram2.Vector3(0, 0, -1);
        normals[23] = new miniprogram2.Vector3(0, 0, -1);
        uvs[20] = new miniprogram2.Vector2(1, 0);
        uvs[21] = new miniprogram2.Vector2(0, 0);
        uvs[22] = new miniprogram2.Vector2(0, 1);
        uvs[23] = new miniprogram2.Vector2(1, 1);
        var indices = new Uint16Array(36);
        indices[0] = 0, indices[1] = 2, indices[2] = 1, indices[3] = 2, indices[4] = 0, indices[5] = 3, indices[6] = 4, indices[7] = 6, indices[8] = 7, indices[9] = 6, indices[10] = 4, indices[11] = 5, indices[12] = 8, indices[13] = 10, indices[14] = 9, indices[15] = 10, indices[16] = 8, indices[17] = 11, indices[18] = 12, indices[19] = 14, indices[20] = 15, indices[21] = 14, indices[22] = 12, indices[23] = 13, indices[24] = 16, indices[25] = 18, indices[26] = 17, indices[27] = 18, indices[28] = 16, indices[29] = 19, indices[30] = 20, indices[31] = 22, indices[32] = 23, indices[33] = 22, indices[34] = 20, indices[35] = 21;
        var bounds = mesh.bounds;
        bounds.min.set(-halfWidth, -halfHeight, -halfDepth);
        bounds.max.set(halfWidth, halfHeight, halfDepth);
        PrimitiveMesh2._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
        return mesh;
      };
      PrimitiveMesh2.createPlane = function createPlane(engine, width, height, horizontalSegments, verticalSegments, noLongerAccessible) {
        if (width === void 0) {
          width = 1;
        }
        if (height === void 0) {
          height = 1;
        }
        if (horizontalSegments === void 0) {
          horizontalSegments = 1;
        }
        if (verticalSegments === void 0) {
          verticalSegments = 1;
        }
        if (noLongerAccessible === void 0) {
          noLongerAccessible = true;
        }
        var mesh = new ModelMesh(engine);
        horizontalSegments = Math.max(1, Math.floor(horizontalSegments));
        verticalSegments = Math.max(1, Math.floor(verticalSegments));
        var horizontalCount = horizontalSegments + 1;
        var verticalCount = verticalSegments + 1;
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var gridWidth = width / horizontalSegments;
        var gridHeight = height / verticalSegments;
        var vertexCount = horizontalCount * verticalCount;
        var rectangleCount = verticalSegments * horizontalSegments;
        var indices = PrimitiveMesh2._generateIndices(engine, vertexCount, rectangleCount * 6);
        var horizontalCountReciprocal = 1 / horizontalCount;
        var horizontalSegmentsReciprocal = 1 / horizontalSegments;
        var verticalSegmentsReciprocal = 1 / verticalSegments;
        var positions = new Array(vertexCount);
        var normals = new Array(vertexCount);
        var uvs = new Array(vertexCount);
        for (var i = 0; i < vertexCount; ++i) {
          var x = i % horizontalCount;
          var z = i * horizontalCountReciprocal | 0;
          positions[i] = new miniprogram2.Vector3(x * gridWidth - halfWidth, 0, z * gridHeight - halfHeight);
          normals[i] = new miniprogram2.Vector3(0, 1, 0);
          uvs[i] = new miniprogram2.Vector2(x * horizontalSegmentsReciprocal, z * verticalSegmentsReciprocal);
        }
        var offset = 0;
        for (var _i2 = 0; _i2 < rectangleCount; ++_i2) {
          var _x2 = _i2 % horizontalSegments;
          var y = _i2 * horizontalSegmentsReciprocal | 0;
          var a = y * horizontalCount + _x2;
          var b = a + 1;
          var c = a + horizontalCount;
          var d = c + 1;
          indices[offset++] = a;
          indices[offset++] = c;
          indices[offset++] = b;
          indices[offset++] = c;
          indices[offset++] = d;
          indices[offset++] = b;
        }
        var bounds = mesh.bounds;
        bounds.min.set(-halfWidth, 0, -halfHeight);
        bounds.max.set(halfWidth, 0, halfHeight);
        PrimitiveMesh2._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
        return mesh;
      };
      PrimitiveMesh2.createCylinder = function createCylinder(engine, radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible) {
        if (radiusTop === void 0) {
          radiusTop = 0.5;
        }
        if (radiusBottom === void 0) {
          radiusBottom = 0.5;
        }
        if (height === void 0) {
          height = 2;
        }
        if (radialSegments === void 0) {
          radialSegments = 20;
        }
        if (heightSegments === void 0) {
          heightSegments = 1;
        }
        if (noLongerAccessible === void 0) {
          noLongerAccessible = true;
        }
        var mesh = new ModelMesh(engine);
        radialSegments = Math.floor(radialSegments);
        heightSegments = Math.floor(heightSegments);
        var radialCount = radialSegments + 1;
        var verticalCount = heightSegments + 1;
        var halfHeight = height * 0.5;
        var unitHeight = height / heightSegments;
        var torsoVertexCount = radialCount * verticalCount;
        var torsoRectangleCount = radialSegments * heightSegments;
        var capTriangleCount = radialSegments * 2;
        var totalVertexCount = torsoVertexCount + 2 + capTriangleCount;
        var indices = PrimitiveMesh2._generateIndices(engine, totalVertexCount, torsoRectangleCount * 6 + capTriangleCount * 3);
        var radialCountReciprocal = 1 / radialCount;
        var radialSegmentsReciprocal = 1 / radialSegments;
        var heightSegmentsReciprocal = 1 / heightSegments;
        var positions = new Array(totalVertexCount);
        var normals = new Array(totalVertexCount);
        var uvs = new Array(totalVertexCount);
        var indicesOffset = 0;
        var thetaStart = Math.PI;
        var thetaRange = Math.PI * 2;
        var radiusDiff = radiusBottom - radiusTop;
        var slope = radiusDiff / height;
        var radiusSlope = radiusDiff / heightSegments;
        for (var i = 0; i < torsoVertexCount; ++i) {
          var x = i % radialCount;
          var y = i * radialCountReciprocal | 0;
          var u = x * radialSegmentsReciprocal;
          var v = y * heightSegmentsReciprocal;
          var theta = thetaStart + u * thetaRange;
          var sinTheta = Math.sin(theta);
          var cosTheta = Math.cos(theta);
          var radius = radiusBottom - y * radiusSlope;
          var posX = radius * sinTheta;
          var posY = y * unitHeight - halfHeight;
          var posZ = radius * cosTheta;
          positions[i] = new miniprogram2.Vector3(posX, posY, posZ);
          normals[i] = new miniprogram2.Vector3(sinTheta, slope, cosTheta);
          uvs[i] = new miniprogram2.Vector2(u, 1 - v);
        }
        for (var _i3 = 0; _i3 < torsoRectangleCount; ++_i3) {
          var _x3 = _i3 % radialSegments;
          var _y2 = _i3 * radialSegmentsReciprocal | 0;
          var a = _y2 * radialCount + _x3;
          var b = a + 1;
          var c = a + radialCount;
          var d = c + 1;
          indices[indicesOffset++] = b;
          indices[indicesOffset++] = c;
          indices[indicesOffset++] = a;
          indices[indicesOffset++] = b;
          indices[indicesOffset++] = d;
          indices[indicesOffset++] = c;
        }
        positions[torsoVertexCount] = new miniprogram2.Vector3(0, -halfHeight, 0);
        normals[torsoVertexCount] = new miniprogram2.Vector3(0, -1, 0);
        uvs[torsoVertexCount] = new miniprogram2.Vector2(0.5, 0.5);
        positions[torsoVertexCount + 1] = new miniprogram2.Vector3(0, halfHeight, 0);
        normals[torsoVertexCount + 1] = new miniprogram2.Vector3(0, 1, 0);
        uvs[torsoVertexCount + 1] = new miniprogram2.Vector2(0.5, 0.5);
        var offset = torsoVertexCount + 2;
        var diameterTopReciprocal = 1 / (radiusTop * 2);
        var diameterBottomReciprocal = 1 / (radiusBottom * 2);
        var positionStride = radialCount * heightSegments;
        for (var _i4 = 0; _i4 < radialSegments; ++_i4) {
          var curPosBottom = positions[_i4];
          var curPosX = curPosBottom.x;
          var curPosZ = curPosBottom.z;
          positions[offset] = new miniprogram2.Vector3(curPosX, -halfHeight, curPosZ);
          normals[offset] = new miniprogram2.Vector3(0, -1, 0);
          uvs[offset++] = new miniprogram2.Vector2(curPosX * diameterBottomReciprocal + 0.5, 0.5 - curPosZ * diameterBottomReciprocal);
          var curPosTop = positions[_i4 + positionStride];
          curPosX = curPosTop.x;
          curPosZ = curPosTop.z;
          positions[offset] = new miniprogram2.Vector3(curPosX, halfHeight, curPosZ);
          normals[offset] = new miniprogram2.Vector3(0, 1, 0);
          uvs[offset++] = new miniprogram2.Vector2(curPosX * diameterTopReciprocal + 0.5, curPosZ * diameterTopReciprocal + 0.5);
        }
        var topCapIndex = torsoVertexCount + 1;
        var bottomIndiceIndex = torsoVertexCount + 2;
        var topIndiceIndex = bottomIndiceIndex + 1;
        for (var _i5 = 0; _i5 < radialSegments; ++_i5) {
          var firstStride = _i5 * 2;
          var secondStride = _i5 === radialSegments - 1 ? 0 : firstStride + 2;
          indices[indicesOffset++] = torsoVertexCount;
          indices[indicesOffset++] = bottomIndiceIndex + secondStride;
          indices[indicesOffset++] = bottomIndiceIndex + firstStride;
          indices[indicesOffset++] = topCapIndex;
          indices[indicesOffset++] = topIndiceIndex + firstStride;
          indices[indicesOffset++] = topIndiceIndex + secondStride;
        }
        var bounds = mesh.bounds;
        var radiusMax = Math.max(radiusTop, radiusBottom);
        bounds.min.set(-radiusMax, -halfHeight, -radiusMax);
        bounds.max.set(radiusMax, halfHeight, radiusMax);
        PrimitiveMesh2._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
        return mesh;
      };
      PrimitiveMesh2.createTorus = function createTorus(engine, radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible) {
        if (radius === void 0) {
          radius = 0.5;
        }
        if (tubeRadius === void 0) {
          tubeRadius = 0.1;
        }
        if (radialSegments === void 0) {
          radialSegments = 30;
        }
        if (tubularSegments === void 0) {
          tubularSegments = 30;
        }
        if (arc === void 0) {
          arc = 360;
        }
        if (noLongerAccessible === void 0) {
          noLongerAccessible = true;
        }
        var mesh = new ModelMesh(engine);
        radialSegments = Math.floor(radialSegments);
        tubularSegments = Math.floor(tubularSegments);
        var vertexCount = (radialSegments + 1) * (tubularSegments + 1);
        var rectangleCount = radialSegments * tubularSegments;
        var indices = PrimitiveMesh2._generateIndices(engine, vertexCount, rectangleCount * 6);
        var positions = new Array(vertexCount);
        var normals = new Array(vertexCount);
        var uvs = new Array(vertexCount);
        arc = arc / 180 * Math.PI;
        var offset = 0;
        for (var i = 0; i <= radialSegments; i++) {
          for (var j = 0; j <= tubularSegments; j++) {
            var u = j / tubularSegments * arc;
            var v = i / radialSegments * Math.PI * 2;
            var cosV = Math.cos(v);
            var sinV = Math.sin(v);
            var cosU = Math.cos(u);
            var sinU = Math.sin(u);
            var position = new miniprogram2.Vector3((radius + tubeRadius * cosV) * cosU, (radius + tubeRadius * cosV) * sinU, tubeRadius * sinV);
            positions[offset] = position;
            var centerX = radius * cosU;
            var centerY = radius * sinU;
            normals[offset] = new miniprogram2.Vector3(position.x - centerX, position.y - centerY, position.z).normalize();
            uvs[offset++] = new miniprogram2.Vector2(j / tubularSegments, i / radialSegments);
          }
        }
        offset = 0;
        for (var _i6 = 1; _i6 <= radialSegments; _i6++) {
          for (var _j = 1; _j <= tubularSegments; _j++) {
            var a = (tubularSegments + 1) * _i6 + _j - 1;
            var b = (tubularSegments + 1) * (_i6 - 1) + _j - 1;
            var c = (tubularSegments + 1) * (_i6 - 1) + _j;
            var d = (tubularSegments + 1) * _i6 + _j;
            indices[offset++] = a;
            indices[offset++] = b;
            indices[offset++] = d;
            indices[offset++] = b;
            indices[offset++] = c;
            indices[offset++] = d;
          }
        }
        var bounds = mesh.bounds;
        var outerRadius = radius + tubeRadius;
        bounds.min.set(-outerRadius, -outerRadius, -tubeRadius);
        bounds.max.set(outerRadius, outerRadius, tubeRadius);
        PrimitiveMesh2._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
        return mesh;
      };
      PrimitiveMesh2.createCone = function createCone(engine, radius, height, radialSegments, heightSegments, noLongerAccessible) {
        if (radius === void 0) {
          radius = 0.5;
        }
        if (height === void 0) {
          height = 2;
        }
        if (radialSegments === void 0) {
          radialSegments = 20;
        }
        if (heightSegments === void 0) {
          heightSegments = 1;
        }
        if (noLongerAccessible === void 0) {
          noLongerAccessible = true;
        }
        var mesh = new ModelMesh(engine);
        radialSegments = Math.floor(radialSegments);
        heightSegments = Math.floor(heightSegments);
        var radialCount = radialSegments + 1;
        var verticalCount = heightSegments + 1;
        var halfHeight = height * 0.5;
        var unitHeight = height / heightSegments;
        var torsoVertexCount = radialCount * verticalCount;
        var torsoRectangleCount = radialSegments * heightSegments;
        var totalVertexCount = torsoVertexCount + 1 + radialSegments;
        var indices = PrimitiveMesh2._generateIndices(engine, totalVertexCount, torsoRectangleCount * 6 + radialSegments * 3);
        var radialCountReciprocal = 1 / radialCount;
        var radialSegmentsReciprocal = 1 / radialSegments;
        var heightSegmentsReciprocal = 1 / heightSegments;
        var positions = new Array(totalVertexCount);
        var normals = new Array(totalVertexCount);
        var uvs = new Array(totalVertexCount);
        var indicesOffset = 0;
        var thetaStart = Math.PI;
        var thetaRange = Math.PI * 2;
        var slope = radius / height;
        for (var i = 0; i < torsoVertexCount; ++i) {
          var x = i % radialCount;
          var y = i * radialCountReciprocal | 0;
          var u = x * radialSegmentsReciprocal;
          var v = y * heightSegmentsReciprocal;
          var theta = thetaStart + u * thetaRange;
          var sinTheta = Math.sin(theta);
          var cosTheta = Math.cos(theta);
          var curRadius = radius - y * radius;
          var posX = curRadius * sinTheta;
          var posY = y * unitHeight - halfHeight;
          var posZ = curRadius * cosTheta;
          positions[i] = new miniprogram2.Vector3(posX, posY, posZ);
          normals[i] = new miniprogram2.Vector3(sinTheta, slope, cosTheta);
          uvs[i] = new miniprogram2.Vector2(u, 1 - v);
        }
        for (var _i7 = 0; _i7 < torsoRectangleCount; ++_i7) {
          var _x4 = _i7 % radialSegments;
          var _y3 = _i7 * radialSegmentsReciprocal | 0;
          var a = _y3 * radialCount + _x4;
          var b = a + 1;
          var c = a + radialCount;
          var d = c + 1;
          indices[indicesOffset++] = b;
          indices[indicesOffset++] = c;
          indices[indicesOffset++] = a;
          indices[indicesOffset++] = b;
          indices[indicesOffset++] = d;
          indices[indicesOffset++] = c;
        }
        positions[torsoVertexCount] = new miniprogram2.Vector3(0, -halfHeight, 0);
        normals[torsoVertexCount] = new miniprogram2.Vector3(0, -1, 0);
        uvs[torsoVertexCount] = new miniprogram2.Vector2(0.5, 0.5);
        var offset = torsoVertexCount + 1;
        var diameterBottomReciprocal = 1 / (radius * 2);
        for (var _i8 = 0; _i8 < radialSegments; ++_i8) {
          var curPos = positions[_i8];
          var curPosX = curPos.x;
          var curPosZ = curPos.z;
          positions[offset] = new miniprogram2.Vector3(curPosX, -halfHeight, curPosZ);
          normals[offset] = new miniprogram2.Vector3(0, -1, 0);
          uvs[offset++] = new miniprogram2.Vector2(curPosX * diameterBottomReciprocal + 0.5, 0.5 - curPosZ * diameterBottomReciprocal);
        }
        var bottomIndiceIndex = torsoVertexCount + 1;
        for (var _i9 = 0; _i9 < radialSegments; ++_i9) {
          var firstStride = _i9;
          var secondStride = _i9 === radialSegments - 1 ? 0 : firstStride + 1;
          indices[indicesOffset++] = torsoVertexCount;
          indices[indicesOffset++] = bottomIndiceIndex + secondStride;
          indices[indicesOffset++] = bottomIndiceIndex + firstStride;
        }
        var bounds = mesh.bounds;
        bounds.min.set(-radius, -halfHeight, -radius);
        bounds.max.set(radius, halfHeight, radius);
        PrimitiveMesh2._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
        return mesh;
      };
      PrimitiveMesh2.createCapsule = function createCapsule(engine, radius, height, radialSegments, heightSegments, noLongerAccessible) {
        if (radius === void 0) {
          radius = 0.5;
        }
        if (height === void 0) {
          height = 2;
        }
        if (radialSegments === void 0) {
          radialSegments = 6;
        }
        if (heightSegments === void 0) {
          heightSegments = 1;
        }
        if (noLongerAccessible === void 0) {
          noLongerAccessible = true;
        }
        var mesh = new ModelMesh(engine);
        radialSegments = Math.max(2, Math.floor(radialSegments));
        heightSegments = Math.floor(heightSegments);
        var radialCount = radialSegments + 1;
        var verticalCount = heightSegments + 1;
        var halfHeight = height * 0.5;
        var unitHeight = height / heightSegments;
        var torsoVertexCount = radialCount * verticalCount;
        var torsoRectangleCount = radialSegments * heightSegments;
        var capVertexCount = radialCount * radialCount;
        var capRectangleCount = radialSegments * radialSegments;
        var totalVertexCount = torsoVertexCount + 2 * capVertexCount;
        var indices = PrimitiveMesh2._generateIndices(engine, totalVertexCount, (torsoRectangleCount + 2 * capRectangleCount) * 6);
        var radialCountReciprocal = 1 / radialCount;
        var radialSegmentsReciprocal = 1 / radialSegments;
        var heightSegmentsReciprocal = 1 / heightSegments;
        var thetaStart = Math.PI;
        var thetaRange = Math.PI * 2;
        var positions = new Array(totalVertexCount);
        var normals = new Array(totalVertexCount);
        var uvs = new Array(totalVertexCount);
        var indicesOffset = 0;
        for (var i = 0; i < torsoVertexCount; ++i) {
          var x = i % radialCount;
          var y = i * radialCountReciprocal | 0;
          var u = x * radialSegmentsReciprocal;
          var v = y * heightSegmentsReciprocal;
          var theta = thetaStart + u * thetaRange;
          var sinTheta = Math.sin(theta);
          var cosTheta = Math.cos(theta);
          positions[i] = new miniprogram2.Vector3(radius * sinTheta, y * unitHeight - halfHeight, radius * cosTheta);
          normals[i] = new miniprogram2.Vector3(sinTheta, 0, cosTheta);
          uvs[i] = new miniprogram2.Vector2(u, 1 - v);
        }
        for (var _i10 = 0; _i10 < torsoRectangleCount; ++_i10) {
          var _x5 = _i10 % radialSegments;
          var _y4 = _i10 * radialSegmentsReciprocal | 0;
          var a = _y4 * radialCount + _x5;
          var b = a + 1;
          var c = a + radialCount;
          var d = c + 1;
          indices[indicesOffset++] = b;
          indices[indicesOffset++] = c;
          indices[indicesOffset++] = a;
          indices[indicesOffset++] = b;
          indices[indicesOffset++] = d;
          indices[indicesOffset++] = c;
        }
        PrimitiveMesh2._createCapsuleCap(radius, height, radialSegments, thetaRange, torsoVertexCount, 1, positions, normals, uvs, indices, indicesOffset);
        PrimitiveMesh2._createCapsuleCap(radius, height, radialSegments, -thetaRange, torsoVertexCount + capVertexCount, -1, positions, normals, uvs, indices, indicesOffset + 6 * capRectangleCount);
        var bounds = mesh.bounds;
        bounds.min.set(-radius, -radius - halfHeight, -radius);
        bounds.max.set(radius, radius + halfHeight, radius);
        PrimitiveMesh2._initialize(mesh, positions, normals, uvs, indices, noLongerAccessible);
        return mesh;
      };
      PrimitiveMesh2._initialize = function _initialize(mesh, positions, normals, uvs, indices, noLongerAccessible) {
        mesh.setPositions(positions);
        mesh.setNormals(normals);
        mesh.setUVs(uvs);
        mesh.setIndices(indices);
        mesh.uploadData(noLongerAccessible);
        mesh.addSubMesh(0, indices.length);
      };
      PrimitiveMesh2._generateIndices = function _generateIndices(engine, vertexCount, indexCount) {
        var indices = null;
        if (vertexCount > 65535) {
          if (engine._hardwareRenderer.canIUse(exports3.GLCapabilityType.elementIndexUint)) {
            indices = new Uint32Array(indexCount);
          } else {
            throw Error("The vertex count is over limit.");
          }
        } else {
          indices = new Uint16Array(indexCount);
        }
        return indices;
      };
      PrimitiveMesh2._createCapsuleCap = function _createCapsuleCap(radius, height, radialSegments, capAlphaRange, offset, posIndex, positions, normals, uvs, indices, indicesOffset) {
        var radialCount = radialSegments + 1;
        var halfHeight = height * 0.5 * posIndex;
        var capVertexCount = radialCount * radialCount;
        var capRectangleCount = radialSegments * radialSegments;
        var radialCountReciprocal = 1 / radialCount;
        var radialSegmentsReciprocal = 1 / radialSegments;
        for (var i = 0; i < capVertexCount; ++i) {
          var x = i % radialCount;
          var y = i * radialCountReciprocal | 0;
          var u = x * radialSegmentsReciprocal;
          var v = y * radialSegmentsReciprocal;
          var alphaDelta = u * capAlphaRange;
          var thetaDelta = v * Math.PI / 2;
          var sinTheta = Math.sin(thetaDelta);
          var posX = -radius * Math.cos(alphaDelta) * sinTheta;
          var posY = radius * Math.cos(thetaDelta) * posIndex + halfHeight;
          var posZ = radius * Math.sin(alphaDelta) * sinTheta;
          var index = i + offset;
          positions[index] = new miniprogram2.Vector3(posX, posY, posZ);
          normals[index] = new miniprogram2.Vector3(posX, posY - halfHeight, posZ);
          uvs[index] = new miniprogram2.Vector2(u, v);
        }
        for (var _i11 = 0; _i11 < capRectangleCount; ++_i11) {
          var _x6 = _i11 % radialSegments;
          var _y5 = _i11 * radialSegmentsReciprocal | 0;
          var a = _y5 * radialCount + _x6 + offset;
          var b = a + 1;
          var c = a + radialCount;
          var d = c + 1;
          indices[indicesOffset++] = b;
          indices[indicesOffset++] = a;
          indices[indicesOffset++] = d;
          indices[indicesOffset++] = a;
          indices[indicesOffset++] = c;
          indices[indicesOffset++] = d;
        }
      };
      return PrimitiveMesh2;
    }();
    var BufferMesh = /* @__PURE__ */ function(_Mesh) {
      _inheritsLoose2(BufferMesh2, _Mesh);
      function BufferMesh2() {
        return _Mesh.apply(this, arguments) || this;
      }
      var _proto = BufferMesh2.prototype;
      _proto.setVertexElements = function setVertexElements(elements) {
        this._setVertexElements(elements);
      };
      _proto.setVertexBufferBinding = function setVertexBufferBinding(bufferOrBinding, strideOrFirstIndex, index) {
        if (strideOrFirstIndex === void 0) {
          strideOrFirstIndex = 0;
        }
        if (index === void 0) {
          index = 0;
        }
        var binding = bufferOrBinding;
        var isBinding = binding.buffer !== void 0;
        isBinding || (binding = new VertexBufferBinding(bufferOrBinding, strideOrFirstIndex));
        var bindings = this._vertexBufferBindings;
        bindings.length <= index && (bindings.length = index + 1);
        this._setVertexBufferBinding(isBinding ? strideOrFirstIndex : index, binding);
      };
      _proto.setVertexBufferBindings = function setVertexBufferBindings(vertexBufferBindings, firstIndex) {
        if (firstIndex === void 0) {
          firstIndex = 0;
        }
        var bindings = this._vertexBufferBindings;
        var count = vertexBufferBindings.length;
        var needLength = firstIndex + count;
        bindings.length < needLength && (bindings.length = needLength);
        for (var i = 0; i < count; i++) {
          this._setVertexBufferBinding(firstIndex + i, vertexBufferBindings[i]);
        }
      };
      _proto.setIndexBufferBinding = function setIndexBufferBinding(bufferOrBinding, format) {
        var binding = bufferOrBinding;
        if (binding) {
          var isBinding = binding.buffer !== void 0;
          isBinding || (binding = new IndexBufferBinding(bufferOrBinding, format));
        }
        this._setIndexBufferBinding(binding);
      };
      _createClass2(BufferMesh2, [{
        key: "instanceCount",
        get: function get() {
          return this._instanceCount;
        },
        set: function set(value) {
          this._instanceCount = value;
        }
      }, {
        key: "vertexBufferBindings",
        get: function get() {
          return this._vertexBufferBindings;
        }
      }, {
        key: "indexBufferBinding",
        get: function get() {
          return this._indexBufferBinding;
        }
      }, {
        key: "vertexElements",
        get: function get() {
          return this._vertexElements;
        }
      }]);
      return BufferMesh2;
    }(Mesh);
    var BlendShapeFrame = function BlendShapeFrame2(weight, deltaPositions, deltaNormals, deltaTangents) {
      if (deltaNormals === void 0) {
        deltaNormals = null;
      }
      if (deltaTangents === void 0) {
        deltaTangents = null;
      }
      this.weight = void 0;
      this.deltaPositions = void 0;
      this.deltaNormals = void 0;
      this.deltaTangents = void 0;
      if (deltaNormals && deltaNormals.length !== deltaPositions.length) {
        throw "deltaNormals length must same with deltaPositions length.";
      }
      if (deltaTangents && deltaTangents.length !== deltaPositions.length) {
        throw "deltaTangents length must same with deltaPositions length.";
      }
      this.weight = weight;
      this.deltaPositions = deltaPositions;
      this.deltaNormals = deltaNormals;
      this.deltaTangents = deltaTangents;
    };
    var BlendShape = /* @__PURE__ */ function() {
      function BlendShape2(name) {
        this.name = void 0;
        this._useBlendShapeNormal = true;
        this._useBlendShapeTangent = true;
        this._layoutChangeManager = new UpdateFlagManager();
        this._dataChangeManager = new UpdateFlagManager();
        this._frames = [];
        this.name = name;
      }
      var _proto = BlendShape2.prototype;
      _proto.addFrame = function addFrame(frameOrWeight, deltaPositions, deltaNormals, deltaTangents) {
        if (typeof frameOrWeight === "number") {
          var _frame = new BlendShapeFrame(frameOrWeight, deltaPositions, deltaNormals, deltaTangents);
          this._addFrame(_frame);
          return _frame;
        } else {
          this._addFrame(frameOrWeight);
        }
      };
      _proto.clearFrames = function clearFrames() {
        this._frames.length = 0;
        this._updateUseNormalAndTangent(true, true);
        this._dataChangeManager.dispatch();
      };
      _proto._addLayoutChangeFlag = function _addLayoutChangeFlag(flag) {
        this._layoutChangeManager.addFlag(flag);
      };
      _proto._addDataDirtyFlag = function _addDataDirtyFlag(flag) {
        this._dataChangeManager.addFlag(flag);
      };
      _proto._createSubDataDirtyFlag = function _createSubDataDirtyFlag() {
        return this._dataChangeManager.createFlag(BoolUpdateFlag);
      };
      _proto._addFrame = function _addFrame(frame) {
        var frames = this._frames;
        var frameCount = frames.length;
        if (frameCount > 0 && frame.deltaPositions.length !== frames[frameCount - 1].deltaPositions.length) {
          throw "Frame's deltaPositions length must same with before frame deltaPositions length.";
        }
        this._frames.push(frame);
        this._updateUseNormalAndTangent(!!frame.deltaNormals, !!frame.deltaTangents);
        this._dataChangeManager.dispatch();
      };
      _proto._updateUseNormalAndTangent = function _updateUseNormalAndTangent(useNormal, useTangent) {
        var useBlendShapeNormal = this._useBlendShapeNormal && useNormal;
        var useBlendShapeTangent = this._useBlendShapeTangent && useTangent;
        if (this._useBlendShapeNormal !== useBlendShapeNormal || this._useBlendShapeTangent !== useBlendShapeTangent) {
          this._useBlendShapeNormal = useBlendShapeNormal;
          this._useBlendShapeTangent = useBlendShapeTangent;
          this._layoutChangeManager.dispatch(this);
        }
      };
      _createClass2(BlendShape2, [{
        key: "frames",
        get: function get() {
          return this._frames;
        }
      }]);
      return BlendShape2;
    }();
    var Basic2DBatcher = /* @__PURE__ */ function() {
      function Basic2DBatcher2(engine) {
        this._engine = void 0;
        this._subMeshPool = new ClassPool(SubMesh);
        this._batchedQueue = [];
        this._meshes = [];
        this._meshCount = 1;
        this._vertexBuffers = [];
        this._indiceBuffers = [];
        this._vertices = void 0;
        this._indices = void 0;
        this._flushId = 0;
        this._vertexCount = 0;
        this._elementCount = 0;
        this._engine = engine;
        var MAX_VERTEX_COUNT = Basic2DBatcher2.MAX_VERTEX_COUNT;
        this._vertices = new Float32Array(MAX_VERTEX_COUNT * 9);
        this._indices = new Uint16Array(MAX_VERTEX_COUNT * 3);
        var _meshes = this._meshes, _meshCount = this._meshCount;
        for (var i = 0; i < _meshCount; i++) {
          _meshes[i] = this._createMesh(engine, i);
        }
      }
      var _proto = Basic2DBatcher2.prototype;
      _proto.drawElement = function drawElement(element, camera, replaceMaterial) {
        if (element.multiRenderData) {
          var elements = element.charElements;
          for (var i = 0, n = elements.length; i < n; ++i) {
            this._drawSubElement(elements[i], camera, replaceMaterial);
          }
        } else {
          this._drawSubElement(element, camera, replaceMaterial);
        }
      };
      _proto._drawSubElement = function _drawSubElement(element, camera, replaceMaterial) {
        var len = element.renderData.vertexCount;
        if (this._vertexCount + len > Basic2DBatcher2.MAX_VERTEX_COUNT) {
          this.flush(camera, replaceMaterial);
        }
        this._vertexCount += len;
        this._batchedQueue[this._elementCount++] = element;
      };
      _proto.flush = function flush(camera, replaceMaterial) {
        var batchedQueue = this._batchedQueue;
        if (batchedQueue.length === 0) {
          return;
        }
        this._updateData(this._engine);
        this.drawBatches(camera, replaceMaterial);
        if (!Basic2DBatcher2._canUploadSameBuffer) {
          this._flushId++;
        }
        batchedQueue.length = 0;
        this._subMeshPool.resetPool();
        this._vertexCount = 0;
        this._elementCount = 0;
      };
      _proto.clear = function clear() {
        this._flushId = 0;
        this._vertexCount = 0;
        this._elementCount = 0;
        this._batchedQueue.length = 0;
      };
      _proto.destroy = function destroy() {
        this._batchedQueue = null;
        var meshes = this._meshes, vertexBuffers = this._vertexBuffers, indiceBuffers = this._indiceBuffers;
        for (var i = 0, n = meshes.length; i < n; ++i) {
          meshes[i].destroy();
        }
        this._meshes = null;
        for (var _i = 0, _n = vertexBuffers.length; _i < _n; ++_i) {
          vertexBuffers[_i].destroy();
        }
        this._vertexBuffers = null;
        for (var _i2 = 0, _n2 = indiceBuffers.length; _i2 < _n2; ++_i2) {
          indiceBuffers[_i2].destroy();
        }
        this._indiceBuffers = null;
      };
      _proto._createMesh = function _createMesh(engine, index) {
        var MAX_VERTEX_COUNT = Basic2DBatcher2.MAX_VERTEX_COUNT;
        var mesh = new BufferMesh(engine, "BufferMesh" + index);
        var vertexElements = [];
        var vertexStride = this.createVertexElements(vertexElements);
        this._vertexBuffers[index] = new Buffer2(engine, exports3.BufferBindFlag.VertexBuffer, MAX_VERTEX_COUNT * 4 * vertexStride, exports3.BufferUsage.Dynamic);
        this._indiceBuffers[index] = new Buffer2(engine, exports3.BufferBindFlag.IndexBuffer, MAX_VERTEX_COUNT * 3, exports3.BufferUsage.Dynamic);
        mesh.setVertexBufferBinding(this._vertexBuffers[index], vertexStride);
        mesh.setIndexBufferBinding(this._indiceBuffers[index], exports3.IndexFormat.UInt16);
        mesh.setVertexElements(vertexElements);
        return mesh;
      };
      _proto._updateData = function _updateData(engine) {
        var _meshes = this._meshes, _flushId = this._flushId;
        if (!Basic2DBatcher2._canUploadSameBuffer && this._meshCount <= _flushId) {
          this._meshCount++;
          _meshes[_flushId] = this._createMesh(engine, _flushId);
        }
        var batchedQueue = this._batchedQueue, vertices = this._vertices, indices = this._indices;
        var mesh = _meshes[_flushId];
        mesh.clearSubMesh();
        var vertexIndex = 0;
        var indiceIndex = 0;
        var vertexStartIndex = 0;
        var vertexCount = 0;
        var curIndiceStartIndex = 0;
        var curMeshIndex = 0;
        var preElement = null;
        for (var i = 0, len = batchedQueue.length; i < len; i++) {
          var _curElement = batchedQueue[i];
          vertexIndex = this.updateVertices(_curElement, vertices, vertexIndex);
          var triangles = _curElement.renderData.triangles;
          var triangleNum = triangles.length;
          for (var j = 0; j < triangleNum; j++) {
            indices[indiceIndex++] = triangles[j] + curIndiceStartIndex;
          }
          curIndiceStartIndex += _curElement.renderData.vertexCount;
          if (preElement === null) {
            vertexCount += triangleNum;
          } else {
            if (this.canBatch(preElement, _curElement)) {
              vertexCount += triangleNum;
            } else {
              mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex, vertexCount));
              vertexStartIndex += vertexCount;
              vertexCount = triangleNum;
              batchedQueue[curMeshIndex++] = preElement;
            }
          }
          preElement = _curElement;
        }
        mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex, vertexCount));
        batchedQueue[curMeshIndex] = preElement;
        this._vertexBuffers[_flushId].setData(vertices, 0, 0, vertexIndex);
        this._indiceBuffers[_flushId].setData(indices, 0, 0, indiceIndex);
      };
      _proto._getSubMeshFromPool = function _getSubMeshFromPool(start2, count) {
        var subMesh = this._subMeshPool.getFromPool();
        subMesh.start = start2;
        subMesh.count = count;
        subMesh.topology = exports3.MeshTopology.Triangles;
        return subMesh;
      };
      return Basic2DBatcher2;
    }();
    Basic2DBatcher.MAX_VERTEX_COUNT = 4096;
    Basic2DBatcher._canUploadSameBuffer = true;
    var SpriteMaskBatcher = /* @__PURE__ */ function(_Basic2DBatcher) {
      _inheritsLoose2(SpriteMaskBatcher2, _Basic2DBatcher);
      function SpriteMaskBatcher2() {
        return _Basic2DBatcher.apply(this, arguments) || this;
      }
      var _proto = SpriteMaskBatcher2.prototype;
      _proto.createVertexElements = function createVertexElements(vertexElements) {
        vertexElements[0] = new VertexElement("POSITION", 0, exports3.VertexElementFormat.Vector3, 0);
        vertexElements[1] = new VertexElement("TEXCOORD_0", 12, exports3.VertexElementFormat.Vector2, 0);
        return 20;
      };
      _proto.canBatch = function canBatch(preElement, curElement) {
        if (preElement.isAdd !== curElement.isAdd) {
          return false;
        }
        var preShaderData = preElement.component.shaderData;
        var curShaderData = curElement.component.shaderData;
        var textureProperty = SpriteMask._textureProperty;
        var alphaCutoffProperty = SpriteMask._alphaCutoffProperty;
        return preShaderData.getTexture(textureProperty) === curShaderData.getTexture(textureProperty) && preShaderData.getTexture(alphaCutoffProperty) === curShaderData.getTexture(alphaCutoffProperty);
      };
      _proto.updateVertices = function updateVertices(element, vertices, vertexIndex) {
        var _element$renderData = element.renderData, positions = _element$renderData.positions, uvs = _element$renderData.uvs, vertexCount = _element$renderData.vertexCount;
        for (var i = 0; i < vertexCount; i++) {
          var curPos = positions[i];
          var curUV = uvs[i];
          vertices[vertexIndex++] = curPos.x;
          vertices[vertexIndex++] = curPos.y;
          vertices[vertexIndex++] = curPos.z;
          vertices[vertexIndex++] = curUV.x;
          vertices[vertexIndex++] = curUV.y;
        }
        return vertexIndex;
      };
      _proto.drawBatches = function drawBatches(camera) {
        var engine = this._engine, batchedQueue = this._batchedQueue;
        var mesh = this._meshes[this._flushId];
        var subMeshes = mesh.subMeshes;
        var sceneData = camera.scene.shaderData;
        var cameraData = camera.shaderData;
        for (var i = 0, len = subMeshes.length; i < len; i++) {
          var subMesh = subMeshes[i];
          var spriteMaskElement = batchedQueue[i];
          if (!subMesh || !spriteMaskElement) {
            return;
          }
          var renderer = spriteMaskElement.component;
          var material = spriteMaskElement.material;
          var compileMacros = Shader._compileMacros;
          ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, material.shaderData._macroCollection, compileMacros);
          var stencilState = material.renderState.stencilState;
          var op = spriteMaskElement.isAdd ? exports3.StencilOperation.IncrementSaturate : exports3.StencilOperation.DecrementSaturate;
          stencilState.passOperationFront = op;
          stencilState.passOperationBack = op;
          var program = material.shader._getShaderProgram(engine, compileMacros);
          if (!program.isValid) {
            return;
          }
          program.bind();
          program.groupingOtherUniformBlock();
          program.uploadAll(program.sceneUniformBlock, sceneData);
          program.uploadAll(program.cameraUniformBlock, cameraData);
          program.uploadAll(program.rendererUniformBlock, renderer.shaderData);
          program.uploadAll(program.materialUniformBlock, material.shaderData);
          material.renderState._apply(engine, false);
          engine._hardwareRenderer.drawPrimitive(mesh, subMesh, program);
        }
      };
      return SpriteMaskBatcher2;
    }(Basic2DBatcher);
    var SpriteMaskManager = /* @__PURE__ */ function() {
      function SpriteMaskManager2(engine) {
        this._batcher = void 0;
        this._preMaskLayer = 0;
        this._batcher = new SpriteMaskBatcher(engine);
      }
      var _proto = SpriteMaskManager2.prototype;
      _proto.clear = function clear() {
        this._preMaskLayer = 0;
        this._batcher.clear();
      };
      _proto.preRender = function preRender(camera, renderer) {
        if (renderer.maskInteraction === exports3.SpriteMaskInteraction.None) {
          return;
        }
        this._batcher.clear();
        this._processMasksDiff(camera, renderer);
        this._batcher.flush(camera, null);
      };
      _proto.postRender = function postRender(renderer) {
        if (renderer.maskInteraction === exports3.SpriteMaskInteraction.None) {
          return;
        }
        this._preMaskLayer = renderer.maskLayer;
      };
      _proto.destroy = function destroy() {
        this._batcher.destroy();
        this._batcher = null;
      };
      _proto._processMasksDiff = function _processMasksDiff(camera, renderer) {
        var preMaskLayer = this._preMaskLayer;
        var curMaskLayer = renderer.maskLayer;
        if (preMaskLayer !== curMaskLayer) {
          var allMasks = camera._renderPipeline._allSpriteMasks;
          var commonLayer = preMaskLayer & curMaskLayer;
          var addLayer = curMaskLayer & ~preMaskLayer;
          var reduceLayer = preMaskLayer & ~curMaskLayer;
          var allMaskElements = allMasks._elements;
          for (var i = 0, n = allMasks.length; i < n; i++) {
            var mask = allMaskElements[i];
            var influenceLayers = mask.influenceLayers;
            if (influenceLayers & commonLayer) {
              continue;
            }
            if (influenceLayers & addLayer) {
              var maskRenderElement = mask._maskElement;
              maskRenderElement.isAdd = true;
              this._batcher.drawElement(maskRenderElement, camera, null);
              continue;
            }
            if (influenceLayers & reduceLayer) {
              var _maskRenderElement = mask._maskElement;
              _maskRenderElement.isAdd = false;
              this._batcher.drawElement(_maskRenderElement, camera, null);
            }
          }
        }
      };
      return SpriteMaskManager2;
    }();
    var TextRenderElement = /* @__PURE__ */ function(_RenderElement) {
      _inheritsLoose2(TextRenderElement2, _RenderElement);
      function TextRenderElement2() {
        var _this;
        _this = _RenderElement.call(this) || this;
        _this.charElements = [];
        _this.multiRenderData = true;
        return _this;
      }
      return TextRenderElement2;
    }(RenderElement);
    exports3.BackgroundMode = void 0;
    (function(BackgroundMode) {
      BackgroundMode[BackgroundMode["SolidColor"] = 0] = "SolidColor";
      BackgroundMode[BackgroundMode["Sky"] = 1] = "Sky";
      BackgroundMode[BackgroundMode["Texture"] = 2] = "Texture";
    })(exports3.BackgroundMode || (exports3.BackgroundMode = {}));
    exports3.BackgroundTextureFillMode = void 0;
    (function(BackgroundTextureFillMode) {
      BackgroundTextureFillMode[BackgroundTextureFillMode["AspectFitWidth"] = 0] = "AspectFitWidth";
      BackgroundTextureFillMode[BackgroundTextureFillMode["AspectFitHeight"] = 1] = "AspectFitHeight";
      BackgroundTextureFillMode[BackgroundTextureFillMode["Fill"] = 2] = "Fill";
    })(exports3.BackgroundTextureFillMode || (exports3.BackgroundTextureFillMode = {}));
    var Sky = function Sky2() {
      this.material = void 0;
      this.mesh = void 0;
      this._matrix = new miniprogram2.Matrix();
    };
    var Background = /* @__PURE__ */ function() {
      function Background2(_engine) {
        this._engine = _engine;
        this.mode = exports3.BackgroundMode.SolidColor;
        this.solidColor = new miniprogram2.Color(0.25, 0.25, 0.25, 1);
        this.sky = new Sky();
        this._textureFillMode = exports3.BackgroundTextureFillMode.AspectFitHeight;
        this._mesh = void 0;
        this._texture = null;
        this._mesh = this._createPlane(_engine);
      }
      var _proto = Background2.prototype;
      _proto._resizeBackgroundTexture = function _resizeBackgroundTexture() {
        if (!this._texture) {
          return;
        }
        var canvas = this._engine.canvas;
        var width = canvas.width, height = canvas.height;
        var _backgroundTextureMesh = this._mesh;
        var positions = _backgroundTextureMesh.getPositions();
        switch (this._textureFillMode) {
          case exports3.BackgroundTextureFillMode.Fill:
            positions[0].set(-1, -1, 1);
            positions[1].set(1, -1, 1);
            positions[2].set(-1, 1, 1);
            positions[3].set(1, 1, 1);
            break;
          case exports3.BackgroundTextureFillMode.AspectFitWidth:
            var fitWidthScale = this._texture.height * width / this.texture.width / height;
            positions[0].set(-1, -fitWidthScale, 1);
            positions[1].set(1, -fitWidthScale, 1);
            positions[2].set(-1, fitWidthScale, 1);
            positions[3].set(1, fitWidthScale, 1);
            break;
          case exports3.BackgroundTextureFillMode.AspectFitHeight:
            var fitHeightScale = this._texture.width * height / this.texture.height / width;
            positions[0].set(-fitHeightScale, -1, 1);
            positions[1].set(fitHeightScale, -1, 1);
            positions[2].set(-fitHeightScale, 1, 1);
            positions[3].set(fitHeightScale, 1, 1);
            break;
        }
        _backgroundTextureMesh.setPositions(positions);
        _backgroundTextureMesh.uploadData(false);
      };
      _proto._createPlane = function _createPlane(engine) {
        var mesh = new ModelMesh(engine);
        mesh.isGCIgnored = true;
        var indices = new Uint8Array([1, 2, 0, 1, 3, 2]);
        var positions = new Array(4);
        var uvs = new Array(4);
        for (var i = 0; i < 4; ++i) {
          positions[i] = new miniprogram2.Vector3();
          uvs[i] = new miniprogram2.Vector2(i % 2, 1 - (i * 0.5 | 0));
        }
        mesh.setPositions(positions);
        mesh.setUVs(uvs);
        mesh.setIndices(indices);
        mesh.uploadData(false);
        mesh.addSubMesh(0, indices.length);
        return mesh;
      };
      _createClass2(Background2, [{
        key: "texture",
        get: function get() {
          return this._texture;
        },
        set: function set(value) {
          if (this._texture !== value) {
            this._texture = value;
            this._engine._backgroundTextureMaterial.shaderData.setTexture("u_baseTexture", value);
          }
        }
      }, {
        key: "textureFillMode",
        get: function get() {
          return this._textureFillMode;
        },
        set: function set(value) {
          if (value !== this._textureFillMode) {
            this._textureFillMode = value;
            this._resizeBackgroundTexture();
          }
        }
      }]);
      return Background2;
    }();
    exports3.DiffuseMode = void 0;
    (function(DiffuseMode) {
      DiffuseMode[DiffuseMode["SolidColor"] = 0] = "SolidColor";
      DiffuseMode[DiffuseMode["SphericalHarmonics"] = 1] = "SphericalHarmonics";
    })(exports3.DiffuseMode || (exports3.DiffuseMode = {}));
    var AmbientLight = /* @__PURE__ */ function() {
      function AmbientLight2() {
        this._diffuseSphericalHarmonics = void 0;
        this._diffuseSolidColor = new miniprogram2.Color(0.212, 0.227, 0.259);
        this._diffuseIntensity = 1;
        this._specularTexture = void 0;
        this._specularIntensity = 1;
        this._diffuseMode = exports3.DiffuseMode.SolidColor;
        this._shArray = new Float32Array(27);
        this._scenes = [];
        this._specularTextureDecodeRGBM = false;
      }
      var _proto = AmbientLight2.prototype;
      _proto._addToScene = function _addToScene(scene) {
        this._scenes.push(scene);
        var shaderData = scene.shaderData;
        shaderData.setColor(AmbientLight2._diffuseColorProperty, this._diffuseSolidColor);
        shaderData.setFloat(AmbientLight2._diffuseIntensityProperty, this._diffuseIntensity);
        shaderData.setFloat(AmbientLight2._specularIntensityProperty, this._specularIntensity);
        shaderData.setFloatArray(AmbientLight2._diffuseSHProperty, this._shArray);
        this._setDiffuseMode(shaderData);
        this._setSpecularTextureDecodeRGBM(shaderData);
        this._setSpecularTexture(shaderData);
      };
      _proto._removeFromScene = function _removeFromScene(scene) {
        var scenes = this._scenes;
        var index = scenes.indexOf(scene);
        scenes.splice(index, 1);
      };
      _proto._setDiffuseMode = function _setDiffuseMode(sceneShaderData) {
        if (this._diffuseMode === exports3.DiffuseMode.SphericalHarmonics) {
          sceneShaderData.enableMacro(AmbientLight2._shMacro);
        } else {
          sceneShaderData.disableMacro(AmbientLight2._shMacro);
        }
      };
      _proto._setSpecularTexture = function _setSpecularTexture(sceneShaderData) {
        if (this._specularTexture) {
          sceneShaderData.setTexture(AmbientLight2._specularTextureProperty, this._specularTexture);
          sceneShaderData.setFloat(AmbientLight2._mipLevelProperty, this._specularTexture.mipmapCount - 1);
          sceneShaderData.enableMacro(AmbientLight2._specularMacro);
        } else {
          sceneShaderData.disableMacro(AmbientLight2._specularMacro);
        }
      };
      _proto._setSpecularTextureDecodeRGBM = function _setSpecularTextureDecodeRGBM(sceneShaderData) {
        if (this._specularTextureDecodeRGBM) {
          sceneShaderData.enableMacro(AmbientLight2._decodeRGBMMacro);
        } else {
          sceneShaderData.disableMacro(AmbientLight2._decodeRGBMMacro);
        }
      };
      _proto._preComputeSH = function _preComputeSH(sh, out) {
        var src = sh.coefficients;
        out[0] = src[0] * 0.886227;
        out[1] = src[1] * 0.886227;
        out[2] = src[2] * 0.886227;
        out[3] = src[3] * -1.023327;
        out[4] = src[4] * -1.023327;
        out[5] = src[5] * -1.023327;
        out[6] = src[6] * 1.023327;
        out[7] = src[7] * 1.023327;
        out[8] = src[8] * 1.023327;
        out[9] = src[9] * -1.023327;
        out[10] = src[10] * -1.023327;
        out[11] = src[11] * -1.023327;
        out[12] = src[12] * 0.858086;
        out[13] = src[13] * 0.858086;
        out[14] = src[14] * 0.858086;
        out[15] = src[15] * -0.858086;
        out[16] = src[16] * -0.858086;
        out[17] = src[17] * -0.858086;
        out[18] = src[18] * 0.247708;
        out[19] = src[19] * 0.247708;
        out[20] = src[20] * 0.247708;
        out[21] = src[21] * -0.858086;
        out[22] = src[22] * -0.858086;
        out[23] = src[23] * -0.858086;
        out[24] = src[24] * 0.429042;
        out[25] = src[25] * 0.429042;
        out[26] = src[26] * 0.429042;
      };
      _createClass2(AmbientLight2, [{
        key: "specularTextureDecodeRGBM",
        get: function get() {
          return this._specularTextureDecodeRGBM;
        },
        set: function set(value) {
          this._specularTextureDecodeRGBM = value;
          var scenes = this._scenes;
          for (var i = 0, n = scenes.length; i < n; i++) {
            this._setSpecularTextureDecodeRGBM(scenes[i].shaderData);
          }
        }
      }, {
        key: "diffuseMode",
        get: function get() {
          return this._diffuseMode;
        },
        set: function set(value) {
          this._diffuseMode = value;
          var scenes = this._scenes;
          for (var i = 0, n = scenes.length; i < n; i++) {
            this._setDiffuseMode(scenes[i].shaderData);
          }
        }
      }, {
        key: "diffuseSolidColor",
        get: function get() {
          return this._diffuseSolidColor;
        },
        set: function set(value) {
          if (value !== this._diffuseSolidColor) {
            this._diffuseSolidColor.copyFrom(value);
          }
        }
      }, {
        key: "diffuseSphericalHarmonics",
        get: function get() {
          return this._diffuseSphericalHarmonics;
        },
        set: function set(value) {
          this._diffuseSphericalHarmonics = value;
          if (value) {
            this._preComputeSH(value, this._shArray);
            var scenes = this._scenes;
            for (var i = 0, n = scenes.length; i < n; i++) {
              scenes[i].shaderData.setFloatArray(AmbientLight2._diffuseSHProperty, this._shArray);
            }
          }
        }
      }, {
        key: "diffuseIntensity",
        get: function get() {
          return this._diffuseIntensity;
        },
        set: function set(value) {
          this._diffuseIntensity = value;
          var scenes = this._scenes;
          for (var i = 0, n = scenes.length; i < n; i++) {
            scenes[i].shaderData.setFloat(AmbientLight2._diffuseIntensityProperty, value);
          }
        }
      }, {
        key: "specularTexture",
        get: function get() {
          return this._specularTexture;
        },
        set: function set(value) {
          this._specularTexture = value;
          var scenes = this._scenes;
          for (var i = 0, n = scenes.length; i < n; i++) {
            this._setSpecularTexture(scenes[i].shaderData);
          }
        }
      }, {
        key: "specularIntensity",
        get: function get() {
          return this._specularIntensity;
        },
        set: function set(value) {
          this._specularIntensity = value;
          for (var i = 0, n = this._scenes.length; i < n; i++) {
            this._scenes[i].shaderData.setFloat(AmbientLight2._specularIntensityProperty, value);
          }
        }
      }]);
      return AmbientLight2;
    }();
    AmbientLight._shMacro = Shader.getMacroByName("O3_USE_SH");
    AmbientLight._specularMacro = Shader.getMacroByName("O3_USE_SPECULAR_ENV");
    AmbientLight._decodeRGBMMacro = Shader.getMacroByName("O3_DECODE_ENV_RGBM");
    AmbientLight._diffuseColorProperty = Shader.getPropertyByName("u_envMapLight.diffuse");
    AmbientLight._diffuseSHProperty = Shader.getPropertyByName("u_env_sh");
    AmbientLight._diffuseIntensityProperty = Shader.getPropertyByName("u_envMapLight.diffuseIntensity");
    AmbientLight._specularTextureProperty = Shader.getPropertyByName("u_env_specularSampler");
    AmbientLight._specularIntensityProperty = Shader.getPropertyByName("u_envMapLight.specularIntensity");
    AmbientLight._mipLevelProperty = Shader.getPropertyByName("u_envMapLight.mipMapLevel");
    var SceneFeature = /* @__PURE__ */ function() {
      function SceneFeature2() {
      }
      var _proto = SceneFeature2.prototype;
      _proto.preUpdate = function preUpdate(scene) {
      };
      _proto.postUpdate = function postUpdate(scene) {
      };
      _proto.preRender = function preRender(scene, camera) {
      };
      _proto.postRender = function postRender(scene, camera) {
      };
      _proto.destroy = function destroy(scene) {
      };
      return SceneFeature2;
    }();
    var Light = /* @__PURE__ */ function(_Component) {
      _inheritsLoose2(Light2, _Component);
      function Light2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _Component.call.apply(_Component, [this].concat(args)) || this;
        _this._viewMat = void 0;
        _this._inverseViewMat = void 0;
        return _this;
      }
      var _proto = Light2.prototype;
      _proto._onEnable = function _onEnable() {
        this.scene.findFeature(LightFeature).attachRenderLight(this);
      };
      _proto._onDisable = function _onDisable() {
        this.scene.findFeature(LightFeature).detachRenderLight(this);
      };
      _createClass2(Light2, [{
        key: "viewMatrix",
        get: function get() {
          if (!this._viewMat)
            this._viewMat = new miniprogram2.Matrix();
          miniprogram2.Matrix.invert(this.entity.transform.worldMatrix, this._viewMat);
          return this._viewMat;
        }
      }, {
        key: "inverseViewMatrix",
        get: function get() {
          if (!this._inverseViewMat)
            this._inverseViewMat = new miniprogram2.Matrix();
          miniprogram2.Matrix.invert(this.viewMatrix, this._inverseViewMat);
          return this._inverseViewMat;
        }
      }]);
      return Light2;
    }(Component);
    Light._maxLight = 10;
    var DirectLight = /* @__PURE__ */ function(_Light) {
      _inheritsLoose2(DirectLight2, _Light);
      function DirectLight2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _Light.call.apply(_Light, [this].concat(args)) || this;
        _this.color = new miniprogram2.Color(1, 1, 1, 1);
        _this.intensity = 1;
        _this._forward = new miniprogram2.Vector3();
        _this._lightColor = new miniprogram2.Color(1, 1, 1, 1);
        _this._reverseDirection = new miniprogram2.Vector3();
        return _this;
      }
      DirectLight2._updateShaderData = function _updateShaderData(shaderData) {
        var data = DirectLight2._combinedData;
        shaderData.setFloatArray(DirectLight2._colorProperty, data.color);
        shaderData.setFloatArray(DirectLight2._directionProperty, data.direction);
      };
      var _proto = DirectLight2.prototype;
      _proto._appendData = function _appendData(lightIndex) {
        var colorStart = lightIndex * 3;
        var directionStart = lightIndex * 3;
        var lightColor = this.lightColor;
        var direction = this.direction;
        var data = DirectLight2._combinedData;
        data.color[colorStart] = lightColor.r;
        data.color[colorStart + 1] = lightColor.g;
        data.color[colorStart + 2] = lightColor.b;
        data.direction[directionStart] = direction.x;
        data.direction[directionStart + 1] = direction.y;
        data.direction[directionStart + 2] = direction.z;
      };
      _createClass2(DirectLight2, [{
        key: "direction",
        get: function get() {
          this.entity.transform.getWorldForward(this._forward);
          return this._forward;
        }
      }, {
        key: "lightColor",
        get: function get() {
          this._lightColor.r = this.color.r * this.intensity;
          this._lightColor.g = this.color.g * this.intensity;
          this._lightColor.b = this.color.b * this.intensity;
          this._lightColor.a = this.color.a * this.intensity;
          return this._lightColor;
        }
      }, {
        key: "reverseDirection",
        get: function get() {
          miniprogram2.Vector3.scale(this.direction, -1, this._reverseDirection);
          return this._reverseDirection;
        }
      }]);
      return DirectLight2;
    }(Light);
    DirectLight._colorProperty = Shader.getPropertyByName("u_directLightColor");
    DirectLight._directionProperty = Shader.getPropertyByName("u_directLightDirection");
    DirectLight._combinedData = {
      color: new Float32Array(3 * Light._maxLight),
      direction: new Float32Array(3 * Light._maxLight)
    };
    var PointLight = /* @__PURE__ */ function(_Light) {
      _inheritsLoose2(PointLight2, _Light);
      function PointLight2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _Light.call.apply(_Light, [this].concat(args)) || this;
        _this.color = new miniprogram2.Color(1, 1, 1, 1);
        _this.intensity = 1;
        _this.distance = 100;
        _this._lightColor = new miniprogram2.Color(1, 1, 1, 1);
        return _this;
      }
      PointLight2._updateShaderData = function _updateShaderData(shaderData) {
        var data = PointLight2._combinedData;
        shaderData.setFloatArray(PointLight2._colorProperty, data.color);
        shaderData.setFloatArray(PointLight2._positionProperty, data.position);
        shaderData.setFloatArray(PointLight2._distanceProperty, data.distance);
      };
      var _proto = PointLight2.prototype;
      _proto._appendData = function _appendData(lightIndex) {
        var colorStart = lightIndex * 3;
        var positionStart = lightIndex * 3;
        var distanceStart = lightIndex;
        var lightColor = this.lightColor;
        var lightPosition = this.position;
        var data = PointLight2._combinedData;
        data.color[colorStart] = lightColor.r;
        data.color[colorStart + 1] = lightColor.g;
        data.color[colorStart + 2] = lightColor.b;
        data.position[positionStart] = lightPosition.x;
        data.position[positionStart + 1] = lightPosition.y;
        data.position[positionStart + 2] = lightPosition.z;
        data.distance[distanceStart] = this.distance;
      };
      _createClass2(PointLight2, [{
        key: "position",
        get: function get() {
          return this.entity.transform.worldPosition;
        }
      }, {
        key: "lightColor",
        get: function get() {
          this._lightColor.r = this.color.r * this.intensity;
          this._lightColor.g = this.color.g * this.intensity;
          this._lightColor.b = this.color.b * this.intensity;
          this._lightColor.a = this.color.a * this.intensity;
          return this._lightColor;
        }
      }]);
      return PointLight2;
    }(Light);
    PointLight._colorProperty = Shader.getPropertyByName("u_pointLightColor");
    PointLight._positionProperty = Shader.getPropertyByName("u_pointLightPosition");
    PointLight._distanceProperty = Shader.getPropertyByName("u_pointLightDistance");
    PointLight._combinedData = {
      color: new Float32Array(3 * Light._maxLight),
      position: new Float32Array(3 * Light._maxLight),
      distance: new Float32Array(Light._maxLight)
    };
    var SpotLight = /* @__PURE__ */ function(_Light) {
      _inheritsLoose2(SpotLight2, _Light);
      function SpotLight2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _Light.call.apply(_Light, [this].concat(args)) || this;
        _this.color = new miniprogram2.Color(1, 1, 1, 1);
        _this.intensity = 1;
        _this.distance = 100;
        _this.angle = Math.PI / 6;
        _this.penumbra = Math.PI / 12;
        _this._forward = new miniprogram2.Vector3();
        _this._lightColor = new miniprogram2.Color(1, 1, 1, 1);
        _this._inverseDirection = new miniprogram2.Vector3();
        return _this;
      }
      SpotLight2._updateShaderData = function _updateShaderData(shaderData) {
        var data = SpotLight2._combinedData;
        shaderData.setFloatArray(SpotLight2._colorProperty, data.color);
        shaderData.setFloatArray(SpotLight2._positionProperty, data.position);
        shaderData.setFloatArray(SpotLight2._directionProperty, data.direction);
        shaderData.setFloatArray(SpotLight2._distanceProperty, data.distance);
        shaderData.setFloatArray(SpotLight2._angleCosProperty, data.angleCos);
        shaderData.setFloatArray(SpotLight2._penumbraCosProperty, data.penumbraCos);
      };
      var _proto = SpotLight2.prototype;
      _proto._appendData = function _appendData(lightIndex) {
        var colorStart = lightIndex * 3;
        var positionStart = lightIndex * 3;
        var directionStart = lightIndex * 3;
        var distanceStart = lightIndex;
        var penumbraCosStart = lightIndex;
        var angleCosStart = lightIndex;
        var color = this.lightColor;
        var position = this.position;
        var direction = this.direction;
        var data = SpotLight2._combinedData;
        data.color[colorStart] = color.r;
        data.color[colorStart + 1] = color.g;
        data.color[colorStart + 2] = color.b;
        data.position[positionStart] = position.x;
        data.position[positionStart + 1] = position.y;
        data.position[positionStart + 2] = position.z;
        data.direction[directionStart] = direction.x;
        data.direction[directionStart + 1] = direction.y;
        data.direction[directionStart + 2] = direction.z;
        data.distance[distanceStart] = this.distance;
        data.angleCos[angleCosStart] = Math.cos(this.angle);
        data.penumbraCos[penumbraCosStart] = Math.cos(this.angle + this.penumbra);
      };
      _createClass2(SpotLight2, [{
        key: "position",
        get: function get() {
          return this.entity.transform.worldPosition;
        }
      }, {
        key: "direction",
        get: function get() {
          this.entity.transform.getWorldForward(this._forward);
          return this._forward;
        }
      }, {
        key: "reverseDirection",
        get: function get() {
          miniprogram2.Vector3.scale(this.direction, -1, this._inverseDirection);
          return this._inverseDirection;
        }
      }, {
        key: "lightColor",
        get: function get() {
          this._lightColor.r = this.color.r * this.intensity;
          this._lightColor.g = this.color.g * this.intensity;
          this._lightColor.b = this.color.b * this.intensity;
          this._lightColor.a = this.color.a * this.intensity;
          return this._lightColor;
        }
      }]);
      return SpotLight2;
    }(Light);
    SpotLight._colorProperty = Shader.getPropertyByName("u_spotLightColor");
    SpotLight._positionProperty = Shader.getPropertyByName("u_spotLightPosition");
    SpotLight._directionProperty = Shader.getPropertyByName("u_spotLightDirection");
    SpotLight._distanceProperty = Shader.getPropertyByName("u_spotLightDistance");
    SpotLight._angleCosProperty = Shader.getPropertyByName("u_spotLightAngleCos");
    SpotLight._penumbraCosProperty = Shader.getPropertyByName("u_spotLightPenumbraCos");
    SpotLight._combinedData = {
      color: new Float32Array(3 * Light._maxLight),
      position: new Float32Array(3 * Light._maxLight),
      direction: new Float32Array(3 * Light._maxLight),
      distance: new Float32Array(Light._maxLight),
      angleCos: new Float32Array(Light._maxLight),
      penumbraCos: new Float32Array(Light._maxLight)
    };
    function hasLight() {
      return this.findFeature(LightFeature).visibleLights.length > 0;
    }
    var LightFeature = /* @__PURE__ */ function(_SceneFeature) {
      _inheritsLoose2(LightFeature2, _SceneFeature);
      function LightFeature2() {
        var _this;
        _this = _SceneFeature.call(this) || this;
        _this.visibleLights = void 0;
        _this.visibleLights = [];
        return _this;
      }
      var _proto = LightFeature2.prototype;
      _proto.attachRenderLight = function attachRenderLight(light) {
        var index = this.visibleLights.indexOf(light);
        if (index == -1) {
          this.visibleLights.push(light);
        } else {
          Logger.warn("Light already attached.");
        }
      };
      _proto.detachRenderLight = function detachRenderLight(light) {
        var index = this.visibleLights.indexOf(light);
        if (index != -1) {
          this.visibleLights.splice(index, 1);
        }
      };
      _proto._updateShaderData = function _updateShaderData(shaderData) {
        var directLightCount = 0;
        var pointLightCount = 0;
        var spotLightCount = 0;
        var lights = this.visibleLights;
        for (var i = 0, len = lights.length; i < len; i++) {
          var light = lights[i];
          if (light instanceof DirectLight) {
            light._appendData(directLightCount++);
          } else if (light instanceof PointLight) {
            light._appendData(pointLightCount++);
          } else if (light instanceof SpotLight) {
            light._appendData(spotLightCount++);
          }
        }
        if (directLightCount) {
          DirectLight._updateShaderData(shaderData);
          shaderData.enableMacro("O3_DIRECT_LIGHT_COUNT", directLightCount.toString());
        } else {
          shaderData.disableMacro("O3_DIRECT_LIGHT_COUNT");
        }
        if (pointLightCount) {
          PointLight._updateShaderData(shaderData);
          shaderData.enableMacro("O3_POINT_LIGHT_COUNT", pointLightCount.toString());
        } else {
          shaderData.disableMacro("O3_POINT_LIGHT_COUNT");
        }
        if (spotLightCount) {
          SpotLight._updateShaderData(shaderData);
          shaderData.enableMacro("O3_SPOT_LIGHT_COUNT", spotLightCount.toString());
        } else {
          shaderData.disableMacro("O3_SPOT_LIGHT_COUNT");
        }
      };
      return LightFeature2;
    }(SceneFeature);
    var Scene = /* @__PURE__ */ function(_EngineObject) {
      _inheritsLoose2(Scene2, _EngineObject);
      function Scene2(engine, name) {
        var _this;
        _this = _EngineObject.call(this, engine) || this;
        _this.name = void 0;
        _this.background = new Background(_this._engine);
        _this.shaderData = new ShaderData(ShaderDataGroup.Scene);
        _this._activeCameras = [];
        _this._isActiveInEngine = false;
        _this._globalShaderMacro = new ShaderMacroCollection();
        _this._rootEntities = [];
        _this._ambientLight = void 0;
        _this.features = [];
        _this.name = name || "";
        var shaderData = _this.shaderData;
        Scene2.sceneFeatureManager.addObject(_assertThisInitialized(_this));
        shaderData._addRefCount(1);
        _this.ambientLight = new AmbientLight();
        engine.sceneManager._allScenes.push(_assertThisInitialized(_this));
        return _this;
      }
      var _proto = Scene2.prototype;
      _proto.createRootEntity = function createRootEntity(name) {
        var entity = new Entity(this._engine, name);
        this.addRootEntity(entity);
        return entity;
      };
      _proto.addRootEntity = function addRootEntity(indexOrChild, entity) {
        var index;
        if (typeof indexOrChild === "number") {
          index = indexOrChild;
        } else {
          index = void 0;
          entity = indexOrChild;
        }
        var isRoot = entity._isRoot;
        if (!isRoot) {
          entity._isRoot = true;
          entity._removeFromParent();
        }
        var oldScene = entity._scene;
        if (oldScene !== this) {
          if (oldScene && isRoot) {
            oldScene._removeFromEntityList(entity);
          }
          this._addToRootEntityList(index, entity);
          Entity._traverseSetOwnerScene(entity, this);
        } else if (!isRoot) {
          this._addToRootEntityList(index, entity);
        }
        if (this._isActiveInEngine) {
          !entity._isActiveInHierarchy && entity._isActive && entity._processActive();
        } else {
          entity._isActiveInHierarchy && entity._processInActive();
        }
      };
      _proto.removeRootEntity = function removeRootEntity(entity) {
        if (entity._isRoot && entity._scene == this) {
          this._removeFromEntityList(entity);
          entity._isRoot = false;
          this._isActiveInEngine && entity._isActiveInHierarchy && entity._processInActive();
          Entity._traverseSetOwnerScene(entity, null);
        }
      };
      _proto.getRootEntity = function getRootEntity(index) {
        if (index === void 0) {
          index = 0;
        }
        return this._rootEntities[index];
      };
      _proto.findEntityByName = function findEntityByName(name) {
        var children = this._rootEntities;
        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];
          if (child.name === name) {
            return child;
          }
        }
        for (var _i = children.length - 1; _i >= 0; _i--) {
          var _child = children[_i];
          var _entity = _child.findByName(name);
          if (_entity) {
            return _entity;
          }
        }
        return null;
      };
      _proto.findEntityByPath = function findEntityByPath(path) {
        var splits = path.split("/").filter(Boolean);
        for (var i = 0, n = this.rootEntitiesCount; i < n; i++) {
          var findEntity = this.getRootEntity(i);
          if (findEntity.name != splits[0])
            continue;
          for (var j = 1, m = splits.length; j < m; ++j) {
            findEntity = Entity._findChildByName(findEntity, splits[j]);
            if (!findEntity)
              break;
          }
          return findEntity;
        }
        return null;
      };
      _proto.destroy = function destroy() {
        if (this._destroyed) {
          return;
        }
        this._destroy();
        var allScenes = this.engine.sceneManager._allScenes;
        allScenes.splice(allScenes.indexOf(this), 1);
      };
      _proto._attachRenderCamera = function _attachRenderCamera(camera) {
        var index = this._activeCameras.indexOf(camera);
        if (index === -1) {
          this._activeCameras.push(camera);
        } else {
          Logger.warn("Camera already attached.");
        }
      };
      _proto._detachRenderCamera = function _detachRenderCamera(camera) {
        var index = this._activeCameras.indexOf(camera);
        if (index !== -1) {
          this._activeCameras.splice(index, 1);
        }
      };
      _proto._processActive = function _processActive(active) {
        this._isActiveInEngine = active;
        var rootEntities = this._rootEntities;
        for (var i = rootEntities.length - 1; i >= 0; i--) {
          var _entity2 = rootEntities[i];
          if (_entity2._isActive) {
            active ? _entity2._processActive() : _entity2._processInActive();
          }
        }
      };
      _proto._updateShaderData = function _updateShaderData() {
        this.findFeature(LightFeature)._updateShaderData(this.shaderData);
        ShaderMacroCollection.unionCollection(this.engine._macroCollection, this.shaderData._macroCollection, this._globalShaderMacro);
      };
      _proto._removeFromEntityList = function _removeFromEntityList(entity) {
        var rootEntities = this._rootEntities;
        var index = entity._siblingIndex;
        rootEntities.splice(index, 1);
        for (var n = rootEntities.length; index < n; index++) {
          rootEntities[index]._siblingIndex--;
        }
        entity._siblingIndex = -1;
      };
      _proto._destroy = function _destroy() {
        this._isActiveInEngine && (this._engine.sceneManager.activeScene = null);
        Scene2.sceneFeatureManager.callFeatureMethod(this, "destroy", [this]);
        for (var i = 0, n = this.rootEntitiesCount; i < n; i++) {
          this._rootEntities[i].destroy();
        }
        this._rootEntities.length = 0;
        this._activeCameras.length = 0;
        Scene2.sceneFeatureManager._objects = [];
        this.shaderData._addRefCount(-1);
      };
      _proto._addToRootEntityList = function _addToRootEntityList(index, rootEntity) {
        var rootEntities = this._rootEntities;
        var rootEntityCount = rootEntities.length;
        if (index === void 0) {
          rootEntity._siblingIndex = rootEntityCount;
          rootEntities.push(rootEntity);
        } else {
          if (index < 0 || index > rootEntityCount) {
            throw "The index " + index + " is out of child list bounds " + rootEntityCount;
          }
          rootEntity._siblingIndex = index;
          rootEntities.splice(index, 0, rootEntity);
          for (var i = index + 1, n = rootEntityCount + 1; i < n; i++) {
            rootEntities[i]._siblingIndex++;
          }
        }
      };
      Scene2.registerFeature = function registerFeature(Feature) {
        Scene2.sceneFeatureManager.registerFeature(Feature);
      };
      _proto.findFeature = function findFeature(Feature) {
        return Scene2.sceneFeatureManager.findFeature(this, Feature);
      };
      _createClass2(Scene2, [{
        key: "ambientLight",
        get: function get() {
          return this._ambientLight;
        },
        set: function set(value) {
          if (!value) {
            Logger.warn("The scene must have one ambient light");
            return;
          }
          var lastAmbientLight = this._ambientLight;
          if (lastAmbientLight !== value) {
            lastAmbientLight && lastAmbientLight._removeFromScene(this);
            value._addToScene(this);
            this._ambientLight = value;
          }
        }
      }, {
        key: "rootEntitiesCount",
        get: function get() {
          return this._rootEntities.length;
        }
      }, {
        key: "rootEntities",
        get: function get() {
          return this._rootEntities;
        }
      }]);
      return Scene2;
    }(EngineObject);
    Scene.sceneFeatureManager = new FeatureManager();
    var SceneManager = /* @__PURE__ */ function() {
      function SceneManager2(engine) {
        this.engine = engine;
        this._allScenes = [];
        this._activeScene = void 0;
      }
      var _proto = SceneManager2.prototype;
      _proto.loadScene = function loadScene(url, destroyOldScene) {
        var _this = this;
        if (destroyOldScene === void 0) {
          destroyOldScene = true;
        }
        var scenePromise = this.engine.resourceManager.load(url);
        scenePromise.then(function(scene) {
          var oldScene = _this._activeScene;
          _this.activeScene = scene;
          if (oldScene && destroyOldScene) {
            oldScene.destroy();
          }
        });
        return scenePromise;
      };
      _proto.mergeScenes = function mergeScenes(sourceScene, destScene) {
        var oldRootEntities = sourceScene.rootEntities;
        for (var i = 0, n = oldRootEntities.length; i < n; i++) {
          destScene.addRootEntity(oldRootEntities[i]);
        }
      };
      _proto._destroyAllScene = function _destroyAllScene() {
        var allScenes = this._allScenes;
        for (var i = 0, n = allScenes.length; i < n; i++) {
          allScenes[i]._destroy();
        }
        allScenes.length = 0;
      };
      _createClass2(SceneManager2, [{
        key: "activeScene",
        get: function get() {
          return this._activeScene;
        },
        set: function set(scene) {
          var oldScene = this._activeScene;
          if (oldScene !== scene) {
            oldScene && oldScene._processActive(false);
            scene && scene._processActive(true);
            this._activeScene = scene;
          }
        }
      }]);
      return SceneManager2;
    }();
    var blinnPhongFs = "#define GLSLIFY 1\n#include <common>\n#include <common_frag>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <light_frag_define>\n#include <mobile_material_frag>\n#include <fog_share>\n#include <normal_get>\nvoid main(){\n#include <begin_mobile_frag>\n#include <begin_viewdir_frag>\n#include <mobile_blinnphong_frag>\ngl_FragColor=emission+ambient+diffuse+specular;gl_FragColor.a=diffuse.a;\n#ifndef OASIS_COLORSPACE_GAMMA\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n#include <fog_frag>\n}";
    var blinnPhongVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <shadow_vert>\n#include <position_vert>\n#include <fog_vert>\n}";
    var particleFs = "#define GLSLIFY 1\nvarying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;uniform sampler2D u_texture;void main(){if(v_lifeLeft==1.0){discard;}float alphaFactor=1.0;\n#ifdef fadeIn\nfloat fadeInFactor=step(0.5,v_lifeLeft);alphaFactor=2.0*fadeInFactor*(1.0-v_lifeLeft)+(1.0-fadeInFactor);\n#endif\n#ifdef fadeOut\nfloat fadeOutFactor=step(0.5,v_lifeLeft);alphaFactor=alphaFactor*2.0*(1.0-fadeOutFactor)*v_lifeLeft+alphaFactor*fadeOutFactor;\n#endif\n#ifdef particleTexture\nvec4 tex=texture2D(u_texture,v_uv);\n#ifdef useOriginColor\ngl_FragColor=vec4(tex.rgb,alphaFactor*tex.a*v_color.w);\n#else\ngl_FragColor=vec4(v_color.xyz*tex.rgb,alphaFactor*tex.a*v_color.w);\n#endif\n#else\ngl_FragColor=vec4(v_color.xyz,alphaFactor*v_color.w);\n#endif\n}";
    var particleVs = "#define GLSLIFY 1\nattribute vec3 a_position;attribute vec3 a_velocity;attribute vec3 a_acceleration;attribute vec4 a_color;attribute vec4 a_lifeAndSize;attribute vec2 a_rotation;attribute vec3 a_uv;attribute vec2 a_normalizedUv;uniform float u_time;uniform bool u_once;uniform mat4 u_MVPMat;varying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;\n#ifdef is2d\nuniform mat4 u_viewInvMat;uniform mat4 u_projMat;uniform mat4 u_viewMat;uniform mat4 u_modelMat;\n#endif\nmat2 rotation2d(float angle){float s=sin(angle);float c=cos(angle);return mat2(c,-s,s,c);}void main(){v_color=a_color;v_uv=a_uv.xy;float life=a_lifeAndSize.y;float startTime=a_lifeAndSize.x;float deltaTime=max(mod(u_time-startTime,life),0.0);if((u_once&&u_time>life+startTime)){deltaTime=0.0;}v_lifeLeft=1.0-deltaTime/life;float scale=a_lifeAndSize.z;vec3 position=a_position+(a_velocity+a_acceleration*deltaTime*0.5)*deltaTime;\n#ifdef isScaleByLifetime\nscale*=v_lifeLeft;\n#else\nscale*=pow(a_lifeAndSize.w,deltaTime);\n#endif\n#ifdef rotateToVelocity\nvec3 v=a_velocity+a_acceleration*deltaTime;float angle=atan(v.z,v.x)*2.0;\n#else\nfloat deltaAngle=deltaTime*a_rotation.y;float angle=a_rotation.x+deltaAngle;\n#endif\n#ifdef is2d\nvec2 rotatedPoint=rotation2d(angle)*vec2(a_normalizedUv.x,a_normalizedUv.y*a_uv.z);vec3 basisX=u_viewInvMat[0].xyz;vec3 basisZ=u_viewInvMat[1].xyz;vec3 localPosition=vec3(basisX*rotatedPoint.x+basisZ*rotatedPoint.y)*scale+position;gl_Position=u_projMat*u_viewMat*vec4(localPosition+u_modelMat[3].xyz,1.);\n#else\n#ifdef rotateToVelocity\nfloat s=sin(angle);float c=cos(angle);\n#else\nfloat s=sin(angle);float c=cos(angle);\n#endif\nvec4 rotatedPoint=vec4((a_normalizedUv.x*c+a_normalizedUv.y*a_uv.z*s)*scale,0.,(a_normalizedUv.x*s-a_normalizedUv.y*a_uv.z*c)*scale,1.);vec4 orientation=vec4(0,0,0,1);vec4 q2=orientation+orientation;vec4 qx=orientation.xxxw*q2.xyzx;vec4 qy=orientation.xyyw*q2.xyzy;vec4 qz=orientation.xxzw*q2.xxzz;mat4 localMatrix=mat4((1.0-qy.y)-qz.z,qx.y+qz.w,qx.z-qy.w,0,qx.y-qz.w,(1.0-qx.x)-qz.z,qy.z+qx.w,0,qx.z+qy.w,qy.z-qx.w,(1.0-qx.x)-qy.y,0,position.x,position.y,position.z,1);rotatedPoint=localMatrix*rotatedPoint;gl_Position=u_MVPMat*rotatedPoint;\n#endif\n}";
    var pbrFs = "#define GLSLIFY 1\n#define IS_METALLIC_WORKFLOW\n#include <common>\n#include <common_frag>\n#include <fog_share>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\nvoid main(){\n#include <pbr_frag>\n#include <fog_frag>\n}";
    var pbrSpecularFs = "#define GLSLIFY 1\n#include <common>\n#include <common_frag>\n#include <fog_share>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\nvoid main(){\n#include <pbr_frag>\n#include <fog_frag>\n}";
    var pbrVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <shadow_vert>\n#include <position_vert>\n#include <fog_vert>\n}";
    var shadowMapFs = "#define GLSLIFY 1\nvec4 pack(float depth){const vec4 bitShift=vec4(1.0,256.0,256.0*256.0,256.0*256.0*256.0);const vec4 bitMask=vec4(1.0/256.0,1.0/256.0,1.0/256.0,0.0);vec4 rgbaDepth=fract(depth*bitShift);rgbaDepth-=rgbaDepth.gbaa*bitMask;return rgbaDepth;}void main(){gl_FragColor=pack(gl_FragCoord.z);}";
    var shadowMapVs = "#define GLSLIFY 1\n#include <common_vert>\n#include <blendShape_input>\n#include <normal_share>\n#include <shadow_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <shadow_vert>\n#include <position_vert>\n}";
    var shadowFs = "#define GLSLIFY 1\n#ifdef O3_SHADOW_MAP_COUNT\nuniform float u_shadowBias[O3_SHADOW_MAP_COUNT];uniform float u_shadowIntensity[O3_SHADOW_MAP_COUNT];uniform float u_shadowRadius[O3_SHADOW_MAP_COUNT];uniform vec2 u_shadowMapSize[O3_SHADOW_MAP_COUNT];uniform sampler2D u_shadowMaps[O3_SHADOW_MAP_COUNT];varying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];const vec4 bitShift=vec4(1.0,1.0/256.0,1.0/(256.0*256.0),1.0/(256.0*256.0*256.0));float unpack(const in vec4 rgbaDepth){return dot(rgbaDepth,bitShift);}float getVisibility(vec4 positionFromLight,const in sampler2D shadowMap,vec2 mapSize,float intensity,float bias,float radius){vec3 shadowCoord=(positionFromLight.xyz/positionFromLight.w)/2.0+0.5;float filterX=step(0.0,shadowCoord.x)*(1.0-step(1.0,shadowCoord.x));float filterY=step(0.0,shadowCoord.y)*(1.0-step(1.0,shadowCoord.y));shadowCoord.z-=bias;vec2 texelSize=vec2(1.0)/mapSize;float visibility=0.0;for(float y=-1.0;y<=1.0;y+=1.0){for(float x=-1.0;x<=1.0;x+=1.0){vec2 uv=shadowCoord.xy+texelSize*vec2(x,y)*radius;vec4 rgbaDepth=texture2D(shadowMap,uv);float depth=unpack(rgbaDepth);visibility+=step(depth,shadowCoord.z)*intensity;}}visibility*=(1.0/9.0);return visibility*filterX*filterY;}\n#endif\nvoid main(){vec4 shadowColor=vec4(1.0,1.0,1.0,1.0);\n#ifdef O3_SHADOW_MAP_COUNT\nfloat visibility=1.0;\n#if (O3_SHADOW_MAP_COUNT == 1)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);\n#elif (O3_SHADOW_MAP_COUNT == 2)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);visibility-=getVisibility(v_PositionFromLight[1],u_shadowMaps[1],u_shadowMapSize[1],u_shadowIntensity[1],u_shadowBias[1],u_shadowRadius[1]);\n#elif (O3_SHADOW_MAP_COUNT == 3)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);visibility-=getVisibility(v_PositionFromLight[1],u_shadowMaps[1],u_shadowMapSize[1],u_shadowIntensity[1],u_shadowBias[1],u_shadowRadius[1]);visibility-=getVisibility(v_PositionFromLight[2],u_shadowMaps[2],u_shadowMapSize[2],u_shadowIntensity[2],u_shadowBias[2],u_shadowRadius[2]);\n#endif\nvisibility=clamp(visibility,0.0,1.0);shadowColor=vec4(visibility,visibility,visibility,1.0);\n#endif\ngl_FragColor=shadowColor;}";
    var skyboxFs = "#define GLSLIFY 1\n#include <common>\nuniform samplerCube u_cube;varying vec3 v_cubeUV;uniform vec4 u_cubeDecodeParam;void main(){vec4 textureColor=textureCube(u_cube,v_cubeUV);if(u_cubeDecodeParam.x>0.0){textureColor=RGBMToLinear(textureColor,u_cubeDecodeParam.y);textureColor=linearToGamma(textureColor);}gl_FragColor=textureColor;}";
    var skyboxVs = "#define GLSLIFY 1\n#include <common_vert>\nuniform mat4 u_mvpNoscale;varying vec3 v_cubeUV;void main(){v_cubeUV=vec3(-POSITION.x,POSITION.yz);gl_Position=u_mvpNoscale*vec4(POSITION,1.0);gl_Position.z=gl_Position.w;}";
    var spriteMaskFs = "#define GLSLIFY 1\nuniform sampler2D u_maskTexture;uniform float u_maskAlphaCutoff;varying vec2 v_uv;void main(){vec4 color=texture2D(u_maskTexture,v_uv);if(color.a<u_maskAlphaCutoff){discard;}gl_FragColor=color;}";
    var spriteMaskVs = "#define GLSLIFY 1\nuniform mat4 u_VPMat;attribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=u_VPMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";
    var spriteFs = "#define GLSLIFY 1\n#ifdef USE_CUSTOM_TEXTURE\nuniform sampler2D u_cusTomTexture;\n#else\nuniform sampler2D u_spriteTexture;\n#endif\nvarying vec2 v_uv;varying vec4 v_color;void main(){\n#ifdef USE_CUSTOM_TEXTURE\nvec4 baseColor=texture2D(u_cusTomTexture,v_uv);\n#else\nvec4 baseColor=texture2D(u_spriteTexture,v_uv);\n#endif\ngl_FragColor=baseColor*v_color;}";
    var spriteVs = "#define GLSLIFY 1\n#ifdef USE_MODEL_MATRIX\nuniform mat4 u_MVPMat;\n#else\nuniform mat4 u_VPMat;\n#endif\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;attribute vec4 COLOR_0;varying vec2 v_uv;varying vec4 v_color;void main(){\n#ifdef USE_MODEL_MATRIX\ngl_Position=u_MVPMat*vec4(POSITION,1.0);\n#else\ngl_Position=u_VPMat*vec4(POSITION,1.0);\n#endif\nv_uv=TEXCOORD_0;v_color=COLOR_0;}";
    var unlitFs = "#define GLSLIFY 1\n#include <common>\n#include <uv_share>\n#include <fog_share>\nuniform vec4 u_baseColor;uniform float u_alphaCutoff;\n#ifdef BASETEXTURE\nuniform sampler2D u_baseTexture;\n#endif\nvoid main(){vec4 baseColor=u_baseColor;\n#ifdef BASETEXTURE\nvec4 textureColor=texture2D(u_baseTexture,v_uv);\n#ifndef OASIS_COLORSPACE_GAMMA\ntextureColor=gammaToLinear(textureColor);\n#endif\nbaseColor*=textureColor;\n#endif\n#ifdef ALPHA_CUTOFF\nif(baseColor.a<u_alphaCutoff){discard;}\n#endif\n#ifndef OASIS_COLORSPACE_GAMMA\nbaseColor=linearToGamma(baseColor);\n#endif\ngl_FragColor=baseColor;\n#include <fog_frag>\n}";
    var unlitVs = "#define GLSLIFY 1\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <position_vert>\n#include <fog_vert>\n}";
    var backgroundTextureVs = "#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";
    var backgroundTextureFs = "#define GLSLIFY 1\nuniform sampler2D u_baseTexture;varying vec2 v_uv;void main(){gl_FragColor=texture2D(u_baseTexture,v_uv);}";
    var ShaderPool = /* @__PURE__ */ function() {
      function ShaderPool2() {
      }
      ShaderPool2.init = function init() {
        Shader.create("blinn-phong", blinnPhongVs, blinnPhongFs);
        Shader.create("pbr", pbrVs, pbrFs);
        Shader.create("pbr-specular", pbrVs, pbrSpecularFs);
        Shader.create("unlit", unlitVs, unlitFs);
        Shader.create("shadow-map", shadowMapVs, shadowMapFs);
        Shader.create("shadow", shadowMapVs, shadowFs);
        Shader.create("skybox", skyboxVs, skyboxFs);
        Shader.create("particle-shader", particleVs, particleFs);
        Shader.create("SpriteMask", spriteMaskVs, spriteMaskFs);
        Shader.create("Sprite", spriteVs, spriteFs);
        Shader.create("background-texture", backgroundTextureVs, backgroundTextureFs);
      };
      return ShaderPool2;
    }();
    var ShaderProgramPool = /* @__PURE__ */ function() {
      function ShaderProgramPool2() {
        this._cacheHierarchy = 1;
        this._cacheMap = /* @__PURE__ */ Object.create(null);
        this._lastQueryMap = void 0;
        this._lastQueryKey = void 0;
      }
      var _proto = ShaderProgramPool2.prototype;
      _proto.get = function get(macros) {
        var cacheMap = this._cacheMap;
        var maskLength = macros._length;
        if (maskLength > this._cacheHierarchy) {
          this._resizeCacheMapHierarchy(cacheMap, 0, maskLength);
        }
        var mask = macros._mask;
        var endIndex = macros._length - 1;
        var maxEndIndex = this._cacheHierarchy - 1;
        for (var i = 0; i < maxEndIndex; i++) {
          var subMask = endIndex < i ? 0 : mask[i];
          var subCacheShaders = cacheMap[subMask];
          subCacheShaders || (cacheMap[subMask] = subCacheShaders = /* @__PURE__ */ Object.create(null));
          cacheMap = subCacheShaders;
        }
        var cacheKey = endIndex < maxEndIndex ? 0 : mask[maxEndIndex];
        var shader = cacheMap[cacheKey];
        if (!shader) {
          this._lastQueryKey = cacheKey;
          this._lastQueryMap = cacheMap;
        }
        return shader;
      };
      _proto.cache = function cache(shaderProgram) {
        this._lastQueryMap[this._lastQueryKey] = shaderProgram;
      };
      _proto._resizeCacheMapHierarchy = function _resizeCacheMapHierarchy(cacheMap, hierarchy, resizeLength) {
        var end = this._cacheHierarchy - 1;
        if (hierarchy == end) {
          for (var k in cacheMap) {
            var shader = cacheMap[k];
            for (var i = 0, n = resizeLength - end; i < n; i++) {
              if (i == n - 1) {
                cacheMap[0] = shader;
              } else {
                cacheMap = cacheMap[i == 0 ? k : 0] = /* @__PURE__ */ Object.create(null);
              }
            }
          }
          this._cacheHierarchy = resizeLength;
        } else {
          for (var _k in cacheMap) {
            this._resizeCacheMapHierarchy(cacheMap[_k], ++hierarchy, resizeLength);
          }
        }
      };
      return ShaderProgramPool2;
    }();
    var engineFeatureManager = new FeatureManager();
    ShaderPool.init();
    var Engine = /* @__PURE__ */ function(_EventDispatcher) {
      _inheritsLoose2(Engine2, _EventDispatcher);
      function Engine2(canvas, hardwareRenderer, settings) {
        var _this;
        _this = _EventDispatcher.call(this) || this;
        _this.physicsManager = void 0;
        _this.inputManager = void 0;
        _this._componentsManager = new ComponentsManager();
        _this._hardwareRenderer = void 0;
        _this._lastRenderState = new RenderState();
        _this._renderElementPool = new ClassPool(MeshRenderElement);
        _this._spriteElementPool = new ClassPool(SpriteElement);
        _this._spriteMaskElementPool = new ClassPool(SpriteMaskElement);
        _this._textElementPool = new ClassPool(TextRenderElement);
        _this._spriteDefaultMaterial = void 0;
        _this._spriteMaskDefaultMaterial = void 0;
        _this._renderContext = new RenderContext();
        _this._magentaTexture2D = void 0;
        _this._magentaTextureCube = void 0;
        _this._magentaTexture2DArray = void 0;
        _this._magentaMaterial = void 0;
        _this._backgroundTextureMaterial = void 0;
        _this._renderCount = 0;
        _this._shaderProgramPools = [];
        _this._spriteMaskManager = void 0;
        _this._canSpriteBatch = true;
        _this._macroCollection = new ShaderMacroCollection();
        _this._canvas = void 0;
        _this._settings = {};
        _this._resourceManager = new ResourceManager(_assertThisInitialized(_this));
        _this._sceneManager = new SceneManager(_assertThisInitialized(_this));
        _this._vSyncCount = 1;
        _this._targetFrameRate = 60;
        _this._time = new Time();
        _this._isPaused = true;
        _this._requestId = void 0;
        _this._timeoutId = void 0;
        _this._vSyncCounter = 1;
        _this._targetFrameInterval = 1e3 / 60;
        _this._destroyed = false;
        _this._waittingDestroy = false;
        _this._animate = function() {
          if (_this._vSyncCount) {
            _this._requestId = miniprogramAdapter2.requestAnimationFrame(_this._animate);
            if (_this._vSyncCounter++ % _this._vSyncCount === 0) {
              _this.update();
              _this._vSyncCounter = 1;
            }
          } else {
            _this._timeoutId = miniprogramAdapter2.window.setTimeout(_this._animate, _this._targetFrameInterval);
            _this.update();
          }
        };
        _this.features = [];
        _this._hardwareRenderer = hardwareRenderer;
        _this._hardwareRenderer.init(canvas);
        _this.physicsManager = new PhysicsManager(_assertThisInitialized(_this));
        _this._canvas = canvas;
        engineFeatureManager.addObject(_assertThisInitialized(_this));
        _this._sceneManager.activeScene = new Scene(_assertThisInitialized(_this), "DefaultScene");
        _this._spriteMaskManager = new SpriteMaskManager(_assertThisInitialized(_this));
        _this._spriteDefaultMaterial = _this._createSpriteMaterial();
        _this._spriteMaskDefaultMaterial = _this._createSpriteMaskMaterial();
        _this.inputManager = new InputManager(_assertThisInitialized(_this));
        var magentaPixel = new Uint8Array([255, 0, 255, 255]);
        var magentaTexture2D = new Texture2D(_assertThisInitialized(_this), 1, 1, exports3.TextureFormat.R8G8B8A8, false);
        magentaTexture2D.setPixelBuffer(magentaPixel);
        magentaTexture2D.isGCIgnored = true;
        var magentaTextureCube = new TextureCube(_assertThisInitialized(_this), 1, exports3.TextureFormat.R8G8B8A8, false);
        magentaTextureCube.setPixelBuffer(exports3.TextureCubeFace.PositiveX, magentaPixel);
        magentaTextureCube.setPixelBuffer(exports3.TextureCubeFace.NegativeX, magentaPixel);
        magentaTextureCube.setPixelBuffer(exports3.TextureCubeFace.PositiveY, magentaPixel);
        magentaTextureCube.setPixelBuffer(exports3.TextureCubeFace.NegativeY, magentaPixel);
        magentaTextureCube.setPixelBuffer(exports3.TextureCubeFace.PositiveZ, magentaPixel);
        magentaTextureCube.setPixelBuffer(exports3.TextureCubeFace.NegativeZ, magentaPixel);
        magentaTextureCube.isGCIgnored = true;
        _this._magentaTexture2D = magentaTexture2D;
        _this._magentaTextureCube = magentaTextureCube;
        if (hardwareRenderer.isWebGL2) {
          var magentaTexture2DArray = new Texture2DArray(_assertThisInitialized(_this), 1, 1, 1, exports3.TextureFormat.R8G8B8A8, false);
          magentaTexture2DArray.setPixelBuffer(0, magentaPixel);
          magentaTexture2DArray.isGCIgnored = true;
          _this._magentaTexture2DArray = magentaTexture2DArray;
        }
        var magentaMaterial = new Material(_assertThisInitialized(_this), Shader.find("unlit"));
        magentaMaterial.shaderData.setColor("u_baseColor", new miniprogram2.Color(1, 0, 1.01, 1));
        _this._magentaMaterial = magentaMaterial;
        var backgroundTextureMaterial = new Material(_assertThisInitialized(_this), Shader.find("background-texture"));
        backgroundTextureMaterial.isGCIgnored = true;
        backgroundTextureMaterial.renderState.depthState.compareFunction = exports3.CompareFunction.LessEqual;
        _this._backgroundTextureMaterial = backgroundTextureMaterial;
        var colorSpace = (settings === null || settings === void 0 ? void 0 : settings.colorSpace) || exports3.ColorSpace.Linear;
        colorSpace === exports3.ColorSpace.Gamma && _this._macroCollection.enable(Engine2._gammaMacro);
        _this._settings.colorSpace = colorSpace;
        return _this;
      }
      var _proto = Engine2.prototype;
      _proto.createEntity = function createEntity(name) {
        return new Entity(this, name);
      };
      _proto.pause = function pause() {
        this._isPaused = true;
        miniprogramAdapter2.cancelAnimationFrame(this._requestId);
        clearTimeout(this._timeoutId);
      };
      _proto.resume = function resume() {
        if (!this._isPaused)
          return;
        this._isPaused = false;
        this.time.reset();
        this._requestId = miniprogramAdapter2.requestAnimationFrame(this._animate);
      };
      _proto.update = function update() {
        var time = this._time;
        var deltaTime = time.deltaTime;
        time.tick();
        this._renderElementPool.resetPool();
        this._spriteElementPool.resetPool();
        this._spriteMaskElementPool.resetPool();
        this._textElementPool.resetPool();
        engineFeatureManager.callFeatureMethod(this, "preTick", [this, this._sceneManager._activeScene]);
        var scene = this._sceneManager._activeScene;
        var componentsManager = this._componentsManager;
        if (scene) {
          scene._activeCameras.sort(function(camera1, camera2) {
            return camera1.priority - camera2.priority;
          });
          componentsManager.callScriptOnStart();
          this.physicsManager._initialized && this.physicsManager._update(deltaTime / 1e3);
          this.inputManager._update();
          componentsManager.callScriptOnUpdate(deltaTime);
          componentsManager.callAnimationUpdate(deltaTime);
          componentsManager.callScriptOnLateUpdate(deltaTime);
          this._render(scene);
        }
        engineFeatureManager.callFeatureMethod(this, "postTick", [this, this._sceneManager._activeScene]);
        if (this._waittingDestroy) {
          this._sceneManager._destroyAllScene();
        }
        componentsManager.handlingInvalidScripts();
        if (this._waittingDestroy) {
          this._destroy();
        }
      };
      _proto.run = function run() {
        engineFeatureManager.callFeatureMethod(this, "preLoad", [this]);
        this.resume();
        this.trigger(new Event("run", this));
      };
      _proto.destroy = function destroy() {
        if (this._destroyed) {
          return;
        }
        this._waittingDestroy = true;
      };
      _proto._destroy = function _destroy() {
        this._resourceManager._destroy();
        this._magentaTexture2D.destroy(true);
        this._magentaTextureCube.destroy(true);
        this.inputManager._destroy();
        this.trigger(new Event("shutdown", this));
        engineFeatureManager.callFeatureMethod(this, "shutdown", [this]);
        this.pause();
        this._animate = null;
        this._sceneManager = null;
        this._resourceManager = null;
        this._canvas = null;
        this.features = [];
        this._time = null;
        this._spriteMaskManager.destroy();
        engineFeatureManager._objects = [];
        this.removeAllEventListeners();
        this._waittingDestroy = false;
        this._destroyed = true;
      };
      _proto._getShaderProgramPool = function _getShaderProgramPool(shader) {
        var index = shader._shaderId;
        var shaderProgramPools = this._shaderProgramPools;
        var pool = shaderProgramPools[index];
        if (!pool) {
          var length2 = index + 1;
          if (length2 < shaderProgramPools.length) {
            shaderProgramPools.length = length2;
          }
          shaderProgramPools[index] = pool = new ShaderProgramPool();
        }
        return pool;
      };
      _proto._render = function _render(scene) {
        var cameras = scene._activeCameras;
        var componentsManager = this._componentsManager;
        var deltaTime = this.time.deltaTime;
        componentsManager.callRendererOnUpdate(deltaTime);
        scene._updateShaderData();
        if (cameras.length > 0) {
          for (var i = 0, n = cameras.length; i < n; i++) {
            var camera = cameras[i];
            componentsManager.callCameraOnBeginRender(camera);
            Scene.sceneFeatureManager.callFeatureMethod(scene, "preRender", [scene, camera]);
            camera.render();
            Scene.sceneFeatureManager.callFeatureMethod(scene, "postRender", [scene, camera]);
            componentsManager.callCameraOnEndRender(camera);
          }
        } else {
          Logger.debug("NO active camera.");
        }
      };
      _proto._createSpriteMaterial = function _createSpriteMaterial() {
        var material = new Material(this, Shader.find("Sprite"));
        var renderState = material.renderState;
        var target = renderState.blendState.targetBlendState;
        target.enabled = true;
        target.sourceColorBlendFactor = exports3.BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = exports3.BlendFactor.OneMinusSourceAlpha;
        target.sourceAlphaBlendFactor = exports3.BlendFactor.One;
        target.destinationAlphaBlendFactor = exports3.BlendFactor.OneMinusSourceAlpha;
        target.colorBlendOperation = target.alphaBlendOperation = exports3.BlendOperation.Add;
        renderState.depthState.writeEnabled = false;
        renderState.rasterState.cullMode = exports3.CullMode.Off;
        material.renderQueueType = exports3.RenderQueueType.Transparent;
        material.isGCIgnored = true;
        return material;
      };
      _proto._createSpriteMaskMaterial = function _createSpriteMaskMaterial() {
        var material = new Material(this, Shader.find("SpriteMask"));
        var renderState = material.renderState;
        renderState.blendState.targetBlendState.colorWriteMask = exports3.ColorWriteMask.None;
        renderState.rasterState.cullMode = exports3.CullMode.Off;
        renderState.stencilState.enabled = true;
        renderState.depthState.enabled = false;
        material.isGCIgnored = true;
        return material;
      };
      _proto.findFeature = function findFeature(Feature) {
        return engineFeatureManager.findFeature(this, Feature);
      };
      Engine2.registerFeature = function registerFeature(Feature) {
        engineFeatureManager.registerFeature(Feature);
      };
      _createClass2(Engine2, [{
        key: "settings",
        get: function get() {
          return this._settings;
        }
      }, {
        key: "canvas",
        get: function get() {
          return this._canvas;
        }
      }, {
        key: "resourceManager",
        get: function get() {
          return this._resourceManager;
        }
      }, {
        key: "sceneManager",
        get: function get() {
          return this._sceneManager;
        }
      }, {
        key: "time",
        get: function get() {
          return this._time;
        }
      }, {
        key: "isPaused",
        get: function get() {
          return this._isPaused;
        }
      }, {
        key: "vSyncCount",
        get: function get() {
          return this._vSyncCount;
        },
        set: function set(value) {
          this._vSyncCount = Math.max(0, Math.floor(value));
        }
      }, {
        key: "targetFrameRate",
        get: function get() {
          return this._targetFrameRate;
        },
        set: function set(value) {
          value = Math.max(1e-6, value);
          this._targetFrameRate = value;
          this._targetFrameInterval = 1e3 / value;
        }
      }, {
        key: "destroyed",
        get: function get() {
          return this._destroyed;
        }
      }]);
      return Engine2;
    }(EventDispatcher);
    Engine._gammaMacro = Shader.getMacroByName("OASIS_COLORSPACE_GAMMA");
    Engine._pixelsPerUnit = 100;
    Engine._defaultBoundingBox = new miniprogram2.BoundingBox(new miniprogram2.Vector3(0, 0, 0), new miniprogram2.Vector3(0, 0, 0));
    var SystemInfo = /* @__PURE__ */ function() {
      function SystemInfo2() {
      }
      SystemInfo2._isIos = function _isIos() {
        if (!miniprogramAdapter2.window) {
          return false;
        }
        var ua = miniprogramAdapter2.window.navigator.userAgent.toLocaleLowerCase();
        return /iphone|ipad|ipod/.test(ua);
      };
      _createClass2(SystemInfo2, null, [{
        key: "devicePixelRatio",
        get: function get() {
          return miniprogramAdapter2.window.devicePixelRatio;
        }
      }]);
      return SystemInfo2;
    }();
    var EngineFeature = /* @__PURE__ */ function() {
      function EngineFeature2() {
      }
      var _proto = EngineFeature2.prototype;
      _proto.preLoad = function preLoad(engine) {
      };
      _proto.preTick = function preTick(engine, currentScene) {
      };
      _proto.postTick = function postTick(engine, currentScene) {
      };
      _proto.shutdown = function shutdown(engine) {
      };
      return EngineFeature2;
    }();
    var _class$52, _descriptor$4, _descriptor2$4, _descriptor3$4, _descriptor4$4, _descriptor5$4, _descriptor6$4, _descriptor7$4, _descriptor8$4, _descriptor9$4;
    var Script = (_class$52 = /* @__PURE__ */ function(_Component) {
      _inheritsLoose2(Script2, _Component);
      function Script2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _Component.call.apply(_Component, [this].concat(args)) || this;
        _initializerDefineProperty(_this, "_started", _descriptor$4, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_onStartIndex", _descriptor2$4, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_onUpdateIndex", _descriptor3$4, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_onLateUpdateIndex", _descriptor4$4, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_onPhysicsUpdateIndex", _descriptor5$4, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_onPreRenderIndex", _descriptor6$4, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_onPostRenderIndex", _descriptor7$4, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_entityScriptsIndex", _descriptor8$4, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_waitHandlingInValid", _descriptor9$4, _assertThisInitialized(_this));
        return _this;
      }
      var _proto = Script2.prototype;
      _proto.onAwake = function onAwake() {
      };
      _proto.onEnable = function onEnable() {
      };
      _proto.onStart = function onStart() {
      };
      _proto.onUpdate = function onUpdate(deltaTime) {
      };
      _proto.onLateUpdate = function onLateUpdate(deltaTime) {
      };
      _proto.onBeginRender = function onBeginRender(camera) {
      };
      _proto.onEndRender = function onEndRender(camera) {
      };
      _proto.onPhysicsUpdate = function onPhysicsUpdate() {
      };
      _proto.onTriggerEnter = function onTriggerEnter(other) {
      };
      _proto.onTriggerExit = function onTriggerExit(other) {
      };
      _proto.onTriggerStay = function onTriggerStay(other) {
      };
      _proto.onCollisionEnter = function onCollisionEnter(other) {
      };
      _proto.onCollisionExit = function onCollisionExit(other) {
      };
      _proto.onCollisionStay = function onCollisionStay(other) {
      };
      _proto.onPointerDown = function onPointerDown() {
      };
      _proto.onPointerUp = function onPointerUp() {
      };
      _proto.onPointerClick = function onPointerClick() {
      };
      _proto.onPointerEnter = function onPointerEnter() {
      };
      _proto.onPointerExit = function onPointerExit() {
      };
      _proto.onPointerDrag = function onPointerDrag() {
      };
      _proto.onDisable = function onDisable() {
      };
      _proto.onDestroy = function onDestroy() {
      };
      _proto._onAwake = function _onAwake() {
        this.onAwake();
      };
      _proto._onEnable = function _onEnable() {
        if (this._waitHandlingInValid) {
          this._waitHandlingInValid = false;
        } else {
          var componentsManager = this.engine._componentsManager;
          var prototype = Script2.prototype;
          if (!this._started) {
            componentsManager.addOnStartScript(this);
          }
          if (this.onUpdate !== prototype.onUpdate) {
            componentsManager.addOnUpdateScript(this);
          }
          if (this.onLateUpdate !== prototype.onLateUpdate) {
            componentsManager.addOnLateUpdateScript(this);
          }
          if (this.onPhysicsUpdate !== prototype.onPhysicsUpdate) {
            componentsManager.addOnPhysicsUpdateScript(this);
          }
          this._entity._addScript(this);
        }
        this.onEnable();
      };
      _proto._onDisable = function _onDisable() {
        this._waitHandlingInValid = true;
        this._engine._componentsManager.addDisableScript(this);
        this.onDisable();
      };
      _proto._onDestroy = function _onDestroy() {
        this._engine._componentsManager.addDestroyScript(this);
      };
      _proto._handlingInValid = function _handlingInValid() {
        var componentsManager = this.engine._componentsManager;
        var prototype = Script2.prototype;
        if (this.onUpdate !== prototype.onUpdate) {
          componentsManager.removeOnUpdateScript(this);
        }
        if (this.onLateUpdate !== prototype.onLateUpdate) {
          componentsManager.removeOnLateUpdateScript(this);
        }
        if (this.onPhysicsUpdate !== prototype.onPhysicsUpdate) {
          componentsManager.removeOnPhysicsUpdateScript(this);
        }
        this._entity._removeScript(this);
        this._waitHandlingInValid = false;
      };
      return Script2;
    }(Component), _descriptor$4 = _applyDecoratedDescriptor(_class$52.prototype, "_started", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor2$4 = _applyDecoratedDescriptor(_class$52.prototype, "_onStartIndex", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return -1;
      }
    }), _descriptor3$4 = _applyDecoratedDescriptor(_class$52.prototype, "_onUpdateIndex", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return -1;
      }
    }), _descriptor4$4 = _applyDecoratedDescriptor(_class$52.prototype, "_onLateUpdateIndex", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return -1;
      }
    }), _descriptor5$4 = _applyDecoratedDescriptor(_class$52.prototype, "_onPhysicsUpdateIndex", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return -1;
      }
    }), _descriptor6$4 = _applyDecoratedDescriptor(_class$52.prototype, "_onPreRenderIndex", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return -1;
      }
    }), _descriptor7$4 = _applyDecoratedDescriptor(_class$52.prototype, "_onPostRenderIndex", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return -1;
      }
    }), _descriptor8$4 = _applyDecoratedDescriptor(_class$52.prototype, "_entityScriptsIndex", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return -1;
      }
    }), _descriptor9$4 = _applyDecoratedDescriptor(_class$52.prototype, "_waitHandlingInValid", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _class$52);
    var passNum = 0;
    var RenderPass = /* @__PURE__ */ function() {
      function RenderPass2(name, priority, renderTarget, replaceMaterial, mask) {
        if (name === void 0) {
          name = "RENDER_PASS" + passNum++;
        }
        if (priority === void 0) {
          priority = 0;
        }
        if (renderTarget === void 0) {
          renderTarget = null;
        }
        if (replaceMaterial === void 0) {
          replaceMaterial = null;
        }
        if (mask === void 0) {
          mask = null;
        }
        this.name = void 0;
        this.enabled = void 0;
        this.priority = void 0;
        this.renderTarget = void 0;
        this.replaceMaterial = void 0;
        this.mask = void 0;
        this.renderOverride = void 0;
        this.clearFlags = void 0;
        this.clearColor = void 0;
        this.name = name;
        this.enabled = true;
        this.priority = priority;
        this.renderTarget = renderTarget;
        this.replaceMaterial = replaceMaterial;
        this.mask = mask || exports3.Layer.Everything;
        this.renderOverride = false;
      }
      var _proto = RenderPass2.prototype;
      _proto.render = function render(camera, opaqueQueue, alphaTestQueue, transparentQueue) {
      };
      _proto.preRender = function preRender(camera, opaqueQueue, alphaTestQueue, transparentQueue) {
      };
      _proto.postRender = function postRender(camera, opaqueQueue, alphaTestQueue, transparentQueue) {
      };
      return RenderPass2;
    }();
    var SpriteBatcher = /* @__PURE__ */ function(_Basic2DBatcher) {
      _inheritsLoose2(SpriteBatcher2, _Basic2DBatcher);
      function SpriteBatcher2() {
        return _Basic2DBatcher.apply(this, arguments) || this;
      }
      var _proto = SpriteBatcher2.prototype;
      _proto.createVertexElements = function createVertexElements(vertexElements) {
        vertexElements[0] = new VertexElement("POSITION", 0, exports3.VertexElementFormat.Vector3, 0);
        vertexElements[1] = new VertexElement("TEXCOORD_0", 12, exports3.VertexElementFormat.Vector2, 0);
        vertexElements[2] = new VertexElement("COLOR_0", 20, exports3.VertexElementFormat.Vector4, 0);
        return 36;
      };
      _proto.canBatch = function canBatch(preElement, curElement) {
        if (!this._engine._canSpriteBatch) {
          return false;
        }
        var preRenderer = preElement.component;
        var curRenderer = curElement.component;
        if (!this.checkBatchWithMask(preRenderer, curRenderer)) {
          return false;
        }
        if (preElement.texture !== curElement.texture) {
          return false;
        }
        return preElement.material === curElement.material;
      };
      _proto.checkBatchWithMask = function checkBatchWithMask(left, right) {
        var leftMaskInteraction = left.maskInteraction;
        if (leftMaskInteraction !== right.maskInteraction) {
          return false;
        }
        if (leftMaskInteraction === exports3.SpriteMaskInteraction.None) {
          return true;
        }
        return left.maskLayer === right.maskLayer;
      };
      _proto.updateVertices = function updateVertices(element, vertices, vertexIndex) {
        var _element$renderData = element.renderData, positions = _element$renderData.positions, uvs = _element$renderData.uvs, color = _element$renderData.color, vertexCount = _element$renderData.vertexCount;
        for (var i = 0; i < vertexCount; i++) {
          var curPos = positions[i];
          var curUV = uvs[i];
          vertices[vertexIndex++] = curPos.x;
          vertices[vertexIndex++] = curPos.y;
          vertices[vertexIndex++] = curPos.z;
          vertices[vertexIndex++] = curUV.x;
          vertices[vertexIndex++] = curUV.y;
          vertices[vertexIndex++] = color.r;
          vertices[vertexIndex++] = color.g;
          vertices[vertexIndex++] = color.b;
          vertices[vertexIndex++] = color.a;
        }
        return vertexIndex;
      };
      _proto.drawBatches = function drawBatches(camera, replaceMaterial) {
        var engine = this._engine, batchedQueue = this._batchedQueue;
        var mesh = this._meshes[this._flushId];
        var subMeshes = mesh.subMeshes;
        var maskManager = engine._spriteMaskManager;
        var sceneData = camera.scene.shaderData;
        var cameraData = camera.shaderData;
        for (var i = 0, len = subMeshes.length; i < len; i++) {
          var subMesh = subMeshes[i];
          var spriteElement = batchedQueue[i];
          if (!subMesh || !spriteElement) {
            return;
          }
          var renderer = spriteElement.component;
          var material = spriteElement.material;
          maskManager.preRender(camera, renderer);
          var compileMacros = Shader._compileMacros;
          ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, material.shaderData._macroCollection, compileMacros);
          (replaceMaterial || material)._preRender(spriteElement);
          var program = (replaceMaterial || material).shader._getShaderProgram(engine, compileMacros);
          if (!program.isValid) {
            return;
          }
          renderer.shaderData.setTexture(SpriteBatcher2._textureProperty, spriteElement.texture);
          program.bind();
          program.groupingOtherUniformBlock();
          program.uploadAll(program.sceneUniformBlock, sceneData);
          program.uploadAll(program.cameraUniformBlock, cameraData);
          program.uploadAll(program.rendererUniformBlock, renderer.shaderData);
          program.uploadAll(program.materialUniformBlock, material.shaderData);
          material.renderState._apply(engine, false);
          engine._hardwareRenderer.drawPrimitive(mesh, subMesh, program);
          maskManager.postRender(renderer);
        }
      };
      _proto.destroy = function destroy() {
        this._batchedQueue = null;
        var meshes = this._meshes, vertexBuffers = this._vertexBuffers, indiceBuffers = this._indiceBuffers;
        for (var i = 0, n = meshes.length; i < n; ++i) {
          meshes[i].destroy();
        }
        this._meshes = null;
        for (var _i = 0, _n = vertexBuffers.length; _i < _n; ++_i) {
          vertexBuffers[_i].destroy();
        }
        this._vertexBuffers = null;
        for (var _i2 = 0, _n2 = indiceBuffers.length; _i2 < _n2; ++_i2) {
          indiceBuffers[_i2].destroy();
        }
        this._indiceBuffers = null;
      };
      return SpriteBatcher2;
    }(Basic2DBatcher);
    SpriteBatcher._textureProperty = Shader.getPropertyByName("u_spriteTexture");
    var RenderQueue = /* @__PURE__ */ function() {
      RenderQueue2._compareFromNearToFar = function _compareFromNearToFar(a, b) {
        return a.component.priority - b.component.priority || a.component._distanceForSort - b.component._distanceForSort;
      };
      RenderQueue2._compareFromFarToNear = function _compareFromFarToNear(a, b) {
        return a.component.priority - b.component.priority || b.component._distanceForSort - a.component._distanceForSort;
      };
      function RenderQueue2(engine) {
        this.items = [];
        this._spriteBatcher = void 0;
        this._spriteBatcher = new SpriteBatcher(engine);
      }
      var _proto = RenderQueue2.prototype;
      _proto.pushPrimitive = function pushPrimitive(element) {
        this.items.push(element);
      };
      _proto.render = function render(camera, replaceMaterial, mask) {
        var items = this.items;
        if (items.length === 0) {
          return;
        }
        var engine = camera.engine, scene = camera.scene;
        var renderCount = engine._renderCount;
        var rhi = engine._hardwareRenderer;
        var sceneData = scene.shaderData;
        var cameraData = camera.shaderData;
        for (var i = 0, n = items.length; i < n; i++) {
          var item = items[i];
          var renderPassFlag = item.component.entity.layer;
          if (!(renderPassFlag & mask)) {
            continue;
          }
          if (!!item.mesh) {
            this._spriteBatcher.flush(camera, replaceMaterial);
            var compileMacros = Shader._compileMacros;
            var element = item;
            var renderer = element.component;
            var material = element.material.destroyed ? engine._magentaMaterial : element.material;
            var rendererData = renderer.shaderData;
            var materialData = material.shaderData;
            (replaceMaterial || material)._preRender(element);
            ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, materialData._macroCollection, compileMacros);
            var program = (replaceMaterial || material).shader._getShaderProgram(engine, compileMacros);
            if (!program.isValid) {
              continue;
            }
            var switchProgram = program.bind();
            var switchRenderCount = renderCount !== program._uploadRenderCount;
            if (switchRenderCount) {
              program.groupingOtherUniformBlock();
              program.uploadAll(program.sceneUniformBlock, sceneData);
              program.uploadAll(program.cameraUniformBlock, cameraData);
              program.uploadAll(program.rendererUniformBlock, rendererData);
              program.uploadAll(program.materialUniformBlock, materialData);
              program.uploadUnGroupTextures();
              program._uploadCamera = camera;
              program._uploadRenderer = renderer;
              program._uploadMaterial = material;
              program._uploadRenderCount = renderCount;
            } else {
              if (program._uploadCamera !== camera) {
                program.uploadAll(program.cameraUniformBlock, cameraData);
                program._uploadCamera = camera;
              } else if (switchProgram) {
                program.uploadTextures(program.cameraUniformBlock, cameraData);
              }
              if (program._uploadRenderer !== renderer) {
                program.uploadAll(program.rendererUniformBlock, rendererData);
                program._uploadRenderer = renderer;
              } else if (switchProgram) {
                program.uploadTextures(program.rendererUniformBlock, rendererData);
              }
              if (program._uploadMaterial !== material) {
                program.uploadAll(program.materialUniformBlock, materialData);
                program._uploadMaterial = material;
              } else if (switchProgram) {
                program.uploadTextures(program.materialUniformBlock, materialData);
              }
              if (switchProgram) {
                program.uploadUnGroupTextures();
              }
            }
            material.renderState._apply(engine, renderer.entity.transform._isFrontFaceInvert());
            rhi.drawPrimitive(element.mesh, element.subMesh, program);
          } else {
            var spriteElement = item;
            this._spriteBatcher.drawElement(spriteElement, camera, replaceMaterial);
          }
        }
        this._spriteBatcher.flush(camera, replaceMaterial);
      };
      _proto.clear = function clear() {
        this.items.length = 0;
        this._spriteBatcher.clear();
      };
      _proto.destroy = function destroy() {
        this._spriteBatcher.destroy();
        this._spriteBatcher = null;
      };
      _proto.sort = function sort(compareFunc) {
        this._quickSort(this.items, 0, this.items.length, compareFunc);
      };
      _proto._quickSort = function _quickSort(a, from, to, compareFunc) {
        while (true) {
          if (to - from <= 10) {
            this._insertionSort(a, from, to, compareFunc);
            return;
          }
          var third_index = from + to >> 1;
          var v0 = a[from];
          var v1 = a[to - 1];
          var v2 = a[third_index];
          var c01 = compareFunc(v0, v1);
          if (c01 > 0) {
            var tmp = v0;
            v0 = v1;
            v1 = tmp;
          }
          var c02 = compareFunc(v0, v2);
          if (c02 >= 0) {
            var _tmp = v0;
            v0 = v2;
            v2 = v1;
            v1 = _tmp;
          } else {
            var c12 = compareFunc(v1, v2);
            if (c12 > 0) {
              var _tmp2 = v1;
              v1 = v2;
              v2 = _tmp2;
            }
          }
          a[from] = v0;
          a[to - 1] = v2;
          var pivot = v1;
          var low_end = from + 1;
          var high_start = to - 1;
          a[third_index] = a[low_end];
          a[low_end] = pivot;
          partition:
            for (var i = low_end + 1; i < high_start; i++) {
              var element = a[i];
              var order = compareFunc(element, pivot);
              if (order < 0) {
                a[i] = a[low_end];
                a[low_end] = element;
                low_end++;
              } else if (order > 0) {
                do {
                  high_start--;
                  if (high_start == i)
                    break partition;
                  var top_elem = a[high_start];
                  order = compareFunc(top_elem, pivot);
                } while (order > 0);
                a[i] = a[high_start];
                a[high_start] = element;
                if (order < 0) {
                  element = a[i];
                  a[i] = a[low_end];
                  a[low_end] = element;
                  low_end++;
                }
              }
            }
          if (to - high_start < low_end - from) {
            this._quickSort(a, high_start, to, compareFunc);
            to = low_end;
          } else {
            this._quickSort(a, from, low_end, compareFunc);
            from = high_start;
          }
        }
      };
      _proto._insertionSort = function _insertionSort(a, from, to, compareFunc) {
        for (var i = from + 1; i < to; i++) {
          var j = void 0;
          var element = a[i];
          for (j = i - 1; j >= from; j--) {
            var tmp = a[j];
            var order = compareFunc(tmp, element);
            if (order > 0) {
              a[j + 1] = tmp;
            } else {
              break;
            }
          }
          a[j + 1] = element;
        }
      };
      return RenderQueue2;
    }();
    var BasicRenderPipeline = /* @__PURE__ */ function() {
      function BasicRenderPipeline2(camera) {
        this._opaqueQueue = void 0;
        this._transparentQueue = void 0;
        this._alphaTestQueue = void 0;
        this._allSpriteMasks = new DisorderedArray2();
        this._camera = void 0;
        this._defaultPass = void 0;
        this._renderPassArray = void 0;
        this._lastCanvasSize = new miniprogram2.Vector2();
        this._camera = camera;
        var engine = camera.engine;
        this._opaqueQueue = new RenderQueue(engine);
        this._alphaTestQueue = new RenderQueue(engine);
        this._transparentQueue = new RenderQueue(engine);
        this._renderPassArray = [];
        this._defaultPass = new RenderPass("default", 0, null, null, 0);
        this.addRenderPass(this._defaultPass);
      }
      var _proto = BasicRenderPipeline2.prototype;
      _proto.addRenderPass = function addRenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask) {
        if (priority === void 0) {
          priority = null;
        }
        if (renderTarget === void 0) {
          renderTarget = null;
        }
        if (replaceMaterial === void 0) {
          replaceMaterial = null;
        }
        if (mask === void 0) {
          mask = null;
        }
        if (typeof nameOrPass === "string") {
          var renderPass = new RenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask);
          this._renderPassArray.push(renderPass);
        } else if (nameOrPass instanceof RenderPass) {
          this._renderPassArray.push(nameOrPass);
        }
        this._renderPassArray.sort(function(p1, p2) {
          return p1.priority - p2.priority;
        });
      };
      _proto.removeRenderPass = function removeRenderPass(nameOrPass) {
        var pass;
        if (typeof nameOrPass === "string")
          pass = this.getRenderPass(nameOrPass);
        else if (nameOrPass instanceof RenderPass)
          pass = nameOrPass;
        if (pass) {
          var idx = this._renderPassArray.indexOf(pass);
          this._renderPassArray.splice(idx, 1);
        }
      };
      _proto.getRenderPass = function getRenderPass(name) {
        for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
          var pass = this._renderPassArray[i];
          if (pass.name === name)
            return pass;
        }
        return null;
      };
      _proto.destroy = function destroy() {
        this._opaqueQueue.destroy();
        this._alphaTestQueue.destroy();
        this._transparentQueue.destroy();
        this._allSpriteMasks = null;
        this._renderPassArray = null;
        this._defaultPass = null;
        this._camera = null;
      };
      _proto.render = function render(context, cubeFace, mipLevel) {
        var camera = this._camera;
        var opaqueQueue = this._opaqueQueue;
        var alphaTestQueue = this._alphaTestQueue;
        var transparentQueue = this._transparentQueue;
        camera.engine._spriteMaskManager.clear();
        opaqueQueue.clear();
        alphaTestQueue.clear();
        transparentQueue.clear();
        this._allSpriteMasks.length = 0;
        camera.engine._componentsManager.callRender(context);
        opaqueQueue.sort(RenderQueue._compareFromNearToFar);
        alphaTestQueue.sort(RenderQueue._compareFromNearToFar);
        transparentQueue.sort(RenderQueue._compareFromFarToNear);
        for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
          this._drawRenderPass(this._renderPassArray[i], camera, cubeFace, mipLevel);
        }
      };
      _proto._drawRenderPass = function _drawRenderPass(pass, camera, cubeFace, mipLevel) {
        pass.preRender(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
        if (pass.enabled) {
          var _pass$clearFlags, _pass$clearColor;
          var engine = camera.engine, scene = camera.scene;
          var background = scene.background;
          var rhi = engine._hardwareRenderer;
          var renderTarget = camera.renderTarget || pass.renderTarget;
          rhi.activeRenderTarget(renderTarget, camera, mipLevel);
          renderTarget === null || renderTarget === void 0 ? void 0 : renderTarget._setRenderTargetInfo(cubeFace, mipLevel);
          var clearFlags = (_pass$clearFlags = pass.clearFlags) != null ? _pass$clearFlags : camera.clearFlags;
          var color = (_pass$clearColor = pass.clearColor) != null ? _pass$clearColor : background.solidColor;
          if (clearFlags !== exports3.CameraClearFlags.None) {
            rhi.clearRenderTarget(camera.engine, clearFlags, color);
          }
          if (pass.renderOverride) {
            pass.render(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
          } else {
            this._opaqueQueue.render(camera, pass.replaceMaterial, pass.mask);
            this._alphaTestQueue.render(camera, pass.replaceMaterial, pass.mask);
            if (camera.clearFlags & exports3.CameraClearFlags.Color) {
              if (background.mode === exports3.BackgroundMode.Sky) {
                this._drawSky(engine, camera, background.sky);
              } else if (background.mode === exports3.BackgroundMode.Texture && background.texture) {
                this._drawBackgroundTexture(engine, background);
              }
            }
            this._transparentQueue.render(camera, pass.replaceMaterial, pass.mask);
          }
          renderTarget === null || renderTarget === void 0 ? void 0 : renderTarget._blitRenderTarget();
          renderTarget === null || renderTarget === void 0 ? void 0 : renderTarget.generateMipmaps();
        }
        pass.postRender(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
      };
      _proto.pushPrimitive = function pushPrimitive(element) {
        switch (element.material.renderQueueType) {
          case exports3.RenderQueueType.Transparent:
            this._transparentQueue.pushPrimitive(element);
            break;
          case exports3.RenderQueueType.AlphaTest:
            this._alphaTestQueue.pushPrimitive(element);
            break;
          case exports3.RenderQueueType.Opaque:
            this._opaqueQueue.pushPrimitive(element);
            break;
        }
      };
      _proto._drawBackgroundTexture = function _drawBackgroundTexture(engine, background) {
        var rhi = engine._hardwareRenderer;
        var _backgroundTextureMaterial = engine._backgroundTextureMaterial, canvas = engine.canvas;
        var mesh = background._mesh;
        if ((this._lastCanvasSize.x !== canvas.width || this._lastCanvasSize.y !== canvas.height) && background._textureFillMode !== exports3.BackgroundTextureFillMode.Fill) {
          this._lastCanvasSize.set(canvas.width, canvas.height);
          background._resizeBackgroundTexture();
        }
        var program = _backgroundTextureMaterial.shader._getShaderProgram(engine, Shader._compileMacros);
        program.bind();
        program.uploadAll(program.materialUniformBlock, _backgroundTextureMaterial.shaderData);
        program.uploadUnGroupTextures();
        _backgroundTextureMaterial.renderState._apply(engine, false);
        rhi.drawPrimitive(mesh, mesh.subMesh, program);
      };
      _proto._drawSky = function _drawSky(engine, camera, sky) {
        var material = sky.material, mesh = sky.mesh, _matrix = sky._matrix;
        if (!material) {
          Logger.warn("The material of sky is not defined.");
          return;
        }
        if (!mesh) {
          Logger.warn("The mesh of sky is not defined.");
          return;
        }
        var rhi = engine._hardwareRenderer;
        var shaderData = material.shaderData, shader = material.shader, renderState = material.renderState;
        var compileMacros = Shader._compileMacros;
        ShaderMacroCollection.unionCollection(camera._globalShaderMacro, shaderData._macroCollection, compileMacros);
        var viewMatrix = camera.viewMatrix, projectionMatrix = camera.projectionMatrix;
        _matrix.copyFrom(viewMatrix);
        var e = _matrix.elements;
        e[12] = e[13] = e[14] = 0;
        miniprogram2.Matrix.multiply(projectionMatrix, _matrix, _matrix);
        shaderData.setMatrix("u_mvpNoscale", _matrix);
        var program = shader._getShaderProgram(engine, compileMacros);
        program.bind();
        program.groupingOtherUniformBlock();
        program.uploadAll(program.materialUniformBlock, shaderData);
        program.uploadUnGroupTextures();
        renderState._apply(engine, false);
        rhi.drawPrimitive(mesh, mesh.subMesh, program);
      };
      _createClass2(BasicRenderPipeline2, [{
        key: "defaultRenderPass",
        get: function get() {
          return this._defaultPass;
        }
      }]);
      return BasicRenderPipeline2;
    }();
    var _dec$12, _class$42, _class2$4, _descriptor$3, _descriptor2$3, _descriptor3$3, _descriptor4$3, _descriptor5$3, _descriptor6$3, _descriptor7$3, _descriptor8$3, _descriptor9$3, _descriptor10$2, _descriptor11$2, _descriptor12$2, _class3;
    var MathTemp = function MathTemp2() {
    };
    MathTemp.tempVec4 = new miniprogram2.Vector4();
    MathTemp.tempVec3 = new miniprogram2.Vector3();
    MathTemp.tempVec2 = new miniprogram2.Vector2();
    var Camera = (_dec$12 = dependentComponents(Transform), _dec$12(_class$42 = (_class2$4 = (_class3 = /* @__PURE__ */ function(_Component) {
      _inheritsLoose2(Camera2, _Component);
      function Camera2(entity) {
        var _this;
        _this = _Component.call(this, entity) || this;
        _this.shaderData = new ShaderData(ShaderDataGroup.Camera);
        _this.priority = 0;
        _this.enableFrustumCulling = true;
        _this.clearFlags = exports3.CameraClearFlags.All;
        _this.cullingMask = exports3.Layer.Everything;
        _this._globalShaderMacro = new ShaderMacroCollection();
        _initializerDefineProperty(_this, "_frustum", _descriptor$3, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_renderPipeline", _descriptor2$3, _assertThisInitialized(_this));
        _this._isOrthographic = false;
        _this._isProjMatSetting = false;
        _this._nearClipPlane = 0.1;
        _this._farClipPlane = 100;
        _this._fieldOfView = 45;
        _this._orthographicSize = 10;
        _this._isProjectionDirty = true;
        _this._isInvProjMatDirty = true;
        _this._isFrustumProjectDirty = true;
        _this._customAspectRatio = void 0;
        _this._renderTarget = null;
        _initializerDefineProperty(_this, "_frustumViewChangeFlag", _descriptor3$3, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_transform", _descriptor4$3, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_isViewMatrixDirty", _descriptor5$3, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_isInvViewProjDirty", _descriptor6$3, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_projectionMatrix", _descriptor7$3, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_viewMatrix", _descriptor8$3, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_viewport", _descriptor9$3, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_inverseProjectionMatrix", _descriptor10$2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_lastAspectSize", _descriptor11$2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_invViewProjMat", _descriptor12$2, _assertThisInitialized(_this));
        var transform = _this.entity.transform;
        _this._transform = transform;
        _this._isViewMatrixDirty = transform.registerWorldChangeFlag();
        _this._isInvViewProjDirty = transform.registerWorldChangeFlag();
        _this._frustumViewChangeFlag = transform.registerWorldChangeFlag();
        _this._renderPipeline = new BasicRenderPipeline(_assertThisInitialized(_this));
        _this.shaderData._addRefCount(1);
        return _this;
      }
      var _proto = Camera2.prototype;
      _proto.resetProjectionMatrix = function resetProjectionMatrix() {
        this._isProjMatSetting = false;
        this._projMatChange();
      };
      _proto.resetAspectRatio = function resetAspectRatio() {
        this._customAspectRatio = void 0;
        this._projMatChange();
      };
      _proto.worldToViewportPoint = function worldToViewportPoint(point, out) {
        var cameraPoint = MathTemp.tempVec3;
        var viewportPoint = MathTemp.tempVec4;
        miniprogram2.Vector3.transformCoordinate(point, this.viewMatrix, cameraPoint);
        miniprogram2.Vector3.transformToVec4(cameraPoint, this.projectionMatrix, viewportPoint);
        var w = viewportPoint.w;
        out.set((viewportPoint.x / w + 1) * 0.5, (1 - viewportPoint.y / w) * 0.5, -cameraPoint.z);
        return out;
      };
      _proto.viewportToWorldPoint = function viewportToWorldPoint(point, out) {
        var nearClipPlane = this.nearClipPlane, farClipPlane = this.farClipPlane;
        var nf = 1 / (nearClipPlane - farClipPlane);
        var z;
        if (this.isOrthographic) {
          z = -point.z * 2 * nf;
          z += (farClipPlane + nearClipPlane) * nf;
        } else {
          var pointZ = point.z;
          z = -pointZ * (nearClipPlane + farClipPlane) * nf;
          z += 2 * nearClipPlane * farClipPlane * nf;
          z = z / pointZ;
        }
        this._innerViewportToWorldPoint(point.x, point.y, (z + 1) / 2, this._getInvViewProjMat(), out);
        return out;
      };
      _proto.viewportPointToRay = function viewportPointToRay(point, out) {
        var invViewProjMat = this._getInvViewProjMat();
        var origin = this._innerViewportToWorldPoint(point.x, point.y, 0, invViewProjMat, out.origin);
        var direction = this._innerViewportToWorldPoint(point.x, point.y, 1, invViewProjMat, out.direction);
        miniprogram2.Vector3.subtract(direction, origin, direction);
        direction.normalize();
        return out;
      };
      _proto.screenToViewportPoint = function screenToViewportPoint(point, out) {
        var canvas = this.engine.canvas;
        var viewport = this.viewport;
        out.x = (point.x / canvas.width - viewport.x) / viewport.z;
        out.y = (point.y / canvas.height - viewport.y) / viewport.w;
        point.z !== void 0 && (out.z = point.z);
        return out;
      };
      _proto.viewportToScreenPoint = function viewportToScreenPoint(point, out) {
        var canvas = this.engine.canvas;
        var viewport = this.viewport;
        out.x = (viewport.x + point.x * viewport.z) * canvas.width;
        out.y = (viewport.y + point.y * viewport.w) * canvas.height;
        point.z !== void 0 && (out.z = point.z);
        return out;
      };
      _proto.worldToScreenPoint = function worldToScreenPoint(point, out) {
        this.worldToViewportPoint(point, out);
        return this.viewportToScreenPoint(out, out);
      };
      _proto.screenToWorldPoint = function screenToWorldPoint(point, out) {
        this.screenToViewportPoint(point, out);
        return this.viewportToWorldPoint(out, out);
      };
      _proto.screenPointToRay = function screenPointToRay(point, out) {
        var viewportPoint = MathTemp.tempVec2;
        this.screenToViewportPoint(point, viewportPoint);
        return this.viewportPointToRay(viewportPoint, out);
      };
      _proto.render = function render(cubeFace, mipLevel) {
        if (mipLevel === void 0) {
          mipLevel = 0;
        }
        var context = this.engine._renderContext;
        context._setContext(this);
        if (this.enableFrustumCulling && (this._frustumViewChangeFlag.flag || this._isFrustumProjectDirty)) {
          this._frustum.calculateFromMatrix(context._viewProjectMatrix);
          this._frustumViewChangeFlag.flag = false;
          this._isFrustumProjectDirty = false;
        }
        this._updateShaderData(context);
        ShaderMacroCollection.unionCollection(this.scene._globalShaderMacro, this.shaderData._macroCollection, this._globalShaderMacro);
        if (mipLevel > 0 && !this.engine._hardwareRenderer.isWebGL2) {
          mipLevel = 0;
          Logger.error("mipLevel only take effect in WebGL2.0");
        }
        this._renderPipeline.render(context, cubeFace, mipLevel);
        this._engine._renderCount++;
      };
      _proto._onEnable = function _onEnable() {
        this.entity.scene._attachRenderCamera(this);
      };
      _proto._onDisable = function _onDisable() {
        this.entity.scene._detachRenderCamera(this);
      };
      _proto._onDestroy = function _onDestroy() {
        var _this$_renderPipeline;
        (_this$_renderPipeline = this._renderPipeline) === null || _this$_renderPipeline === void 0 ? void 0 : _this$_renderPipeline.destroy();
        this._isInvViewProjDirty.destroy();
        this._isViewMatrixDirty.destroy();
        this.shaderData._addRefCount(-1);
      };
      _proto._projMatChange = function _projMatChange() {
        this._isFrustumProjectDirty = true;
        this._isProjectionDirty = true;
        this._isInvProjMatDirty = true;
        this._isInvViewProjDirty.flag = true;
      };
      _proto._innerViewportToWorldPoint = function _innerViewportToWorldPoint(x, y, z, invViewProjMat, out) {
        var clipPoint = MathTemp.tempVec3;
        clipPoint.set(x * 2 - 1, 1 - y * 2, z * 2 - 1);
        miniprogram2.Vector3.transformCoordinate(clipPoint, invViewProjMat, out);
        return out;
      };
      _proto._updateShaderData = function _updateShaderData(context) {
        var shaderData = this.shaderData;
        shaderData.setMatrix(Camera2._viewMatrixProperty, this.viewMatrix);
        shaderData.setMatrix(Camera2._projectionMatrixProperty, this.projectionMatrix);
        shaderData.setMatrix(Camera2._vpMatrixProperty, context._viewProjectMatrix);
        shaderData.setMatrix(Camera2._inverseViewMatrixProperty, this._transform.worldMatrix);
        shaderData.setMatrix(Camera2._inverseProjectionMatrixProperty, this._getInverseProjectionMatrix());
        shaderData.setVector3(Camera2._cameraPositionProperty, this._transform.worldPosition);
      };
      _proto._getInvViewProjMat = function _getInvViewProjMat() {
        if (this._isInvViewProjDirty.flag) {
          this._isInvViewProjDirty.flag = false;
          miniprogram2.Matrix.multiply(this._transform.worldMatrix, this._getInverseProjectionMatrix(), this._invViewProjMat);
        }
        return this._invViewProjMat;
      };
      _proto._getInverseProjectionMatrix = function _getInverseProjectionMatrix() {
        if (this._isInvProjMatDirty) {
          this._isInvProjMatDirty = false;
          miniprogram2.Matrix.invert(this.projectionMatrix, this._inverseProjectionMatrix);
        }
        return this._inverseProjectionMatrix;
      };
      _createClass2(Camera2, [{
        key: "nearClipPlane",
        get: function get() {
          return this._nearClipPlane;
        },
        set: function set(value) {
          this._nearClipPlane = value;
          this._projMatChange();
        }
      }, {
        key: "farClipPlane",
        get: function get() {
          return this._farClipPlane;
        },
        set: function set(value) {
          this._farClipPlane = value;
          this._projMatChange();
        }
      }, {
        key: "fieldOfView",
        get: function get() {
          return this._fieldOfView;
        },
        set: function set(value) {
          this._fieldOfView = value;
          this._projMatChange();
        }
      }, {
        key: "aspectRatio",
        get: function get() {
          var _this$_customAspectRa;
          var canvas = this._entity.engine.canvas;
          return (_this$_customAspectRa = this._customAspectRatio) != null ? _this$_customAspectRa : canvas.width * this._viewport.z / (canvas.height * this._viewport.w);
        },
        set: function set(value) {
          this._customAspectRatio = value;
          this._projMatChange();
        }
      }, {
        key: "viewport",
        get: function get() {
          return this._viewport;
        },
        set: function set(value) {
          if (value !== this._viewport) {
            this._viewport.copyFrom(value);
          }
          this._projMatChange();
        }
      }, {
        key: "isOrthographic",
        get: function get() {
          return this._isOrthographic;
        },
        set: function set(value) {
          this._isOrthographic = value;
          this._projMatChange();
        }
      }, {
        key: "orthographicSize",
        get: function get() {
          return this._orthographicSize;
        },
        set: function set(value) {
          this._orthographicSize = value;
          this._projMatChange();
        }
      }, {
        key: "viewMatrix",
        get: function get() {
          if (this._isViewMatrixDirty.flag) {
            this._isViewMatrixDirty.flag = false;
            miniprogram2.Matrix.rotationTranslation(this._transform.worldRotationQuaternion, this._transform.worldPosition, this._viewMatrix);
            this._viewMatrix.invert();
          }
          return this._viewMatrix;
        }
      }, {
        key: "projectionMatrix",
        get: function get() {
          var canvas = this._entity.engine.canvas;
          if ((!this._isProjectionDirty || this._isProjMatSetting) && this._lastAspectSize.x === canvas.width && this._lastAspectSize.y === canvas.height) {
            return this._projectionMatrix;
          }
          this._isProjectionDirty = false;
          this._lastAspectSize.x = canvas.width;
          this._lastAspectSize.y = canvas.height;
          var aspectRatio = this.aspectRatio;
          if (!this._isOrthographic) {
            miniprogram2.Matrix.perspective(miniprogram2.MathUtil.degreeToRadian(this._fieldOfView), aspectRatio, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
          } else {
            var width = this._orthographicSize * aspectRatio;
            var height = this._orthographicSize;
            miniprogram2.Matrix.ortho(-width, width, -height, height, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
          }
          return this._projectionMatrix;
        },
        set: function set(value) {
          this._projectionMatrix = value;
          this._isProjMatSetting = true;
          this._projMatChange();
        }
      }, {
        key: "enableHDR",
        get: function get() {
          console.log("not implementation");
          return false;
        },
        set: function set(value) {
          console.log("not implementation");
        }
      }, {
        key: "renderTarget",
        get: function get() {
          return this._renderTarget;
        },
        set: function set(value) {
          this._renderTarget = value;
        }
      }]);
      return Camera2;
    }(Component), _class3._viewMatrixProperty = Shader.getPropertyByName("u_viewMat"), _class3._projectionMatrixProperty = Shader.getPropertyByName("u_projMat"), _class3._vpMatrixProperty = Shader.getPropertyByName("u_VPMat"), _class3._inverseViewMatrixProperty = Shader.getPropertyByName("u_viewInvMat"), _class3._inverseProjectionMatrixProperty = Shader.getPropertyByName("u_projInvMat"), _class3._cameraPositionProperty = Shader.getPropertyByName("u_cameraPos"), _class3), _descriptor$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_frustum", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.BoundingFrustum();
      }
    }), _descriptor2$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_renderPipeline", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor3$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_frustumViewChangeFlag", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor4$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_transform", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor5$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_isViewMatrixDirty", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor6$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_isInvViewProjDirty", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor7$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_projectionMatrix", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Matrix();
      }
    }), _descriptor8$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_viewMatrix", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Matrix();
      }
    }), _descriptor9$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_viewport", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Vector4(0, 0, 1, 1);
      }
    }), _descriptor10$2 = _applyDecoratedDescriptor(_class2$4.prototype, "_inverseProjectionMatrix", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Matrix();
      }
    }), _descriptor11$2 = _applyDecoratedDescriptor(_class2$4.prototype, "_lastAspectSize", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Vector2(0, 0);
      }
    }), _descriptor12$2 = _applyDecoratedDescriptor(_class2$4.prototype, "_invViewProjMat", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Matrix();
      }
    }), _class2$4)) || _class$42);
    var mimeType = {
      json: "json",
      gltf: "json",
      mtl: "json",
      prefab: "json",
      txt: "text",
      bin: "arraybuffer",
      png: "image",
      webp: "image",
      jpg: "image"
    };
    var defaultRetryCount = 1;
    var defaultTimeout = Infinity;
    var defaultInterval = 500;
    function request(url, config) {
      if (config === void 0) {
        config = {};
      }
      return new AssetPromise(function(resolve, reject, setProgress) {
        var _config$retryCount, _config$retryInterval, _config$timeout, _config$type;
        var retryCount = (_config$retryCount = config.retryCount) != null ? _config$retryCount : defaultRetryCount;
        var retryInterval = (_config$retryInterval = config.retryInterval) != null ? _config$retryInterval : defaultInterval;
        config.timeout = (_config$timeout = config.timeout) != null ? _config$timeout : defaultTimeout;
        config.type = (_config$type = config.type) != null ? _config$type : getMimeTypeFromUrl(url);
        var realRequest = config.type === "image" ? requestImage : requestRes;
        var lastError;
        var executor = new MultiExecutor(function() {
          return realRequest(url, config).onProgress(setProgress).then(function(res) {
            resolve(res);
            executor.stop();
          }).catch(function(err) {
            return lastError = err;
          });
        }, retryCount, retryInterval);
        executor.start(function() {
          reject(lastError);
        });
      });
    }
    function requestImage(url, config) {
      return new AssetPromise(function(resolve, reject) {
        var timeout = config.timeout;
        var img = new miniprogramAdapter2.Image();
        var onerror = function onerror2() {
          reject(new Error("request " + url + " fail"));
        };
        img.onerror = onerror;
        img.onabort = onerror;
        var timeoutId = -1;
        if (timeout != Infinity) {
          timeoutId = miniprogramAdapter2.window.setTimeout(function() {
            reject(new Error("request " + url + " timeout"));
          }, timeout);
        }
        img.onload = function(timeoutId2) {
          return function() {
            miniprogramAdapter2.requestAnimationFrame(function() {
              resolve(img);
              img.onload = null;
              img.onerror = null;
              img.onabort = null;
            });
            clearTimeout(timeoutId2);
          };
        }(timeoutId);
        img.crossOrigin = "anonymous";
        img.src = url;
      });
    }
    function requestRes(url, config) {
      return new AssetPromise(function(resolve, reject, setProgress) {
        var _config$method;
        var xhr = new miniprogramAdapter2.XMLHttpRequest();
        xhr.timeout = config.timeout;
        config.method = (_config$method = config.method) != null ? _config$method : "get";
        xhr.onload = function() {
          var _xhr$response;
          if (xhr.status < 200 || xhr.status >= 300) {
            reject(new Error("request failed from: " + url));
            return;
          }
          var result = (_xhr$response = xhr.response) != null ? _xhr$response : xhr.responseText;
          resolve(result);
        };
        xhr.onerror = function() {
          reject(new Error("request failed from: " + url));
        };
        xhr.ontimeout = function() {
          reject(new Error("request timeout from: " + url));
        };
        xhr.onprogress = function(e) {
          setProgress(e.loaded / e.total);
        };
        xhr.open(config.method, url, true);
        xhr.withCredentials = config.credentials === "include";
        xhr.responseType = config.type;
        var headers = config.headers;
        if (headers) {
          Object.keys(headers).forEach(function(name) {
            xhr.setRequestHeader(name, headers[name]);
          });
        }
        xhr.send(config.body);
      });
    }
    function getMimeTypeFromUrl(url) {
      var extname = url.substring(url.lastIndexOf(".") + 1);
      return mimeType[extname];
    }
    var MultiExecutor = /* @__PURE__ */ function() {
      function MultiExecutor2(execFunc, totalCount, interval) {
        this.execFunc = execFunc;
        this.totalCount = totalCount;
        this.interval = interval;
        this._timeoutId = -100;
        this._currentCount = 0;
        this.done = void 0;
        this.exec = this.exec.bind(this);
      }
      var _proto = MultiExecutor2.prototype;
      _proto.start = function start2(done) {
        this.done = done;
        this.exec();
      };
      _proto.stop = function stop() {
        clearTimeout(this._timeoutId);
      };
      _proto.exec = function exec() {
        var _this = this;
        if (this._currentCount >= this.totalCount) {
          this.done && this.done();
          return;
        }
        this._currentCount++;
        this.execFunc(this._currentCount).then(function() {
          _this._timeoutId = setTimeout(_this.exec, _this.interval);
        });
      };
      return MultiExecutor2;
    }();
    var Loader = /* @__PURE__ */ function() {
      Loader2.registerClass = function registerClass(className, classDefine) {
        this._engineObjects[className] = classDefine;
      };
      Loader2.getClass = function getClass(className) {
        return this._engineObjects[className];
      };
      function Loader2(useCache) {
        this.useCache = useCache;
        this.request = request;
      }
      return Loader2;
    }();
    Loader._engineObjects = {};
    exports3.AssetType = void 0;
    (function(AssetType) {
      AssetType["Text"] = "text";
      AssetType["JSON"] = "json";
      AssetType["Buffer"] = "buffer";
      AssetType["Texture2D"] = "texture2d";
      AssetType["TextureCube"] = "texture-cube";
      AssetType["Material"] = "material";
      AssetType["Mesh"] = "mesh";
      AssetType["AnimationClip"] = "AnimationClip";
      AssetType["AnimatorController"] = "AnimatorController";
      AssetType["Prefab"] = "prefab";
      AssetType["KTX"] = "ktx";
      AssetType["KTXCube"] = "ktx-cube";
      AssetType["Sprite"] = "sprite";
      AssetType["SpriteAtlas"] = "sprite-atlas";
      AssetType["Env"] = "environment";
      AssetType["Scene"] = "scene";
      AssetType["HDR"] = "HDR";
    })(exports3.AssetType || (exports3.AssetType = {}));
    exports3.RenderFace = void 0;
    (function(RenderFace) {
      RenderFace[RenderFace["Front"] = 0] = "Front";
      RenderFace[RenderFace["Back"] = 1] = "Back";
      RenderFace[RenderFace["Double"] = 2] = "Double";
    })(exports3.RenderFace || (exports3.RenderFace = {}));
    exports3.BlendMode = void 0;
    (function(BlendMode) {
      BlendMode[BlendMode["Normal"] = 0] = "Normal";
      BlendMode[BlendMode["Additive"] = 1] = "Additive";
    })(exports3.BlendMode || (exports3.BlendMode = {}));
    exports3.TextureCoordinate = void 0;
    (function(TextureCoordinate) {
      TextureCoordinate[TextureCoordinate["UV0"] = 0] = "UV0";
      TextureCoordinate[TextureCoordinate["UV1"] = 1] = "UV1";
      TextureCoordinate[TextureCoordinate["UV2"] = 2] = "UV2";
      TextureCoordinate[TextureCoordinate["UV3"] = 3] = "UV3";
      TextureCoordinate[TextureCoordinate["UV4"] = 4] = "UV4";
      TextureCoordinate[TextureCoordinate["UV5"] = 5] = "UV5";
      TextureCoordinate[TextureCoordinate["UV6"] = 6] = "UV6";
      TextureCoordinate[TextureCoordinate["UV7"] = 7] = "UV7";
    })(exports3.TextureCoordinate || (exports3.TextureCoordinate = {}));
    var BaseMaterial = /* @__PURE__ */ function(_Material) {
      _inheritsLoose2(BaseMaterial2, _Material);
      function BaseMaterial2(engine, shader) {
        var _this;
        _this = _Material.call(this, engine, shader) || this;
        _this._renderFace = exports3.RenderFace.Front;
        _this._isTransparent = false;
        _this._blendMode = void 0;
        _this.blendMode = exports3.BlendMode.Normal;
        _this.shaderData.setFloat(BaseMaterial2._alphaCutoffProp, 0);
        return _this;
      }
      var _proto = BaseMaterial2.prototype;
      _proto.clone = function clone() {
        var dest = new BaseMaterial2(this._engine, this.shader);
        this.cloneTo(dest);
        return dest;
      };
      _proto.cloneTo = function cloneTo(target) {
        _Material.prototype.cloneTo.call(this, target);
        target._renderFace = this._renderFace;
        target._isTransparent = this._isTransparent;
        target._blendMode = this._blendMode;
      };
      _createClass2(BaseMaterial2, [{
        key: "isTransparent",
        get: function get() {
          return this._isTransparent;
        },
        set: function set(value) {
          if (value === this._isTransparent)
            return;
          this._isTransparent = value;
          var _this$renderState = this.renderState, depthState = _this$renderState.depthState, targetBlendState = _this$renderState.blendState.targetBlendState;
          if (value) {
            targetBlendState.enabled = true;
            depthState.writeEnabled = false;
            this.renderQueueType = exports3.RenderQueueType.Transparent;
          } else {
            targetBlendState.enabled = false;
            depthState.writeEnabled = true;
            this.renderQueueType = this.shaderData.getFloat(BaseMaterial2._alphaCutoffProp) ? exports3.RenderQueueType.AlphaTest : exports3.RenderQueueType.Opaque;
          }
        }
      }, {
        key: "alphaCutoff",
        get: function get() {
          return this.shaderData.getFloat(BaseMaterial2._alphaCutoffProp);
        },
        set: function set(value) {
          this.shaderData.setFloat(BaseMaterial2._alphaCutoffProp, value);
          if (value > 0) {
            this.shaderData.enableMacro(BaseMaterial2._alphaCutoffMacro);
            this.renderQueueType = this._isTransparent ? exports3.RenderQueueType.Transparent : exports3.RenderQueueType.AlphaTest;
          } else {
            this.shaderData.disableMacro(BaseMaterial2._alphaCutoffMacro);
            this.renderQueueType = this._isTransparent ? exports3.RenderQueueType.Transparent : exports3.RenderQueueType.Opaque;
          }
        }
      }, {
        key: "renderFace",
        get: function get() {
          return this._renderFace;
        },
        set: function set(value) {
          if (value === this._renderFace)
            return;
          this._renderFace = value;
          switch (value) {
            case exports3.RenderFace.Front:
              this.renderState.rasterState.cullMode = exports3.CullMode.Back;
              break;
            case exports3.RenderFace.Back:
              this.renderState.rasterState.cullMode = exports3.CullMode.Front;
              break;
            case exports3.RenderFace.Double:
              this.renderState.rasterState.cullMode = exports3.CullMode.Off;
              break;
          }
        }
      }, {
        key: "blendMode",
        get: function get() {
          return this._blendMode;
        },
        set: function set(value) {
          if (value === this._blendMode)
            return;
          this._blendMode = value;
          var target = this.renderState.blendState.targetBlendState;
          switch (value) {
            case exports3.BlendMode.Normal:
              target.sourceColorBlendFactor = exports3.BlendFactor.SourceAlpha;
              target.destinationColorBlendFactor = exports3.BlendFactor.OneMinusSourceAlpha;
              target.sourceAlphaBlendFactor = exports3.BlendFactor.One;
              target.destinationAlphaBlendFactor = exports3.BlendFactor.OneMinusSourceAlpha;
              target.colorBlendOperation = target.alphaBlendOperation = exports3.BlendOperation.Add;
              break;
            case exports3.BlendMode.Additive:
              target.sourceColorBlendFactor = exports3.BlendFactor.SourceAlpha;
              target.destinationColorBlendFactor = exports3.BlendFactor.One;
              target.sourceAlphaBlendFactor = exports3.BlendFactor.One;
              target.destinationAlphaBlendFactor = exports3.BlendFactor.OneMinusSourceAlpha;
              target.colorBlendOperation = target.alphaBlendOperation = exports3.BlendOperation.Add;
              break;
          }
        }
      }]);
      return BaseMaterial2;
    }(Material);
    BaseMaterial._baseColorProp = Shader.getPropertyByName("u_baseColor");
    BaseMaterial._baseTextureProp = Shader.getPropertyByName("u_baseTexture");
    BaseMaterial._baseTextureMacro = Shader.getMacroByName("BASETEXTURE");
    BaseMaterial._tilingOffsetProp = Shader.getPropertyByName("u_tilingOffset");
    BaseMaterial._normalTextureProp = Shader.getPropertyByName("u_normalTexture");
    BaseMaterial._normalIntensityProp = Shader.getPropertyByName("u_normalIntensity");
    BaseMaterial._normalTextureMacro = Shader.getMacroByName("NORMALTEXTURE");
    BaseMaterial._emissiveColorProp = Shader.getPropertyByName("u_emissiveColor");
    BaseMaterial._emissiveTextureProp = Shader.getPropertyByName("u_emissiveTexture");
    BaseMaterial._emissiveTextureMacro = Shader.getMacroByName("EMISSIVETEXTURE");
    BaseMaterial._alphaCutoffProp = Shader.getPropertyByName("u_alphaCutoff");
    BaseMaterial._alphaCutoffMacro = Shader.getMacroByName("ALPHA_CUTOFF");
    var BlinnPhongMaterial = /* @__PURE__ */ function(_BaseMaterial) {
      _inheritsLoose2(BlinnPhongMaterial2, _BaseMaterial);
      function BlinnPhongMaterial2(engine) {
        var _this;
        _this = _BaseMaterial.call(this, engine, Shader.find("blinn-phong")) || this;
        var shaderData = _this.shaderData;
        shaderData.enableMacro("O3_NEED_WORLDPOS");
        shaderData.enableMacro("O3_NEED_TILINGOFFSET");
        shaderData.setColor(BlinnPhongMaterial2._baseColorProp, new miniprogram2.Color(1, 1, 1, 1));
        shaderData.setColor(BlinnPhongMaterial2._specularColorProp, new miniprogram2.Color(1, 1, 1, 1));
        shaderData.setColor(BlinnPhongMaterial2._emissiveColorProp, new miniprogram2.Color(0, 0, 0, 1));
        shaderData.setVector4(BlinnPhongMaterial2._tilingOffsetProp, new miniprogram2.Vector4(1, 1, 0, 0));
        shaderData.setFloat(BlinnPhongMaterial2._shininessProp, 16);
        shaderData.setFloat(BlinnPhongMaterial2._normalIntensityProp, 1);
        return _this;
      }
      var _proto = BlinnPhongMaterial2.prototype;
      _proto.clone = function clone() {
        var dest = new BlinnPhongMaterial2(this._engine);
        this.cloneTo(dest);
        return dest;
      };
      _createClass2(BlinnPhongMaterial2, [{
        key: "baseColor",
        get: function get() {
          return this.shaderData.getColor(BlinnPhongMaterial2._baseColorProp);
        },
        set: function set(value) {
          var baseColor = this.shaderData.getColor(BlinnPhongMaterial2._baseColorProp);
          if (value !== baseColor) {
            baseColor.copyFrom(value);
          }
        }
      }, {
        key: "baseTexture",
        get: function get() {
          return this.shaderData.getTexture(BlinnPhongMaterial2._baseTextureProp);
        },
        set: function set(value) {
          this.shaderData.setTexture(BlinnPhongMaterial2._baseTextureProp, value);
          if (value) {
            this.shaderData.enableMacro(BlinnPhongMaterial2._baseTextureMacro);
          } else {
            this.shaderData.disableMacro(BlinnPhongMaterial2._baseTextureMacro);
          }
        }
      }, {
        key: "specularColor",
        get: function get() {
          return this.shaderData.getColor(BlinnPhongMaterial2._specularColorProp);
        },
        set: function set(value) {
          var specularColor = this.shaderData.getColor(BlinnPhongMaterial2._specularColorProp);
          if (value !== specularColor) {
            specularColor.copyFrom(value);
          }
        }
      }, {
        key: "specularTexture",
        get: function get() {
          return this.shaderData.getTexture(BlinnPhongMaterial2._specularTextureProp);
        },
        set: function set(value) {
          this.shaderData.setTexture(BlinnPhongMaterial2._specularTextureProp, value);
          if (value) {
            this.shaderData.enableMacro("O3_SPECULAR_TEXTURE");
          } else {
            this.shaderData.disableMacro("O3_SPECULAR_TEXTURE");
          }
        }
      }, {
        key: "emissiveColor",
        get: function get() {
          return this.shaderData.getColor(BlinnPhongMaterial2._emissiveColorProp);
        },
        set: function set(value) {
          var emissiveColor = this.shaderData.getColor(BlinnPhongMaterial2._emissiveColorProp);
          if (value !== emissiveColor) {
            emissiveColor.copyFrom(value);
          }
        }
      }, {
        key: "emissiveTexture",
        get: function get() {
          return this.shaderData.getTexture(BlinnPhongMaterial2._emissiveTextureProp);
        },
        set: function set(value) {
          this.shaderData.setTexture(BlinnPhongMaterial2._emissiveTextureProp, value);
          if (value) {
            this.shaderData.enableMacro(BlinnPhongMaterial2._emissiveTextureMacro);
          } else {
            this.shaderData.disableMacro(BlinnPhongMaterial2._emissiveTextureMacro);
          }
        }
      }, {
        key: "normalTexture",
        get: function get() {
          return this.shaderData.getTexture(BlinnPhongMaterial2._normalTextureProp);
        },
        set: function set(value) {
          this.shaderData.setTexture(BlinnPhongMaterial2._normalTextureProp, value);
          if (value) {
            this.shaderData.enableMacro(BlinnPhongMaterial2._normalTextureMacro);
          } else {
            this.shaderData.disableMacro(BlinnPhongMaterial2._normalTextureMacro);
          }
        }
      }, {
        key: "normalIntensity",
        get: function get() {
          return this.shaderData.getFloat(BlinnPhongMaterial2._normalIntensityProp);
        },
        set: function set(value) {
          this.shaderData.setFloat(BlinnPhongMaterial2._normalIntensityProp, value);
        }
      }, {
        key: "shininess",
        get: function get() {
          return this.shaderData.getFloat(BlinnPhongMaterial2._shininessProp);
        },
        set: function set(value) {
          this.shaderData.setFloat(BlinnPhongMaterial2._shininessProp, Math.max(value, 1e-4));
        }
      }, {
        key: "tilingOffset",
        get: function get() {
          return this.shaderData.getVector4(BlinnPhongMaterial2._tilingOffsetProp);
        },
        set: function set(value) {
          var tilingOffset = this.shaderData.getVector4(BlinnPhongMaterial2._tilingOffsetProp);
          if (value !== tilingOffset) {
            tilingOffset.copyFrom(value);
          }
        }
      }]);
      return BlinnPhongMaterial2;
    }(BaseMaterial);
    BlinnPhongMaterial._specularColorProp = Shader.getPropertyByName("u_specularColor");
    BlinnPhongMaterial._shininessProp = Shader.getPropertyByName("u_shininess");
    BlinnPhongMaterial._specularTextureProp = Shader.getPropertyByName("u_specularTexture");
    var PBRBaseMaterial = /* @__PURE__ */ function(_BaseMaterial) {
      _inheritsLoose2(PBRBaseMaterial2, _BaseMaterial);
      function PBRBaseMaterial2(engine, shader) {
        var _this;
        _this = _BaseMaterial.call(this, engine, shader) || this;
        var shaderData = _this.shaderData;
        shaderData.enableMacro("O3_NEED_WORLDPOS");
        shaderData.enableMacro("O3_NEED_TILINGOFFSET");
        shaderData.setColor(PBRBaseMaterial2._baseColorProp, new miniprogram2.Color(1, 1, 1, 1));
        shaderData.setColor(PBRBaseMaterial2._emissiveColorProp, new miniprogram2.Color(0, 0, 0, 1));
        shaderData.setVector4(PBRBaseMaterial2._tilingOffsetProp, new miniprogram2.Vector4(1, 1, 0, 0));
        shaderData.setFloat(PBRBaseMaterial2._normalIntensityProp, 1);
        shaderData.setFloat(PBRBaseMaterial2._occlusionTextureIntensityProp, 1);
        shaderData.setFloat(PBRBaseMaterial2._occlusionTextureCoordProp, exports3.TextureCoordinate.UV0);
        shaderData.setFloat(PBRBaseMaterial2._clearCoatProp, 0);
        shaderData.setFloat(PBRBaseMaterial2._clearCoatRoughnessProp, 0);
        return _this;
      }
      _createClass2(PBRBaseMaterial2, [{
        key: "baseColor",
        get: function get() {
          return this.shaderData.getColor(PBRBaseMaterial2._baseColorProp);
        },
        set: function set(value) {
          var baseColor = this.shaderData.getColor(PBRBaseMaterial2._baseColorProp);
          if (value !== baseColor) {
            baseColor.copyFrom(value);
          }
        }
      }, {
        key: "baseTexture",
        get: function get() {
          return this.shaderData.getTexture(PBRBaseMaterial2._baseTextureProp);
        },
        set: function set(value) {
          this.shaderData.setTexture(PBRBaseMaterial2._baseTextureProp, value);
          if (value) {
            this.shaderData.enableMacro(PBRBaseMaterial2._baseTextureMacro);
          } else {
            this.shaderData.disableMacro(PBRBaseMaterial2._baseTextureMacro);
          }
        }
      }, {
        key: "normalTexture",
        get: function get() {
          return this.shaderData.getTexture(PBRBaseMaterial2._normalTextureProp);
        },
        set: function set(value) {
          this.shaderData.setTexture(PBRBaseMaterial2._normalTextureProp, value);
          if (value) {
            this.shaderData.enableMacro(PBRBaseMaterial2._normalTextureMacro);
          } else {
            this.shaderData.disableMacro(PBRBaseMaterial2._normalTextureMacro);
          }
        }
      }, {
        key: "normalTextureIntensity",
        get: function get() {
          return this.shaderData.getFloat(PBRBaseMaterial2._normalIntensityProp);
        },
        set: function set(value) {
          this.shaderData.setFloat(PBRBaseMaterial2._normalIntensityProp, value);
        }
      }, {
        key: "emissiveColor",
        get: function get() {
          return this.shaderData.getColor(PBRBaseMaterial2._emissiveColorProp);
        },
        set: function set(value) {
          var emissiveColor = this.shaderData.getColor(PBRBaseMaterial2._emissiveColorProp);
          if (value !== emissiveColor) {
            emissiveColor.copyFrom(value);
          }
        }
      }, {
        key: "emissiveTexture",
        get: function get() {
          return this.shaderData.getTexture(PBRBaseMaterial2._emissiveTextureProp);
        },
        set: function set(value) {
          this.shaderData.setTexture(PBRBaseMaterial2._emissiveTextureProp, value);
          if (value) {
            this.shaderData.enableMacro(PBRBaseMaterial2._emissiveTextureMacro);
          } else {
            this.shaderData.disableMacro(PBRBaseMaterial2._emissiveTextureMacro);
          }
        }
      }, {
        key: "occlusionTexture",
        get: function get() {
          return this.shaderData.getTexture(PBRBaseMaterial2._occlusionTextureProp);
        },
        set: function set(value) {
          this.shaderData.setTexture(PBRBaseMaterial2._occlusionTextureProp, value);
          if (value) {
            this.shaderData.enableMacro("OCCLUSIONTEXTURE");
          } else {
            this.shaderData.disableMacro("OCCLUSIONTEXTURE");
          }
        }
      }, {
        key: "occlusionTextureIntensity",
        get: function get() {
          return this.shaderData.getFloat(PBRBaseMaterial2._occlusionTextureIntensityProp);
        },
        set: function set(value) {
          this.shaderData.setFloat(PBRBaseMaterial2._occlusionTextureIntensityProp, value);
        }
      }, {
        key: "occlusionTextureCoord",
        get: function get() {
          return this.shaderData.getFloat(PBRBaseMaterial2._occlusionTextureCoordProp);
        },
        set: function set(value) {
          if (value > exports3.TextureCoordinate.UV1) {
            Logger.warn("Occlusion texture uv coordinate must be UV0 or UV1.");
          }
          this.shaderData.setFloat(PBRBaseMaterial2._occlusionTextureCoordProp, value);
        }
      }, {
        key: "tilingOffset",
        get: function get() {
          return this.shaderData.getVector4(PBRBaseMaterial2._tilingOffsetProp);
        },
        set: function set(value) {
          var tilingOffset = this.shaderData.getVector4(PBRBaseMaterial2._tilingOffsetProp);
          if (value !== tilingOffset) {
            tilingOffset.copyFrom(value);
          }
        }
      }, {
        key: "clearCoat",
        get: function get() {
          return this.shaderData.getFloat(PBRBaseMaterial2._clearCoatProp);
        },
        set: function set(value) {
          if (!!this.shaderData.getFloat(PBRBaseMaterial2._clearCoatProp) !== !!value) {
            if (value === 0) {
              this.shaderData.disableMacro("CLEARCOAT");
            } else {
              this.shaderData.enableMacro("CLEARCOAT");
            }
          }
          this.shaderData.setFloat(PBRBaseMaterial2._clearCoatProp, value);
        }
      }, {
        key: "clearCoatTexture",
        get: function get() {
          return this.shaderData.getTexture(PBRBaseMaterial2._clearCoatTextureProp);
        },
        set: function set(value) {
          this.shaderData.setTexture(PBRBaseMaterial2._clearCoatTextureProp, value);
          if (value) {
            this.shaderData.enableMacro("HAS_CLEARCOATTEXTURE");
          } else {
            this.shaderData.disableMacro("HAS_CLEARCOATTEXTURE");
          }
        }
      }, {
        key: "clearCoatRoughness",
        get: function get() {
          return this.shaderData.getFloat(PBRBaseMaterial2._clearCoatRoughnessProp);
        },
        set: function set(value) {
          this.shaderData.setFloat(PBRBaseMaterial2._clearCoatRoughnessProp, value);
        }
      }, {
        key: "clearCoatRoughnessTexture",
        get: function get() {
          return this.shaderData.getTexture(PBRBaseMaterial2._clearCoatRoughnessTextureProp);
        },
        set: function set(value) {
          this.shaderData.setTexture(PBRBaseMaterial2._clearCoatRoughnessTextureProp, value);
          if (value) {
            this.shaderData.enableMacro("HAS_CLEARCOATROUGHNESSTEXTURE");
          } else {
            this.shaderData.disableMacro("HAS_CLEARCOATROUGHNESSTEXTURE");
          }
        }
      }, {
        key: "clearCoatNormalTexture",
        get: function get() {
          return this.shaderData.getTexture(PBRBaseMaterial2._clearCoatNormalTextureProp);
        },
        set: function set(value) {
          this.shaderData.setTexture(PBRBaseMaterial2._clearCoatNormalTextureProp, value);
          if (value) {
            this.shaderData.enableMacro("HAS_CLEARCOATNORMALTEXTURE");
          } else {
            this.shaderData.disableMacro("HAS_CLEARCOATNORMALTEXTURE");
          }
        }
      }]);
      return PBRBaseMaterial2;
    }(BaseMaterial);
    PBRBaseMaterial._occlusionTextureIntensityProp = Shader.getPropertyByName("u_occlusionIntensity");
    PBRBaseMaterial._occlusionTextureCoordProp = Shader.getPropertyByName("u_occlusionTextureCoord");
    PBRBaseMaterial._occlusionTextureProp = Shader.getPropertyByName("u_occlusionTexture");
    PBRBaseMaterial._clearCoatProp = Shader.getPropertyByName("u_clearCoat");
    PBRBaseMaterial._clearCoatTextureProp = Shader.getPropertyByName("u_clearCoatTexture");
    PBRBaseMaterial._clearCoatRoughnessProp = Shader.getPropertyByName("u_clearCoatRoughness");
    PBRBaseMaterial._clearCoatRoughnessTextureProp = Shader.getPropertyByName("u_clearCoatRoughnessTexture");
    PBRBaseMaterial._clearCoatNormalTextureProp = Shader.getPropertyByName("u_clearCoatNormalTexture");
    var PBRMaterial = /* @__PURE__ */ function(_PBRBaseMaterial) {
      _inheritsLoose2(PBRMaterial2, _PBRBaseMaterial);
      function PBRMaterial2(engine) {
        var _this;
        _this = _PBRBaseMaterial.call(this, engine, Shader.find("pbr")) || this;
        _this.shaderData.setFloat(PBRMaterial2._metallicProp, 1);
        _this.shaderData.setFloat(PBRMaterial2._roughnessProp, 1);
        return _this;
      }
      var _proto = PBRMaterial2.prototype;
      _proto.clone = function clone() {
        var dest = new PBRMaterial2(this._engine);
        this.cloneTo(dest);
        return dest;
      };
      _createClass2(PBRMaterial2, [{
        key: "metallic",
        get: function get() {
          return this.shaderData.getFloat(PBRMaterial2._metallicProp);
        },
        set: function set(value) {
          this.shaderData.setFloat(PBRMaterial2._metallicProp, value);
        }
      }, {
        key: "roughness",
        get: function get() {
          return this.shaderData.getFloat(PBRMaterial2._roughnessProp);
        },
        set: function set(value) {
          this.shaderData.setFloat(PBRMaterial2._roughnessProp, value);
        }
      }, {
        key: "roughnessMetallicTexture",
        get: function get() {
          return this.shaderData.getTexture(PBRMaterial2._roughnessMetallicTextureProp);
        },
        set: function set(value) {
          this.shaderData.setTexture(PBRMaterial2._roughnessMetallicTextureProp, value);
          if (value) {
            this.shaderData.enableMacro("ROUGHNESSMETALLICTEXTURE");
          } else {
            this.shaderData.disableMacro("ROUGHNESSMETALLICTEXTURE");
          }
        }
      }]);
      return PBRMaterial2;
    }(PBRBaseMaterial);
    PBRMaterial._metallicProp = Shader.getPropertyByName("u_metal");
    PBRMaterial._roughnessProp = Shader.getPropertyByName("u_roughness");
    PBRMaterial._roughnessMetallicTextureProp = Shader.getPropertyByName("u_roughnessMetallicTexture");
    var PBRSpecularMaterial = /* @__PURE__ */ function(_PBRBaseMaterial) {
      _inheritsLoose2(PBRSpecularMaterial2, _PBRBaseMaterial);
      function PBRSpecularMaterial2(engine) {
        var _this;
        _this = _PBRBaseMaterial.call(this, engine, Shader.find("pbr-specular")) || this;
        _this.shaderData.setColor(PBRSpecularMaterial2._specularColorProp, new miniprogram2.Color(1, 1, 1, 1));
        _this.shaderData.setFloat(PBRSpecularMaterial2._glossinessProp, 1);
        return _this;
      }
      var _proto = PBRSpecularMaterial2.prototype;
      _proto.clone = function clone() {
        var dest = new PBRSpecularMaterial2(this._engine);
        this.cloneTo(dest);
        return dest;
      };
      _createClass2(PBRSpecularMaterial2, [{
        key: "specularColor",
        get: function get() {
          return this.shaderData.getColor(PBRSpecularMaterial2._specularColorProp);
        },
        set: function set(value) {
          var specularColor = this.shaderData.getColor(PBRSpecularMaterial2._specularColorProp);
          if (value !== specularColor) {
            specularColor.copyFrom(value);
          }
        }
      }, {
        key: "glossiness",
        get: function get() {
          return this.shaderData.getFloat(PBRSpecularMaterial2._glossinessProp);
        },
        set: function set(value) {
          this.shaderData.setFloat(PBRSpecularMaterial2._glossinessProp, value);
        }
      }, {
        key: "specularGlossinessTexture",
        get: function get() {
          return this.shaderData.getTexture(PBRSpecularMaterial2._specularGlossinessTextureProp);
        },
        set: function set(value) {
          this.shaderData.setTexture(PBRSpecularMaterial2._specularGlossinessTextureProp, value);
          if (value) {
            this.shaderData.enableMacro(PBRSpecularMaterial2._specularGlossinessTextureMacro);
          } else {
            this.shaderData.disableMacro(PBRSpecularMaterial2._specularGlossinessTextureMacro);
          }
        }
      }]);
      return PBRSpecularMaterial2;
    }(PBRBaseMaterial);
    PBRSpecularMaterial._specularColorProp = Shader.getPropertyByName("u_PBRSpecularColor");
    PBRSpecularMaterial._glossinessProp = Shader.getPropertyByName("u_glossiness");
    PBRSpecularMaterial._specularGlossinessTextureProp = Shader.getPropertyByName("u_specularGlossinessTexture");
    PBRSpecularMaterial._specularGlossinessTextureMacro = Shader.getMacroByName("SPECULARGLOSSINESSTEXTURE");
    var UnlitMaterial = /* @__PURE__ */ function(_BaseMaterial) {
      _inheritsLoose2(UnlitMaterial2, _BaseMaterial);
      function UnlitMaterial2(engine) {
        var _this;
        _this = _BaseMaterial.call(this, engine, Shader.find("unlit")) || this;
        var shaderData = _this.shaderData;
        shaderData.enableMacro("OMIT_NORMAL");
        shaderData.enableMacro("O3_NEED_TILINGOFFSET");
        shaderData.setColor(UnlitMaterial2._baseColorProp, new miniprogram2.Color(1, 1, 1, 1));
        shaderData.setVector4(UnlitMaterial2._tilingOffsetProp, new miniprogram2.Vector4(1, 1, 0, 0));
        return _this;
      }
      var _proto = UnlitMaterial2.prototype;
      _proto.clone = function clone() {
        var dest = new UnlitMaterial2(this._engine);
        this.cloneTo(dest);
        return dest;
      };
      _createClass2(UnlitMaterial2, [{
        key: "baseColor",
        get: function get() {
          return this.shaderData.getColor(UnlitMaterial2._baseColorProp);
        },
        set: function set(value) {
          var baseColor = this.shaderData.getColor(UnlitMaterial2._baseColorProp);
          if (value !== baseColor) {
            baseColor.copyFrom(value);
          }
        }
      }, {
        key: "baseTexture",
        get: function get() {
          return this.shaderData.getTexture(UnlitMaterial2._baseTextureProp);
        },
        set: function set(value) {
          this.shaderData.setTexture(UnlitMaterial2._baseTextureProp, value);
          if (value) {
            this.shaderData.enableMacro(UnlitMaterial2._baseTextureMacro);
          } else {
            this.shaderData.disableMacro(UnlitMaterial2._baseTextureMacro);
          }
        }
      }, {
        key: "tilingOffset",
        get: function get() {
          return this.shaderData.getVector4(UnlitMaterial2._tilingOffsetProp);
        },
        set: function set(value) {
          var tilingOffset = this.shaderData.getVector4(UnlitMaterial2._tilingOffsetProp);
          if (value !== tilingOffset) {
            tilingOffset.copyFrom(value);
          }
        }
      }]);
      return UnlitMaterial2;
    }(BaseMaterial);
    exports3.TextHorizontalAlignment = void 0;
    (function(TextHorizontalAlignment) {
      TextHorizontalAlignment[TextHorizontalAlignment["Left"] = 0] = "Left";
      TextHorizontalAlignment[TextHorizontalAlignment["Center"] = 1] = "Center";
      TextHorizontalAlignment[TextHorizontalAlignment["Right"] = 2] = "Right";
    })(exports3.TextHorizontalAlignment || (exports3.TextHorizontalAlignment = {}));
    exports3.TextVerticalAlignment = void 0;
    (function(TextVerticalAlignment) {
      TextVerticalAlignment[TextVerticalAlignment["Top"] = 0] = "Top";
      TextVerticalAlignment[TextVerticalAlignment["Center"] = 1] = "Center";
      TextVerticalAlignment[TextVerticalAlignment["Bottom"] = 2] = "Bottom";
    })(exports3.TextVerticalAlignment || (exports3.TextVerticalAlignment = {}));
    exports3.OverflowMode = void 0;
    (function(OverflowMode) {
      OverflowMode[OverflowMode["Overflow"] = 0] = "Overflow";
      OverflowMode[OverflowMode["Truncate"] = 1] = "Truncate";
    })(exports3.OverflowMode || (exports3.OverflowMode = {}));
    exports3.FontStyle = void 0;
    (function(FontStyle) {
      FontStyle[FontStyle["None"] = 0] = "None";
      FontStyle[FontStyle["Bold"] = 1] = "Bold";
      FontStyle[FontStyle["Italic"] = 2] = "Italic";
    })(exports3.FontStyle || (exports3.FontStyle = {}));
    var SpriteAtlas = /* @__PURE__ */ function(_RefObject) {
      _inheritsLoose2(SpriteAtlas2, _RefObject);
      var _proto = SpriteAtlas2.prototype;
      _proto.getSprite = function getSprite(name) {
        var sprite = this._sprites[this._spriteNamesToIndex[name]];
        if (!sprite) {
          console.warn("There is no sprite named " + name + " in the atlas.");
        }
        return sprite;
      };
      _proto.getSprites = function getSprites(name, outSprites) {
        outSprites.length = 0;
        var i = this._spriteNamesToIndex[name];
        if (i !== void 0) {
          var _sprites = this._sprites;
          for (; i >= 0; i--) {
            var sprite = _sprites[i];
            sprite.name === name && outSprites.push(sprite);
          }
        } else {
          console.warn("The name of the sprite you want to find is not exit in SpriteAtlas.");
        }
        return outSprites;
      };
      function SpriteAtlas2(engine) {
        var _this;
        _this = _RefObject.call(this, engine) || this;
        _this._sprites = new Array();
        _this._spriteNamesToIndex = {};
        return _this;
      }
      _proto._addSprite = function _addSprite(sprite) {
        this._spriteNamesToIndex[sprite.name] = this._sprites.push(sprite) - 1;
      };
      _proto._onDestroy = function _onDestroy() {
        this._sprites = null;
        this._spriteNamesToIndex = null;
      };
      _createClass2(SpriteAtlas2, [{
        key: "sprites",
        get: function get() {
          return this._sprites;
        }
      }]);
      return SpriteAtlas2;
    }(RefObject);
    exports3.SpriteDrawMode = void 0;
    (function(SpriteDrawMode) {
      SpriteDrawMode[SpriteDrawMode["Simple"] = 0] = "Simple";
      SpriteDrawMode[SpriteDrawMode["Sliced"] = 1] = "Sliced";
    })(exports3.SpriteDrawMode || (exports3.SpriteDrawMode = {}));
    var Sprite = /* @__PURE__ */ function(_RefObject) {
      _inheritsLoose2(Sprite2, _RefObject);
      function Sprite2(engine, texture, region, pivot, border, name) {
        var _this;
        if (texture === void 0) {
          texture = null;
        }
        if (region === void 0) {
          region = null;
        }
        if (pivot === void 0) {
          pivot = null;
        }
        if (border === void 0) {
          border = null;
        }
        if (name === void 0) {
          name = null;
        }
        _this = _RefObject.call(this, engine) || this;
        _this.name = void 0;
        _this._assetID = void 0;
        _this._width = void 0;
        _this._height = void 0;
        _this._positions = [new miniprogram2.Vector2(), new miniprogram2.Vector2(), new miniprogram2.Vector2(), new miniprogram2.Vector2()];
        _this._uvs = [new miniprogram2.Vector2(), new miniprogram2.Vector2(), new miniprogram2.Vector2(), new miniprogram2.Vector2()];
        _this._bounds = new miniprogram2.BoundingBox();
        _this._texture = null;
        _this._atlasRotated = false;
        _this._atlasRegion = new miniprogram2.Rect(0, 0, 1, 1);
        _this._atlasRegionOffset = new miniprogram2.Vector4(0, 0, 0, 0);
        _this._region = new miniprogram2.Rect(0, 0, 1, 1);
        _this._pivot = new miniprogram2.Vector2(0.5, 0.5);
        _this._border = new miniprogram2.Vector4(0, 0, 0, 0);
        _this._dirtyFlag = DirtyFlag$2.all;
        _this._updateFlagManager = new UpdateFlagManager();
        _this._texture = texture;
        region && _this._region.copyFrom(region);
        pivot && _this._pivot.copyFrom(pivot);
        border && _this._border.copyFrom(border);
        _this.name = name;
        return _this;
      }
      var _proto = Sprite2.prototype;
      _proto.clone = function clone() {
        var cloneSprite = new Sprite2(this._engine, this._texture, this._region, this._pivot, this._border, this.name);
        cloneSprite._assetID = this._assetID;
        cloneSprite._atlasRotated = this._atlasRotated;
        cloneSprite._atlasRegion.copyFrom(this._atlasRegion);
        cloneSprite._atlasRegionOffset.copyFrom(this._atlasRegionOffset);
        return cloneSprite;
      };
      _proto._registerUpdateFlag = function _registerUpdateFlag() {
        return this._updateFlagManager.createFlag(ListenerUpdateFlag);
      };
      _proto._getPositions = function _getPositions() {
        this._dirtyFlag & DirtyFlag$2.positions && this._updatePositions();
        return this._positions;
      };
      _proto._getUVs = function _getUVs() {
        this._dirtyFlag & DirtyFlag$2.uvs && this._updateUVs();
        return this._uvs;
      };
      _proto._getBounds = function _getBounds() {
        this._dirtyFlag & DirtyFlag$2.positions && this._updatePositions();
        return this._bounds;
      };
      _proto._onDestroy = function _onDestroy() {
        if (this._texture) {
          this._texture = null;
        }
      };
      _proto._calDefaultSize = function _calDefaultSize() {
        if (this._texture) {
          var _texture = this._texture, _atlasRegion = this._atlasRegion, _atlasRegionOffset = this._atlasRegionOffset, _region = this._region;
          var pixelsPerUnitReciprocal = 1 / Engine._pixelsPerUnit;
          this.width = _texture.width * _atlasRegion.width / (1 - _atlasRegionOffset.x - _atlasRegionOffset.z) * _region.width * pixelsPerUnitReciprocal;
          this.height = _texture.height * _atlasRegion.height / (1 - _atlasRegionOffset.y - _atlasRegionOffset.w) * _region.height * pixelsPerUnitReciprocal;
        }
      };
      _proto._updatePositions = function _updatePositions() {
        var blank = this._atlasRegionOffset;
        var _this$_region = this._region, regionX = _this$_region.x, regionY = _this$_region.y, regionW = _this$_region.width, regionH = _this$_region.height;
        var regionRight = 1 - regionX - regionW;
        var regionBottom = 1 - regionY - regionH;
        var left = Math.max(blank.x - regionX, 0) / regionW;
        var bottom = Math.max(blank.w - regionY, 0) / regionH;
        var right = 1 - Math.max(blank.z - regionRight, 0) / regionW;
        var top = 1 - Math.max(blank.y - regionBottom, 0) / regionH;
        var positions = this._positions;
        positions[0].set(left, bottom);
        positions[1].set(right, bottom);
        positions[2].set(left, top);
        positions[3].set(right, top);
        var _this$_bounds = this._bounds, min = _this$_bounds.min, max = _this$_bounds.max;
        min.set(left, bottom, 0);
        max.set(right, top, 0);
        this._dirtyFlag &= ~DirtyFlag$2.positions;
      };
      _proto._updateUVs = function _updateUVs() {
        var uv = this._uvs, atlasRegionOffset = this._atlasRegionOffset;
        var _this$_region2 = this._region, regionX = _this$_region2.x, regionY = _this$_region2.y, regionW = _this$_region2.width, regionH = _this$_region2.height;
        var regionRight = 1 - regionX - regionW;
        var regionBottom = 1 - regionY - regionH;
        var _this$_atlasRegion = this._atlasRegion, atlasRegionX = _this$_atlasRegion.x, atlasRegionY = _this$_atlasRegion.y, atlasRegionW = _this$_atlasRegion.width, atlasRegionH = _this$_atlasRegion.height;
        var offsetLeft = atlasRegionOffset.x, offsetTop = atlasRegionOffset.y, offsetRight = atlasRegionOffset.z, offsetBottom = atlasRegionOffset.w;
        var realWidth = atlasRegionW / (1 - offsetLeft - offsetRight);
        var realHeight = atlasRegionH / (1 - offsetTop - offsetBottom);
        var left = Math.max(regionX - offsetLeft, 0) * realWidth + atlasRegionX;
        var top = Math.max(regionBottom - offsetTop, 0) * realHeight + atlasRegionY;
        var right = atlasRegionW + atlasRegionX - Math.max(regionRight - offsetRight, 0) * realWidth;
        var bottom = atlasRegionH + atlasRegionY - Math.max(regionY - offsetBottom, 0) * realHeight;
        var _this$_border = this._border, borderLeft = _this$_border.x, borderBottom = _this$_border.y, borderRight = _this$_border.z, borderTop = _this$_border.w;
        uv[0].set(left, bottom);
        uv[1].set((regionX - offsetLeft + borderLeft * regionW) * realWidth + atlasRegionX, atlasRegionH + atlasRegionY - (regionY - offsetBottom + borderBottom * regionH) * realHeight);
        uv[2].set(atlasRegionW + atlasRegionX - (regionRight - offsetRight + borderRight * regionW) * realWidth, (regionBottom - offsetTop + borderTop * regionH) * realHeight + atlasRegionY);
        uv[3].set(right, top);
        this._dirtyFlag &= ~DirtyFlag$2.uvs;
      };
      _proto._dispatchSpriteChange = function _dispatchSpriteChange(type) {
        switch (type) {
          case SpritePropertyDirtyFlag.atlasRegionOffset:
          case SpritePropertyDirtyFlag.region:
            this._dirtyFlag |= DirtyFlag$2.all;
            break;
          case SpritePropertyDirtyFlag.atlasRegion:
          case SpritePropertyDirtyFlag.border:
            this._dirtyFlag |= DirtyFlag$2.uvs;
            break;
        }
        this._updateFlagManager.dispatch(type);
      };
      _createClass2(Sprite2, [{
        key: "texture",
        get: function get() {
          return this._texture;
        },
        set: function set(value) {
          if (this._texture !== value) {
            this._texture = value;
            this._dispatchSpriteChange(SpritePropertyDirtyFlag.texture);
          }
        }
      }, {
        key: "width",
        get: function get() {
          this._width === void 0 && this._calDefaultSize();
          return this._width;
        },
        set: function set(value) {
          if (this._width !== value) {
            this._width = value;
            this._dispatchSpriteChange(SpritePropertyDirtyFlag.size);
          }
        }
      }, {
        key: "height",
        get: function get() {
          this._height === void 0 && this._calDefaultSize();
          return this._height;
        },
        set: function set(value) {
          if (this._height !== value) {
            this._height = value;
            this._dispatchSpriteChange(SpritePropertyDirtyFlag.size);
          }
        }
      }, {
        key: "atlasRotated",
        get: function get() {
          return this._atlasRotated;
        },
        set: function set(value) {
          if (this._atlasRotated != value) {
            this._atlasRotated = value;
          }
        }
      }, {
        key: "atlasRegion",
        get: function get() {
          return this._atlasRegion;
        },
        set: function set(value) {
          var x = miniprogram2.MathUtil.clamp(value.x, 0, 1);
          var y = miniprogram2.MathUtil.clamp(value.y, 0, 1);
          this._atlasRegion.set(x, y, miniprogram2.MathUtil.clamp(value.width, 0, 1 - x), miniprogram2.MathUtil.clamp(value.height, 0, 1 - y));
          this._dispatchSpriteChange(SpritePropertyDirtyFlag.atlasRegion);
        }
      }, {
        key: "atlasRegionOffset",
        get: function get() {
          return this._atlasRegionOffset;
        },
        set: function set(value) {
          var x = miniprogram2.MathUtil.clamp(value.x, 0, 1);
          var y = miniprogram2.MathUtil.clamp(value.y, 0, 1);
          this._atlasRegionOffset.set(x, y, miniprogram2.MathUtil.clamp(value.z, 0, 1 - x), miniprogram2.MathUtil.clamp(value.w, 0, 1 - y));
          this._dispatchSpriteChange(SpritePropertyDirtyFlag.atlasRegionOffset);
        }
      }, {
        key: "region",
        get: function get() {
          return this._region;
        },
        set: function set(value) {
          var region = this._region;
          var x = miniprogram2.MathUtil.clamp(value.x, 0, 1);
          var y = miniprogram2.MathUtil.clamp(value.y, 0, 1);
          region.set(x, y, miniprogram2.MathUtil.clamp(value.width, 0, 1 - x), miniprogram2.MathUtil.clamp(value.height, 0, 1 - y));
          this._dispatchSpriteChange(SpritePropertyDirtyFlag.region);
        }
      }, {
        key: "pivot",
        get: function get() {
          return this._pivot;
        },
        set: function set(value) {
          var pivot = this._pivot;
          if (pivot === value) {
            this._dispatchSpriteChange(SpritePropertyDirtyFlag.pivot);
          } else {
            var x = value.x, y = value.y;
            if (pivot.x !== x || pivot.y !== y) {
              pivot.set(x, y);
              this._dispatchSpriteChange(SpritePropertyDirtyFlag.pivot);
            }
          }
        }
      }, {
        key: "border",
        get: function get() {
          return this._border;
        },
        set: function set(value) {
          var border = this._border;
          var x = miniprogram2.MathUtil.clamp(value.x, 0, 1);
          var y = miniprogram2.MathUtil.clamp(value.y, 0, 1);
          border.set(x, y, miniprogram2.MathUtil.clamp(value.z, 0, 1 - x), miniprogram2.MathUtil.clamp(value.w, 0, 1 - y));
          this._dispatchSpriteChange(SpritePropertyDirtyFlag.border);
        }
      }]);
      return Sprite2;
    }(RefObject);
    var DirtyFlag$2;
    (function(DirtyFlag2) {
      DirtyFlag2[DirtyFlag2["positions"] = 1] = "positions";
      DirtyFlag2[DirtyFlag2["uvs"] = 2] = "uvs";
      DirtyFlag2[DirtyFlag2["all"] = 3] = "all";
    })(DirtyFlag$2 || (DirtyFlag$2 = {}));
    var _dec2, _class$32, _class2$3;
    var SlicedSpriteAssembler = (_dec2 = StaticInterfaceImplement2(), _dec2(_class$32 = (_class2$3 = /* @__PURE__ */ function() {
      function SlicedSpriteAssembler2() {
      }
      SlicedSpriteAssembler2.resetData = function resetData(renderer) {
        var renderData = renderer._renderData;
        var positions = renderData.positions, uvs = renderData.uvs;
        if (positions.length < 16) {
          for (var i = positions.length; i < 16; i++) {
            positions.push(new miniprogram2.Vector3());
            uvs.push(new miniprogram2.Vector2());
          }
        }
        renderData.triangles = [];
      };
      SlicedSpriteAssembler2.updatePositions = function updatePositions(renderer) {
        var width = renderer.width, height = renderer.height, sprite = renderer.sprite;
        var _renderer$_renderData = renderer._renderData, positions = _renderer$_renderData.positions, uvs = _renderer$_renderData.uvs, triangles = _renderer$_renderData.triangles;
        var border = sprite.border;
        var spriteUVs = sprite._getUVs();
        var spritePositions = sprite._getPositions();
        var _spritePositions$ = spritePositions[0], left = _spritePositions$.x, bottom = _spritePositions$.y;
        var _spritePositions$2 = spritePositions[3], right = _spritePositions$2.x, top = _spritePositions$2.y;
        var expectWidth = sprite.width, expectHeight = sprite.height;
        var fixedLeft = expectWidth * border.x;
        var fixedBottom = expectHeight * border.y;
        var fixedRight = expectHeight * border.z;
        var fixedTop = expectWidth * border.w;
        var row, column;
        if (fixedLeft + fixedRight > width) {
          var widthScale = width / (fixedLeft + fixedRight);
          row = [expectWidth * left * widthScale, fixedLeft * widthScale, fixedLeft * widthScale, width - expectWidth * (1 - right) * widthScale];
        } else {
          row = [expectWidth * left, fixedLeft, width - fixedRight, width - expectWidth * (1 - right)];
        }
        if (fixedTop + fixedBottom > height) {
          var heightScale = height / (fixedTop + fixedBottom);
          column = [expectHeight * bottom * heightScale, fixedBottom * heightScale, fixedBottom * heightScale, height - expectHeight * (1 - top) * heightScale];
        } else {
          column = [expectHeight * bottom, fixedBottom, height - fixedTop, height - expectHeight * (1 - top)];
        }
        var _renderer$sprite$pivo = renderer.sprite.pivot, pivotX = _renderer$sprite$pivo.x, pivotY = _renderer$sprite$pivo.y;
        var localTransX = renderer.width * pivotX;
        var localTransY = renderer.height * pivotY;
        var worldMatrix = SlicedSpriteAssembler2._worldMatrix;
        var wE = worldMatrix.elements;
        var pWE = renderer.entity.transform.worldMatrix.elements;
        var sx = renderer.flipX ? -1 : 1;
        var sy = renderer.flipY ? -1 : 1;
        wE[0] = pWE[0] * sx, wE[1] = pWE[1] * sx, wE[2] = pWE[2] * sx;
        wE[4] = pWE[4] * sy, wE[5] = pWE[5] * sy, wE[6] = pWE[6] * sy;
        wE[8] = pWE[8], wE[9] = pWE[9], wE[10] = pWE[10];
        wE[12] = pWE[12] - localTransX * wE[0] - localTransY * wE[4];
        wE[13] = pWE[13] - localTransX * wE[1] - localTransY * wE[5];
        wE[14] = pWE[14] - localTransX * wE[2] - localTransY * wE[6];
        var vertexCount = 0;
        var realICount = 0;
        for (var i = 0; i < 4; i++) {
          var rowValue = row[i];
          var rowU = spriteUVs[i].x;
          for (var j = 0; j < 4; j++) {
            var columnValue = column[j];
            positions[vertexCount].set(wE[0] * rowValue + wE[4] * columnValue + wE[12], wE[1] * rowValue + wE[5] * columnValue + wE[13], wE[2] * rowValue + wE[6] * columnValue + wE[14]);
            uvs[vertexCount].set(rowU, spriteUVs[j].y);
            ++vertexCount;
          }
          ++realICount;
        }
        var realJCount = vertexCount / realICount;
        var indexOffset = 0;
        for (var _i = 0; _i < realICount - 1; ++_i) {
          for (var _j = 0; _j < realJCount - 1; ++_j) {
            var start2 = _i * realJCount + _j;
            triangles[indexOffset++] = start2;
            triangles[indexOffset++] = start2 + 1;
            triangles[indexOffset++] = start2 + realJCount;
            triangles[indexOffset++] = start2 + 1;
            triangles[indexOffset++] = start2 + realJCount + 1;
            triangles[indexOffset++] = start2 + realJCount;
          }
        }
        renderer._renderData.vertexCount = realICount * realJCount;
        triangles.length = (realICount - 1) * (realJCount - 1) * 6;
        var _renderer$_bounds = renderer._bounds, min = _renderer$_bounds.min, max = _renderer$_bounds.max;
        min.set(row[0], column[0], 0);
        max.set(row[3], column[3], 0);
        renderer._bounds.transform(worldMatrix);
      };
      SlicedSpriteAssembler2.updateUVs = function updateUVs(renderer) {
      };
      return SlicedSpriteAssembler2;
    }(), _class2$3._worldMatrix = new miniprogram2.Matrix(), _class2$3)) || _class$32);
    var _class$22, _descriptor$2, _descriptor2$2, _descriptor3$2, _descriptor4$2, _descriptor5$2, _descriptor6$2, _descriptor7$2, _descriptor8$2, _descriptor9$2, _descriptor10$1, _descriptor11$1, _descriptor12$1, _descriptor13$1, _class2$22;
    var SpriteRenderer = (_class$22 = (_class2$22 = /* @__PURE__ */ function(_Renderer) {
      _inheritsLoose2(SpriteRenderer2, _Renderer);
      function SpriteRenderer2(entity) {
        var _this;
        _this = _Renderer.call(this, entity) || this;
        _initializerDefineProperty(_this, "_renderData", _descriptor$2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_drawMode", _descriptor2$2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_assembler", _descriptor3$2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_color", _descriptor4$2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_sprite", _descriptor5$2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_width", _descriptor6$2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_height", _descriptor7$2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_flipX", _descriptor8$2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_flipY", _descriptor9$2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_maskLayer", _descriptor10$1, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_maskInteraction", _descriptor11$1, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_dirtyFlag", _descriptor12$1, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_spriteChangeFlag", _descriptor13$1, _assertThisInitialized(_this));
        _this._renderData = new RenderData2D(4, [], [], null, _this._color);
        _this.drawMode = exports3.SpriteDrawMode.Simple;
        _this.setMaterial(_this._engine._spriteDefaultMaterial);
        _this._onSpriteChange = _this._onSpriteChange.bind(_assertThisInitialized(_this));
        return _this;
      }
      var _proto = SpriteRenderer2.prototype;
      _proto._render = function _render(camera) {
        var _this$sprite;
        if (!((_this$sprite = this.sprite) !== null && _this$sprite !== void 0 && _this$sprite.texture) || !this.width || !this.height) {
          return;
        }
        if (this._transformChangeFlag.flag || this._dirtyFlag & DirtyFlag$1.Position) {
          this._assembler.updatePositions(this);
          this._dirtyFlag &= ~DirtyFlag$1.Position;
          this._transformChangeFlag.flag = false;
        }
        if (this._dirtyFlag & DirtyFlag$1.UV) {
          this._assembler.updateUVs(this);
          this._dirtyFlag &= ~DirtyFlag$1.UV;
        }
        var spriteElement = this._engine._spriteElementPool.getFromPool();
        spriteElement.setValue(this, this._renderData, this.getMaterial(), this.sprite.texture);
        camera._renderPipeline.pushPrimitive(spriteElement);
      };
      _proto._cloneTo = function _cloneTo(target) {
        target.sprite = this._sprite;
      };
      _proto._onDestroy = function _onDestroy() {
        this._color = null;
        this._sprite = null;
        this._assembler = null;
        this._renderData = null;
        if (this._spriteChangeFlag) {
          this._spriteChangeFlag.destroy();
          this._spriteChangeFlag = null;
        }
        _Renderer.prototype._onDestroy.call(this);
      };
      _proto._updateStencilState = function _updateStencilState() {
        var material = this.getInstanceMaterial();
        var stencilState = material.renderState.stencilState;
        var maskInteraction = this._maskInteraction;
        if (maskInteraction === exports3.SpriteMaskInteraction.None) {
          stencilState.enabled = false;
          stencilState.writeMask = 255;
          stencilState.referenceValue = 0;
          stencilState.compareFunctionFront = stencilState.compareFunctionBack = exports3.CompareFunction.Always;
        } else {
          stencilState.enabled = true;
          stencilState.writeMask = 0;
          stencilState.referenceValue = 1;
          var compare = maskInteraction === exports3.SpriteMaskInteraction.VisibleInsideMask ? exports3.CompareFunction.LessEqual : exports3.CompareFunction.Greater;
          stencilState.compareFunctionFront = compare;
          stencilState.compareFunctionBack = compare;
        }
      };
      _proto._onSpriteChange = function _onSpriteChange(dirtyFlag) {
        switch (dirtyFlag) {
          case SpritePropertyDirtyFlag.texture:
            this.shaderData.setTexture(SpriteRenderer2._textureProperty, this.sprite.texture);
            break;
          case SpritePropertyDirtyFlag.size:
            this._drawMode === exports3.SpriteDrawMode.Sliced && (this._dirtyFlag |= DirtyFlag$1.Position);
            break;
          case SpritePropertyDirtyFlag.border:
            this._drawMode === exports3.SpriteDrawMode.Sliced && (this._dirtyFlag |= DirtyFlag$1.All);
            break;
          case SpritePropertyDirtyFlag.region:
          case SpritePropertyDirtyFlag.atlasRegionOffset:
            this._dirtyFlag |= DirtyFlag$1.All;
            break;
          case SpritePropertyDirtyFlag.atlasRegion:
            this._dirtyFlag |= DirtyFlag$1.UV;
            break;
          case SpritePropertyDirtyFlag.pivot:
            this._dirtyFlag |= DirtyFlag$1.Position;
            break;
        }
      };
      _createClass2(SpriteRenderer2, [{
        key: "drawMode",
        get: function get() {
          return this._drawMode;
        },
        set: function set(drawMode) {
          if (this._drawMode !== drawMode) {
            this._drawMode = drawMode;
            switch (drawMode) {
              case exports3.SpriteDrawMode.Simple:
                this._assembler = SimpleSpriteAssembler;
                break;
              case exports3.SpriteDrawMode.Sliced:
                this._assembler = SlicedSpriteAssembler;
                break;
            }
            this._assembler.resetData(this);
            this._dirtyFlag |= DirtyFlag$1.All;
          }
        }
      }, {
        key: "sprite",
        get: function get() {
          return this._sprite;
        },
        set: function set(value) {
          if (this._sprite !== value) {
            this._sprite = value;
            this._spriteChangeFlag && this._spriteChangeFlag.destroy();
            if (value) {
              this._spriteChangeFlag = value._registerUpdateFlag();
              this._spriteChangeFlag.listener = this._onSpriteChange;
              this._dirtyFlag |= DirtyFlag$1.All;
              this.shaderData.setTexture(SpriteRenderer2._textureProperty, value.texture);
            } else {
              this._spriteChangeFlag = null;
              this.shaderData.setTexture(SpriteRenderer2._textureProperty, null);
            }
          }
        }
      }, {
        key: "color",
        get: function get() {
          return this._color;
        },
        set: function set(value) {
          if (this._color !== value) {
            this._color.copyFrom(value);
          }
        }
      }, {
        key: "width",
        get: function get() {
          if (this._width === void 0 && this._sprite) {
            this.width = this._sprite.width;
          }
          return this._width;
        },
        set: function set(value) {
          if (this._width !== value) {
            this._width = value;
            this._dirtyFlag |= DirtyFlag$1.Position;
          }
        }
      }, {
        key: "height",
        get: function get() {
          if (this._height === void 0 && this._sprite) {
            this.height = this._sprite.height;
          }
          return this._height;
        },
        set: function set(value) {
          if (this._height !== value) {
            this._height = value;
            this._dirtyFlag |= DirtyFlag$1.Position;
          }
        }
      }, {
        key: "flipX",
        get: function get() {
          return this._flipX;
        },
        set: function set(value) {
          if (this._flipX !== value) {
            this._flipX = value;
            this._dirtyFlag |= DirtyFlag$1.Position;
          }
        }
      }, {
        key: "flipY",
        get: function get() {
          return this._flipY;
        },
        set: function set(value) {
          if (this._flipY !== value) {
            this._flipY = value;
            this._dirtyFlag |= DirtyFlag$1.Position;
          }
        }
      }, {
        key: "bounds",
        get: function get() {
          var _this$sprite2;
          if (!((_this$sprite2 = this.sprite) !== null && _this$sprite2 !== void 0 && _this$sprite2.texture) || !this.width || !this.height) {
            return Engine._defaultBoundingBox;
          } else if (this._transformChangeFlag.flag || this._dirtyFlag & DirtyFlag$1.Position) {
            this._assembler.updatePositions(this);
            this._dirtyFlag &= ~DirtyFlag$1.Position;
            this._transformChangeFlag.flag = false;
          }
          return this._bounds;
        }
      }, {
        key: "maskLayer",
        get: function get() {
          return this._maskLayer;
        },
        set: function set(value) {
          this._maskLayer = value;
        }
      }, {
        key: "maskInteraction",
        get: function get() {
          return this._maskInteraction;
        },
        set: function set(value) {
          if (this._maskInteraction !== value) {
            this._maskInteraction = value;
            this._updateStencilState();
          }
        }
      }]);
      return SpriteRenderer2;
    }(Renderer), _class2$22._textureProperty = Shader.getPropertyByName("u_spriteTexture"), _class2$22), _descriptor$2 = _applyDecoratedDescriptor(_class$22.prototype, "_renderData", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor2$2 = _applyDecoratedDescriptor(_class$22.prototype, "_drawMode", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor3$2 = _applyDecoratedDescriptor(_class$22.prototype, "_assembler", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor4$2 = _applyDecoratedDescriptor(_class$22.prototype, "_color", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Color(1, 1, 1, 1);
      }
    }), _descriptor5$2 = _applyDecoratedDescriptor(_class$22.prototype, "_sprite", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return null;
      }
    }), _descriptor6$2 = _applyDecoratedDescriptor(_class$22.prototype, "_width", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return void 0;
      }
    }), _descriptor7$2 = _applyDecoratedDescriptor(_class$22.prototype, "_height", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return void 0;
      }
    }), _descriptor8$2 = _applyDecoratedDescriptor(_class$22.prototype, "_flipX", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor9$2 = _applyDecoratedDescriptor(_class$22.prototype, "_flipY", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor10$1 = _applyDecoratedDescriptor(_class$22.prototype, "_maskLayer", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return exports3.SpriteMaskLayer.Layer0;
      }
    }), _descriptor11$1 = _applyDecoratedDescriptor(_class$22.prototype, "_maskInteraction", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return exports3.SpriteMaskInteraction.None;
      }
    }), _descriptor12$1 = _applyDecoratedDescriptor(_class$22.prototype, "_dirtyFlag", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _descriptor13$1 = _applyDecoratedDescriptor(_class$22.prototype, "_spriteChangeFlag", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return null;
      }
    }), _class$22);
    var DirtyFlag$1;
    (function(DirtyFlag2) {
      DirtyFlag2[DirtyFlag2["Position"] = 1] = "Position";
      DirtyFlag2[DirtyFlag2["UV"] = 2] = "UV";
      DirtyFlag2[DirtyFlag2["All"] = 3] = "All";
    })(DirtyFlag$1 || (DirtyFlag$1 = {}));
    var FontAtlas = /* @__PURE__ */ function(_RefObject) {
      _inheritsLoose2(FontAtlas2, _RefObject);
      function FontAtlas2(engine) {
        var _this;
        _this = _RefObject.call(this, engine) || this;
        _this._charInfoMap = {};
        _this._texture = void 0;
        _this._space = 1;
        _this._curX = 1;
        _this._curY = 1;
        _this._nextY = 1;
        return _this;
      }
      var _proto = FontAtlas2.prototype;
      _proto._onDestroy = function _onDestroy() {
        this._texture.destroy();
        this._texture = null;
        this._charInfoMap = {};
      };
      _proto.uploadCharTexture = function uploadCharTexture(charInfo) {
        var width = charInfo.w, height = charInfo.h, data = charInfo.data;
        var space = this._space, texture = this.texture;
        var textureSize = texture.width;
        var offsetWidth = width + space;
        var offsetHeight = height + space;
        if (1 + offsetWidth >= textureSize || 1 + offsetHeight >= textureSize) {
          throw Error("The char fontSize is too large.");
        }
        var endX = this._curX + offsetWidth;
        if (endX >= textureSize) {
          this._curX = space;
          this._curY = this._nextY + space;
        }
        var endY = this._curY + offsetHeight;
        if (endY > this._nextY) {
          this._nextY = endY;
        }
        if (endY >= textureSize) {
          return false;
        }
        if (width > 0 && height > 0 && data) {
          texture.setPixelBuffer(data, 0, this._curX, this._curY, width, height);
          texture.generateMipmaps();
        }
        var textureSizeReciprocal = 1 / textureSize;
        var x = this._curX;
        var y = this._curY;
        var w = width;
        var h = height;
        var u0 = x * textureSizeReciprocal;
        var u1 = (x + w) * textureSizeReciprocal;
        var v0 = y * textureSizeReciprocal;
        var v1 = (y + h) * textureSizeReciprocal;
        charInfo.x = x;
        charInfo.y = y;
        var uvs = charInfo.uvs;
        uvs[0].set(u0, v0);
        uvs[1].set(u1, v0);
        uvs[2].set(u1, v1);
        uvs[3].set(u0, v1);
        this._curX += offsetWidth + space;
        return true;
      };
      _proto.addCharInfo = function addCharInfo(char, charInfo) {
        this._charInfoMap[char.charCodeAt(0)] = charInfo;
      };
      _proto.getCharInfo = function getCharInfo(char) {
        return this._charInfoMap[char.charCodeAt(0)];
      };
      _createClass2(FontAtlas2, [{
        key: "texture",
        get: function get() {
          return this._texture;
        },
        set: function set(value) {
          this._texture = value;
        }
      }]);
      return FontAtlas2;
    }(RefObject);
    var Font = /* @__PURE__ */ function(_RefObject) {
      _inheritsLoose2(Font2, _RefObject);
      Font2.createFromOS = function createFromOS(engine, name) {
        if (name === void 0) {
          name = "";
        }
        var fontMap = Font2._fontMap;
        var font = fontMap[name];
        if (font) {
          return font;
        }
        font = new Font2(engine, name);
        fontMap[name] = font;
        return font;
      };
      function Font2(engine, name) {
        var _this;
        if (name === void 0) {
          name = "";
        }
        _this = _RefObject.call(this, engine) || this;
        _this._name = "";
        _this._fontAtlases = [];
        _this._lastIndex = -1;
        _this._name = name;
        return _this;
      }
      var _proto = Font2.prototype;
      _proto._uploadCharTexture = function _uploadCharTexture(charInfo) {
        var fontAtlases = this._fontAtlases;
        var lastIndex = this._lastIndex;
        if (lastIndex === -1) {
          this._createFontAtlas();
          lastIndex++;
        }
        var fontAtlas = fontAtlases[lastIndex];
        if (!fontAtlas.uploadCharTexture(charInfo)) {
          fontAtlas = this._createFontAtlas();
          fontAtlas.uploadCharTexture(charInfo);
          lastIndex++;
        }
        this._lastIndex = lastIndex;
        charInfo.data = null;
      };
      _proto._addCharInfo = function _addCharInfo(char, charInfo) {
        var lastIndex = this._lastIndex;
        charInfo.index = lastIndex;
        this._fontAtlases[lastIndex].addCharInfo(char, charInfo);
      };
      _proto._getCharInfo = function _getCharInfo(char) {
        var fontAtlases = this._fontAtlases;
        for (var i = 0, n = fontAtlases.length; i < n; ++i) {
          var fontAtlas = fontAtlases[i];
          var charInfo = fontAtlas.getCharInfo(char);
          if (charInfo) {
            return charInfo;
          }
        }
        return null;
      };
      _proto._getTextureByIndex = function _getTextureByIndex(index) {
        var fontAtlas = this._fontAtlases[index];
        if (fontAtlas) {
          return fontAtlas.texture;
        }
        return null;
      };
      _proto._getLastIndex = function _getLastIndex() {
        return this._lastIndex;
      };
      _proto._onDestroy = function _onDestroy() {
        var fontAtlases = this._fontAtlases;
        for (var i = 0, n = fontAtlases.length; i < n; ++i) {
          fontAtlases[i].destroy(true);
        }
        fontAtlases.length = 0;
        delete Font2._fontMap[this._name];
      };
      _proto._createFontAtlas = function _createFontAtlas() {
        var engine = this.engine;
        var fontAtlas = new FontAtlas(engine);
        var texture = new Texture2D(engine, 256, 256);
        fontAtlas.texture = texture;
        this._fontAtlases.push(fontAtlas);
        return fontAtlas;
      };
      _createClass2(Font2, [{
        key: "name",
        get: function get() {
          return this._name;
        }
      }]);
      return Font2;
    }(RefObject);
    Font._fontMap = {};
    var CharRenderData = function CharRenderData2() {
      this.texture = void 0;
      this.localPositions = new miniprogram2.Vector4();
      this.renderData = void 0;
      var positions = [new miniprogram2.Vector3(), new miniprogram2.Vector3(), new miniprogram2.Vector3(), new miniprogram2.Vector3()];
      this.renderData = new RenderData2D(4, positions, null, CharRenderData2.triangles, null);
    };
    CharRenderData.triangles = [0, 2, 1, 2, 0, 3];
    var CharRenderDataPool = /* @__PURE__ */ function() {
      function CharRenderDataPool2(type, length2) {
        this._elements = [];
        this._type = void 0;
        this._type = type;
        var elements = this._elements;
        for (var i = 0; i < length2; ++i) {
          elements[i] = new type();
        }
      }
      var _proto = CharRenderDataPool2.prototype;
      _proto.get = function get() {
        if (this._elements.length > 0) {
          return this._elements.pop();
        }
        return new this._type();
      };
      _proto.put = function put(data) {
        this._elements.push(data);
      };
      return CharRenderDataPool2;
    }();
    var TextUtils = /* @__PURE__ */ function() {
      function TextUtils2() {
      }
      TextUtils2.textContext = function textContext() {
        var textContext2 = TextUtils2._textContext;
        if (!textContext2) {
          var canvas;
          try {
            canvas = new miniprogramAdapter2.OffscreenCanvas(0, 0);
          } catch (_unused) {
            canvas = miniprogramAdapter2.document.createElement("canvas");
          }
          var context = canvas.getContext("2d");
          textContext2 = {
            canvas,
            context
          };
          TextUtils2._textContext = textContext2;
        }
        return textContext2;
      };
      TextUtils2.measureFont = function measureFont(fontString) {
        var fontSizeInfoCache = TextUtils2._fontSizeInfoCache;
        var info2 = fontSizeInfoCache[fontString];
        if (info2) {
          return info2;
        }
        info2 = TextUtils2._measureFontOrChar(fontString);
        fontSizeInfoCache[fontString] = info2;
        return info2;
      };
      TextUtils2.getNativeFontString = function getNativeFontString(fontName, fontSize, style) {
        var str = style & exports3.FontStyle.Bold ? "bold " : "";
        style & exports3.FontStyle.Italic && (str += "italic ");
        if (!/([\"\'])[^\'\"]+\1/.test(fontName) && TextUtils2._genericFontFamilies.indexOf(fontName) == -1) {
          fontName = '"' + fontName + '"';
        }
        str += fontSize + "px " + fontName;
        return str;
      };
      TextUtils2.measureChar = function measureChar(char, fontString) {
        return TextUtils2._measureFontOrChar(fontString, char);
      };
      TextUtils2.measureTextWithWrap = function measureTextWithWrap(renderer) {
        var fontSize = renderer.fontSize, fontStyle = renderer.fontStyle;
        var name = renderer.font.name;
        var fontString = TextUtils2.getNativeFontString(name, fontSize, fontStyle);
        var charFont = renderer._styleFont;
        var fontSizeInfo = TextUtils2.measureFont(fontString);
        var subTexts = renderer.text.split(/(?:\r\n|\r|\n)/);
        var lines = new Array();
        var lineWidths = new Array();
        var lineMaxSizes = new Array();
        var _pixelsPerUnit = Engine._pixelsPerUnit;
        var lineHeight = fontSizeInfo.size + renderer.lineSpacing * _pixelsPerUnit;
        var wrapWidth = renderer.width * _pixelsPerUnit;
        var width = 0;
        for (var i = 0, n = subTexts.length; i < n; ++i) {
          var subText = subTexts[i];
          var chars = "";
          var charsWidth = 0;
          var maxAscent = -1;
          var maxDescent = -1;
          for (var j = 0, m = subText.length; j < m; ++j) {
            var char = subText[j];
            var charInfo = TextUtils2._getCharInfo(char, fontString, charFont);
            var w = charInfo.w, offsetY = charInfo.offsetY;
            var halfH = charInfo.h * 0.5;
            var ascent = halfH + offsetY;
            var descent = halfH - offsetY;
            if (charsWidth + w > wrapWidth) {
              if (charsWidth === 0) {
                lines.push(char);
                lineWidths.push(w);
                lineMaxSizes.push({
                  ascent,
                  descent,
                  size: ascent + descent
                });
              } else {
                lines.push(chars);
                lineWidths.push(charsWidth);
                lineMaxSizes.push({
                  ascent: maxAscent,
                  descent: maxDescent,
                  size: maxAscent + maxDescent
                });
                chars = char;
                charsWidth = charInfo.xAdvance;
                maxAscent = ascent;
                maxDescent = descent;
              }
            } else {
              chars += char;
              charsWidth += charInfo.xAdvance;
              maxAscent < ascent && (maxAscent = ascent);
              maxDescent < descent && (maxDescent = descent);
            }
          }
          if (charsWidth > 0) {
            lines.push(chars);
            lineWidths.push(charsWidth);
            lineMaxSizes.push({
              ascent: maxAscent,
              descent: maxDescent,
              size: maxAscent + maxDescent
            });
          }
        }
        var height = renderer.height * _pixelsPerUnit;
        if (renderer.overflowMode === exports3.OverflowMode.Overflow) {
          height = lineHeight * lines.length;
        }
        return {
          width,
          height,
          lines,
          lineWidths,
          lineHeight,
          lineMaxSizes
        };
      };
      TextUtils2.measureTextWithoutWrap = function measureTextWithoutWrap(renderer) {
        var fontSize = renderer.fontSize, fontStyle = renderer.fontStyle;
        var name = renderer.font.name;
        var fontString = TextUtils2.getNativeFontString(name, fontSize, fontStyle);
        var charFont = renderer._styleFont;
        var fontSizeInfo = TextUtils2.measureFont(fontString);
        var lines = renderer.text.split(/(?:\r\n|\r|\n)/);
        var lineCount = lines.length;
        var lineWidths = new Array();
        var lineMaxSizes = new Array();
        var _pixelsPerUnit = Engine._pixelsPerUnit;
        var lineHeight = fontSizeInfo.size + renderer.lineSpacing * _pixelsPerUnit;
        var width = 0;
        var height = renderer.height * _pixelsPerUnit;
        if (renderer.overflowMode === exports3.OverflowMode.Overflow) {
          height = lineHeight * lineCount;
        }
        for (var i = 0; i < lineCount; ++i) {
          var line = lines[i];
          var curWidth = 0;
          var maxAscent = -1;
          var maxDescent = -1;
          for (var j = 0, m = line.length; j < m; ++j) {
            var charInfo = TextUtils2._getCharInfo(line[j], fontString, charFont);
            curWidth += charInfo.xAdvance;
            var offsetY = charInfo.offsetY;
            var halfH = charInfo.h * 0.5;
            var ascent = halfH + offsetY;
            var descent = halfH - offsetY;
            maxAscent < ascent && (maxAscent = ascent);
            maxDescent < descent && (maxDescent = descent);
          }
          lineWidths[i] = curWidth;
          lineMaxSizes[i] = {
            ascent: maxAscent,
            descent: maxDescent,
            size: maxAscent + maxDescent
          };
          if (curWidth > width) {
            width = curWidth;
          }
        }
        return {
          width,
          height,
          lines,
          lineWidths,
          lineHeight,
          lineMaxSizes
        };
      };
      TextUtils2.getNativeFontHash = function getNativeFontHash(fontName, fontSize, style) {
        var str = style & exports3.FontStyle.Bold ? "bold" : "";
        style & exports3.FontStyle.Italic && (str += "italic");
        if (!/([\"\'])[^\'\"]+\1/.test(fontName) && TextUtils2._genericFontFamilies.indexOf(fontName) == -1) {
          fontName = "" + fontName;
        }
        str += fontSize + "px" + fontName;
        return str;
      };
      TextUtils2._measureFontOrChar = function _measureFontOrChar(fontString, char) {
        if (char === void 0) {
          char = "";
        }
        var _TextUtils$textContex = TextUtils2.textContext(), canvas = _TextUtils$textContex.canvas, context = _TextUtils$textContex.context;
        context.font = fontString;
        var measureString = char || TextUtils2._measureString;
        var width = Math.round(context.measureText(measureString).width);
        var baseline = Math.ceil(context.measureText(TextUtils2._measureBaseline).width);
        var height = baseline * TextUtils2._heightMultiplier;
        baseline = TextUtils2._baselineMultiplier * baseline | 0;
        canvas.width = width;
        canvas.height = height;
        context.font = fontString;
        context.fillStyle = "#000";
        context.clearRect(0, 0, width, height);
        context.textBaseline = "middle";
        context.fillStyle = "#fff";
        context.fillText(measureString, 0, baseline);
        var colorData = context.getImageData(0, 0, width, height).data;
        var len = colorData.length;
        var top = -1;
        var bottom = -1;
        var y;
        var ascent = 0;
        var descent = 0;
        var size = 0;
        var integerW = canvas.width;
        var integerWReciprocal = 1 / integerW;
        for (var i = 0; i < len; i += 4) {
          if (colorData[i + 3] !== 0) {
            var idx = i * 0.25;
            y = ~~(idx * integerWReciprocal);
            if (top === -1) {
              top = y;
            }
            if (y > bottom) {
              bottom = y;
            }
          }
        }
        if (top !== -1 && bottom !== -1) {
          ascent = baseline - top;
          descent = bottom - baseline + 1;
          size = ascent + descent;
        }
        var sizeInfo = {
          ascent,
          descent,
          size
        };
        if (char) {
          var data = null;
          if (size > 0) {
            var lineIntegerW = integerW * 4;
            data = new Uint8Array(colorData.buffer, top * lineIntegerW, size * lineIntegerW);
          }
          return {
            x: 0,
            y: 0,
            w: width,
            h: size,
            offsetX: 0,
            offsetY: (ascent - descent) * 0.5,
            xAdvance: width,
            uvs: [new miniprogram2.Vector2(), new miniprogram2.Vector2(), new miniprogram2.Vector2(), new miniprogram2.Vector2()],
            ascent,
            descent,
            index: 0,
            data
          };
        } else {
          return sizeInfo;
        }
      };
      TextUtils2._getCharInfo = function _getCharInfo(char, fontString, font) {
        var charInfo = font._getCharInfo(char);
        if (!charInfo) {
          charInfo = TextUtils2.measureChar(char, fontString);
          font._uploadCharTexture(charInfo);
          font._addCharInfo(char, charInfo);
        }
        return charInfo;
      };
      return TextUtils2;
    }();
    TextUtils._genericFontFamilies = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "math", "emoji", "fangsong"];
    TextUtils._measureString = "|\xC9q\xC5";
    TextUtils._measureBaseline = "M";
    TextUtils._heightMultiplier = 2;
    TextUtils._baselineMultiplier = 1.4;
    TextUtils._fontSizeInfoCache = {};
    TextUtils._textContext = null;
    var _class$12, _descriptor$1, _descriptor2$1, _descriptor3$1, _descriptor4$1, _descriptor5$1, _descriptor6$1, _descriptor7$1, _descriptor8$1, _descriptor9$1, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _class2$12;
    var TextRenderer = (_class$12 = (_class2$12 = /* @__PURE__ */ function(_Renderer) {
      _inheritsLoose2(TextRenderer2, _Renderer);
      function TextRenderer2(entity) {
        var _this;
        _this = _Renderer.call(this, entity) || this;
        _initializerDefineProperty(_this, "_styleFont", _descriptor$1, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_charRenderDatas", _descriptor2$1, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_dirtyFlag", _descriptor3$1, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_isWorldMatrixDirty", _descriptor4$1, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_color", _descriptor5$1, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_text", _descriptor6$1, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_width", _descriptor7$1, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_height", _descriptor8$1, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_localBounds", _descriptor9$1, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_font", _descriptor10, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_fontSize", _descriptor11, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_fontStyle", _descriptor12, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_lineSpacing", _descriptor13, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_horizontalAlignment", _descriptor14, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_verticalAlignment", _descriptor15, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_enableWrapping", _descriptor16, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_overflowMode", _descriptor17, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_maskInteraction", _descriptor18, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_maskLayer", _descriptor19, _assertThisInitialized(_this));
        var _assertThisInitialize = _assertThisInitialized(_this), engine = _assertThisInitialize.engine;
        _this._isWorldMatrixDirty = entity.transform._registerWorldChangeListener();
        _this._isWorldMatrixDirty.listener = function() {
          _this._setDirtyFlagTrue(DirtyFlag.WorldPosition | DirtyFlag.WorldBounds);
        };
        _this.font = Font.createFromOS(engine);
        _this.setMaterial(engine._spriteDefaultMaterial);
        return _this;
      }
      var _proto = TextRenderer2.prototype;
      _proto._render = function _render(camera) {
        if (this._text === "" || this.enableWrapping && this.width <= 0 || this.overflowMode === exports3.OverflowMode.Truncate && this.height <= 0) {
          return;
        }
        if (this._isContainDirtyFlag(DirtyFlag.MaskInteraction)) {
          this._updateStencilState();
          this._setDirtyFlagFalse(DirtyFlag.MaskInteraction);
        }
        if (this._isContainDirtyFlag(DirtyFlag.StyleFont)) {
          this._resetStyleFont();
          this._setDirtyFlagFalse(DirtyFlag.StyleFont);
        }
        if (this._isContainDirtyFlag(DirtyFlag.LocalPositionBounds)) {
          this._updateLocalData();
          this._setDirtyFlagFalse(DirtyFlag.LocalPositionBounds);
        }
        if (this._isContainDirtyFlag(DirtyFlag.WorldPosition)) {
          this._updatePosition();
          this._setDirtyFlagFalse(DirtyFlag.WorldPosition);
        }
        var spriteElementPool = this._engine._spriteElementPool;
        var textElement = this._engine._textElementPool.getFromPool();
        var charElements = textElement.charElements;
        var material = this.getMaterial();
        var charRenderDatas = this._charRenderDatas;
        var charCount = charRenderDatas.length;
        textElement.component = this;
        textElement.material = material;
        charElements.length = charCount;
        for (var i = 0; i < charCount; ++i) {
          var charRenderData = charRenderDatas[i];
          var spriteElement = spriteElementPool.getFromPool();
          spriteElement.setValue(this, charRenderData.renderData, material, charRenderData.texture);
          charElements[i] = spriteElement;
        }
        camera._renderPipeline.pushPrimitive(textElement);
      };
      _proto._onDestroy = function _onDestroy() {
        var charRenderDatas = this._charRenderDatas;
        for (var i = 0, n = charRenderDatas.length; i < n; ++i) {
          TextRenderer2._charRenderDataPool.put(charRenderDatas[i]);
        }
        charRenderDatas.length = 0;
        this._isWorldMatrixDirty.destroy();
        _Renderer.prototype._onDestroy.call(this);
      };
      _proto._cloneTo = function _cloneTo(target) {
        target.font = this._font;
      };
      _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
        return (this._dirtyFlag & type) != 0;
      };
      _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
        this._dirtyFlag |= type;
      };
      _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
        this._dirtyFlag &= ~type;
      };
      _proto._updateBounds = function _updateBounds(worldBounds) {
        miniprogram2.BoundingBox.transform(this._localBounds, this._entity.transform.worldMatrix, worldBounds);
      };
      _proto._updateStencilState = function _updateStencilState() {
        var material = this.getInstanceMaterial();
        var stencilState = material.renderState.stencilState;
        var maskInteraction = this._maskInteraction;
        if (maskInteraction === exports3.SpriteMaskInteraction.None) {
          stencilState.enabled = false;
          stencilState.writeMask = 255;
          stencilState.referenceValue = 0;
          stencilState.compareFunctionFront = stencilState.compareFunctionBack = exports3.CompareFunction.Always;
        } else {
          stencilState.enabled = true;
          stencilState.writeMask = 0;
          stencilState.referenceValue = 1;
          var compare = maskInteraction === exports3.SpriteMaskInteraction.VisibleInsideMask ? exports3.CompareFunction.LessEqual : exports3.CompareFunction.Greater;
          stencilState.compareFunctionFront = compare;
          stencilState.compareFunctionBack = compare;
        }
      };
      _proto._resetStyleFont = function _resetStyleFont() {
        var lastStyleFont = this._styleFont;
        if (lastStyleFont) {
          lastStyleFont._addRefCount(-1);
          lastStyleFont.destroy();
        }
        this._styleFont = Font.createFromOS(this.engine, TextUtils.getNativeFontHash(this.font.name, this.fontSize, this.fontStyle));
        this._styleFont._addRefCount(1);
      };
      _proto._updatePosition = function _updatePosition() {
        var transform = this.entity.transform;
        var e = transform.worldMatrix.elements;
        var charRenderDatas = this._charRenderDatas;
        var e0 = e[0], e1 = e[1], e2 = e[2];
        var e4 = e[4], e5 = e[5], e6 = e[6];
        var e12 = e[12], e13 = e[13], e14 = e[14];
        var up = TextRenderer2._tempVec31.set(e4, e5, e6);
        var right = TextRenderer2._tempVec30.set(e0, e1, e2);
        for (var i = 0, n = charRenderDatas.length; i < n; ++i) {
          var charRenderData = charRenderDatas[i];
          var localPositions = charRenderData.localPositions;
          var positions = charRenderData.renderData.positions;
          var topLeftX = localPositions.x, topLeftY = localPositions.y;
          var worldPosition0 = positions[0];
          worldPosition0.x = topLeftX * e0 + topLeftY * e4 + e12;
          worldPosition0.y = topLeftX * e1 + topLeftY * e5 + e13;
          worldPosition0.z = topLeftX * e2 + topLeftY * e6 + e14;
          var worldPosition1 = positions[1];
          miniprogram2.Vector3.scale(right, localPositions.z - topLeftX, worldPosition1);
          miniprogram2.Vector3.add(worldPosition0, worldPosition1, worldPosition1);
          var worldPosition2 = positions[2];
          miniprogram2.Vector3.scale(up, localPositions.w - topLeftY, worldPosition2);
          miniprogram2.Vector3.add(worldPosition0, worldPosition2, positions[3]);
          miniprogram2.Vector3.add(worldPosition1, worldPosition2, worldPosition2);
        }
      };
      _proto._updateLocalData = function _updateLocalData() {
        var color = this.color, horizontalAlignment = this.horizontalAlignment, verticalAlignment = this.verticalAlignment, charRenderDatas = this._charRenderDatas;
        var _this$_localBounds = this._localBounds, min = _this$_localBounds.min, max = _this$_localBounds.max;
        min.set(0, 0, 0);
        max.set(0, 0, 0);
        var _pixelsPerUnit = Engine._pixelsPerUnit;
        var pixelsPerUnitReciprocal = 1 / _pixelsPerUnit;
        var charFont = this._styleFont;
        var rendererWidth = this.width * _pixelsPerUnit;
        var halfRendererWidth = rendererWidth * 0.5;
        var rendererHeight = this.height * _pixelsPerUnit;
        var textMetrics = this.enableWrapping ? TextUtils.measureTextWithWrap(this) : TextUtils.measureTextWithoutWrap(this);
        var height = textMetrics.height, lines = textMetrics.lines, lineWidths = textMetrics.lineWidths, lineHeight = textMetrics.lineHeight, lineMaxSizes = textMetrics.lineMaxSizes;
        var charRenderDataPool = TextRenderer2._charRenderDataPool;
        var halfLineHeight = lineHeight * 0.5;
        var linesLen = lines.length;
        var startY = 0;
        var topDiff = lineHeight * 0.5 - lineMaxSizes[0].ascent;
        var bottomDiff = lineHeight * 0.5 - lineMaxSizes[linesLen - 1].descent - 1;
        switch (verticalAlignment) {
          case exports3.TextVerticalAlignment.Top:
            startY = rendererHeight * 0.5 - halfLineHeight + topDiff;
            break;
          case exports3.TextVerticalAlignment.Center:
            startY = height * 0.5 - halfLineHeight - (bottomDiff - topDiff) * 0.5;
            break;
          case exports3.TextVerticalAlignment.Bottom:
            startY = height - rendererHeight * 0.5 - halfLineHeight - bottomDiff;
            break;
        }
        var renderDataCount = 0;
        var minX = Number.MAX_SAFE_INTEGER;
        var minY = Number.MAX_SAFE_INTEGER;
        var maxX = Number.MIN_SAFE_INTEGER;
        var maxY = Number.MIN_SAFE_INTEGER;
        var lastLineIndex = linesLen - 1;
        for (var i = 0; i < linesLen; ++i) {
          var line = lines[i];
          var lineWidth = lineWidths[i];
          var startX = 0;
          switch (horizontalAlignment) {
            case exports3.TextHorizontalAlignment.Left:
              startX = -halfRendererWidth;
              break;
            case exports3.TextHorizontalAlignment.Center:
              startX = -lineWidth * 0.5;
              break;
            case exports3.TextHorizontalAlignment.Right:
              startX = halfRendererWidth - lineWidth;
              break;
          }
          for (var j = 0, m = line.length - 1; j <= m; ++j) {
            var char = line[j];
            var charInfo = charFont._getCharInfo(char);
            if (charInfo.h > 0) {
              var charRenderData = charRenderDatas[renderDataCount] || charRenderDataPool.get();
              var renderData = charRenderData.renderData, localPositions = charRenderData.localPositions;
              charRenderData.texture = charFont._getTextureByIndex(charInfo.index);
              renderData.color = color;
              renderData.uvs = charInfo.uvs;
              var w = charInfo.w, ascent = charInfo.ascent, descent = charInfo.descent;
              var left = startX * pixelsPerUnitReciprocal;
              var right = (startX + w) * pixelsPerUnitReciprocal;
              var top = (startY + ascent) * pixelsPerUnitReciprocal;
              var bottom = (startY - descent + 1) * pixelsPerUnitReciprocal;
              localPositions.set(left, top, right, bottom);
              charRenderDatas[renderDataCount] = charRenderData;
              renderDataCount++;
              i === 0 && (maxY = Math.max(maxY, top));
              i === lastLineIndex && (minY = Math.min(minY, bottom));
              j === 0 && (minX = Math.min(minX, left));
              j === m && (maxX = Math.max(maxX, right));
            }
            startX += charInfo.xAdvance;
          }
          startY -= lineHeight;
        }
        min.set(minX, minY, 0);
        max.set(maxX, maxY, 0);
        var lastRenderDataCount = charRenderDatas.length;
        if (lastRenderDataCount > renderDataCount) {
          for (var _i = renderDataCount; _i < lastRenderDataCount; ++_i) {
            charRenderDataPool.put(charRenderDatas[_i]);
          }
          charRenderDatas.length = renderDataCount;
        }
        charFont._getLastIndex() > 0 && charRenderDatas.sort(function(a, b) {
          return a.texture.instanceId - b.texture.instanceId;
        });
      };
      _createClass2(TextRenderer2, [{
        key: "color",
        get: function get() {
          return this._color;
        },
        set: function set(value) {
          if (this._color !== value) {
            this._color.copyFrom(value);
          }
        }
      }, {
        key: "text",
        get: function get() {
          return this._text;
        },
        set: function set(value) {
          value = value || "";
          if (this._text !== value) {
            this._text = value;
            this._setDirtyFlagTrue(DirtyFlag.Position);
          }
        }
      }, {
        key: "width",
        get: function get() {
          return this._width;
        },
        set: function set(value) {
          if (this._width !== value) {
            this._width = value;
            this._setDirtyFlagTrue(DirtyFlag.Position);
          }
        }
      }, {
        key: "height",
        get: function get() {
          return this._height;
        },
        set: function set(value) {
          if (this._height !== value) {
            this._height = value;
            this._setDirtyFlagTrue(DirtyFlag.Position);
          }
        }
      }, {
        key: "font",
        get: function get() {
          return this._font;
        },
        set: function set(value) {
          if (this._font !== value) {
            this._font = value;
            this._setDirtyFlagTrue(DirtyFlag.Font);
          }
        }
      }, {
        key: "fontSize",
        get: function get() {
          return this._fontSize;
        },
        set: function set(value) {
          if (this._fontSize !== value) {
            this._fontSize = value;
            this._setDirtyFlagTrue(DirtyFlag.Font);
          }
        }
      }, {
        key: "fontStyle",
        get: function get() {
          return this._fontStyle;
        },
        set: function set(value) {
          if (this.fontStyle !== value) {
            this._fontStyle = value;
            this._setDirtyFlagTrue(DirtyFlag.Font);
          }
        }
      }, {
        key: "lineSpacing",
        get: function get() {
          return this._lineSpacing;
        },
        set: function set(value) {
          if (this._lineSpacing !== value) {
            this._lineSpacing = value;
            this._setDirtyFlagTrue(DirtyFlag.Position);
          }
        }
      }, {
        key: "horizontalAlignment",
        get: function get() {
          return this._horizontalAlignment;
        },
        set: function set(value) {
          if (this._horizontalAlignment !== value) {
            this._horizontalAlignment = value;
            this._setDirtyFlagTrue(DirtyFlag.Position);
          }
        }
      }, {
        key: "verticalAlignment",
        get: function get() {
          return this._verticalAlignment;
        },
        set: function set(value) {
          if (this._verticalAlignment !== value) {
            this._verticalAlignment = value;
            this._setDirtyFlagTrue(DirtyFlag.Position);
          }
        }
      }, {
        key: "enableWrapping",
        get: function get() {
          return this._enableWrapping;
        },
        set: function set(value) {
          if (this._enableWrapping !== value) {
            this._enableWrapping = value;
            this._setDirtyFlagTrue(DirtyFlag.Position);
          }
        }
      }, {
        key: "overflowMode",
        get: function get() {
          return this._overflowMode;
        },
        set: function set(value) {
          if (this._overflowMode !== value) {
            this._overflowMode = value;
            this._setDirtyFlagTrue(DirtyFlag.Position);
          }
        }
      }, {
        key: "maskInteraction",
        get: function get() {
          return this._maskInteraction;
        },
        set: function set(value) {
          if (this._maskInteraction !== value) {
            this._maskInteraction = value;
            this._setDirtyFlagTrue(DirtyFlag.MaskInteraction);
          }
        }
      }, {
        key: "maskLayer",
        get: function get() {
          return this._maskLayer;
        },
        set: function set(value) {
          this._maskLayer = value;
        }
      }, {
        key: "bounds",
        get: function get() {
          this._isContainDirtyFlag(DirtyFlag.StyleFont) && this._resetStyleFont();
          this._isContainDirtyFlag(DirtyFlag.LocalPositionBounds) && this._updateLocalData();
          this._isContainDirtyFlag(DirtyFlag.WorldPosition) && this._updatePosition();
          this._isContainDirtyFlag(DirtyFlag.WorldBounds) && this._updateBounds(this._bounds);
          this._setDirtyFlagFalse(DirtyFlag.Font);
          return this._bounds;
        }
      }]);
      return TextRenderer2;
    }(Renderer), _class2$12._charRenderDataPool = new CharRenderDataPool(CharRenderData, 50), _class2$12._tempVec30 = new miniprogram2.Vector3(), _class2$12._tempVec31 = new miniprogram2.Vector3(), _class2$12), _descriptor$1 = _applyDecoratedDescriptor(_class$12.prototype, "_styleFont", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return null;
      }
    }), _descriptor2$1 = _applyDecoratedDescriptor(_class$12.prototype, "_charRenderDatas", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return [];
      }
    }), _descriptor3$1 = _applyDecoratedDescriptor(_class$12.prototype, "_dirtyFlag", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return DirtyFlag.Font;
      }
    }), _descriptor4$1 = _applyDecoratedDescriptor(_class$12.prototype, "_isWorldMatrixDirty", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor5$1 = _applyDecoratedDescriptor(_class$12.prototype, "_color", [deepClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.Color(1, 1, 1, 1);
      }
    }), _descriptor6$1 = _applyDecoratedDescriptor(_class$12.prototype, "_text", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return "";
      }
    }), _descriptor7$1 = _applyDecoratedDescriptor(_class$12.prototype, "_width", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _descriptor8$1 = _applyDecoratedDescriptor(_class$12.prototype, "_height", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _descriptor9$1 = _applyDecoratedDescriptor(_class$12.prototype, "_localBounds", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new miniprogram2.BoundingBox();
      }
    }), _descriptor10 = _applyDecoratedDescriptor(_class$12.prototype, "_font", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return null;
      }
    }), _descriptor11 = _applyDecoratedDescriptor(_class$12.prototype, "_fontSize", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 24;
      }
    }), _descriptor12 = _applyDecoratedDescriptor(_class$12.prototype, "_fontStyle", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return exports3.FontStyle.None;
      }
    }), _descriptor13 = _applyDecoratedDescriptor(_class$12.prototype, "_lineSpacing", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _descriptor14 = _applyDecoratedDescriptor(_class$12.prototype, "_horizontalAlignment", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return exports3.TextHorizontalAlignment.Center;
      }
    }), _descriptor15 = _applyDecoratedDescriptor(_class$12.prototype, "_verticalAlignment", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return exports3.TextVerticalAlignment.Center;
      }
    }), _descriptor16 = _applyDecoratedDescriptor(_class$12.prototype, "_enableWrapping", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor17 = _applyDecoratedDescriptor(_class$12.prototype, "_overflowMode", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return exports3.OverflowMode.Overflow;
      }
    }), _descriptor18 = _applyDecoratedDescriptor(_class$12.prototype, "_maskInteraction", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return exports3.SpriteMaskInteraction.None;
      }
    }), _descriptor19 = _applyDecoratedDescriptor(_class$12.prototype, "_maskLayer", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return exports3.SpriteMaskLayer.Layer0;
      }
    }), _class$12);
    var DirtyFlag;
    (function(DirtyFlag2) {
      DirtyFlag2[DirtyFlag2["StyleFont"] = 1] = "StyleFont";
      DirtyFlag2[DirtyFlag2["LocalPositionBounds"] = 2] = "LocalPositionBounds";
      DirtyFlag2[DirtyFlag2["WorldPosition"] = 4] = "WorldPosition";
      DirtyFlag2[DirtyFlag2["WorldBounds"] = 8] = "WorldBounds";
      DirtyFlag2[DirtyFlag2["MaskInteraction"] = 16] = "MaskInteraction";
      DirtyFlag2[DirtyFlag2["Position"] = 14] = "Position";
      DirtyFlag2[DirtyFlag2["Font"] = 15] = "Font";
    })(DirtyFlag || (DirtyFlag = {}));
    var AnimationClipCurveBinding = function AnimationClipCurveBinding2() {
      this.relativePath = void 0;
      this.type = void 0;
      this.property = void 0;
      this.curve = void 0;
    };
    var AnimationEvent = function AnimationEvent2() {
      this.time = void 0;
      this.functionName = void 0;
      this.parameter = void 0;
    };
    exports3.AnimationProperty = void 0;
    (function(AnimationProperty) {
      AnimationProperty[AnimationProperty["Position"] = 0] = "Position";
      AnimationProperty[AnimationProperty["Rotation"] = 1] = "Rotation";
      AnimationProperty[AnimationProperty["Scale"] = 2] = "Scale";
      AnimationProperty[AnimationProperty["BlendShapeWeights"] = 3] = "BlendShapeWeights";
    })(exports3.AnimationProperty || (exports3.AnimationProperty = {}));
    var Motion = function Motion2() {
    };
    var AnimationClip = /* @__PURE__ */ function(_Motion) {
      _inheritsLoose2(AnimationClip2, _Motion);
      function AnimationClip2(name) {
        var _this;
        _this = _Motion.call(this) || this;
        _this.name = name;
        _this._curveBindings = [];
        _this._length = 0;
        _this._events = [];
        return _this;
      }
      var _proto = AnimationClip2.prototype;
      _proto.addEvent = function addEvent(param, time, parameter) {
        if (typeof param === "string") {
          var _event = new AnimationEvent();
          _event.functionName = param;
          _event.time = time;
          _event.parameter = parameter;
          this._events.push(_event);
        } else {
          this._events.push(param);
        }
        this._events.sort(function(a, b) {
          return a.time - b.time;
        });
      };
      _proto.clearEvents = function clearEvents() {
        this._events.length = 0;
      };
      _proto.addCurveBinding = function addCurveBinding(relativePath, type, propertyName, curve) {
        var property;
        switch (propertyName) {
          case "position":
            property = exports3.AnimationProperty.Position;
            break;
          case "rotation":
            property = exports3.AnimationProperty.Rotation;
            break;
          case "scale":
            property = exports3.AnimationProperty.Scale;
            break;
          case "blendShapeWeights":
            property = exports3.AnimationProperty.BlendShapeWeights;
            break;
        }
        var curveBinding = new AnimationClipCurveBinding();
        curveBinding.relativePath = relativePath;
        curveBinding.type = type;
        curveBinding.property = property;
        curveBinding.curve = curve;
        if (curve.length > this._length) {
          this._length = curve.length;
        }
        this._curveBindings.push(curveBinding);
      };
      _proto.clearCurveBindings = function clearCurveBindings() {
        this._curveBindings.length = 0;
        this._length = 0;
      };
      _proto._sampleAnimation = function _sampleAnimation(entity, time) {
        var length2 = this._curveBindings.length;
        for (var i = length2 - 1; i >= 0; i--) {
          var curveData = this._curveBindings[i];
          var curve = curveData.curve, property = curveData.property, relativePath = curveData.relativePath, type = curveData.type;
          var val = curve.evaluate(time);
          var target = entity.findByName(relativePath);
          var transform = target.transform;
          if (type === Transform) {
            switch (property) {
              case exports3.AnimationProperty.Position:
                transform.position = val;
                break;
              case exports3.AnimationProperty.Rotation:
                transform.rotationQuaternion = val;
                break;
              case exports3.AnimationProperty.Scale:
                transform.scale = val;
                break;
            }
          }
        }
      };
      _createClass2(AnimationClip2, [{
        key: "events",
        get: function get() {
          return this._events;
        }
      }, {
        key: "curveBindings",
        get: function get() {
          return this._curveBindings;
        }
      }, {
        key: "length",
        get: function get() {
          return this._length;
        }
      }]);
      return AnimationClip2;
    }(Motion);
    exports3.InterpolableValueType = void 0;
    (function(InterpolableValueType) {
      InterpolableValueType[InterpolableValueType["Float"] = 0] = "Float";
      InterpolableValueType[InterpolableValueType["FloatArray"] = 1] = "FloatArray";
      InterpolableValueType[InterpolableValueType["Vector2"] = 2] = "Vector2";
      InterpolableValueType[InterpolableValueType["Vector3"] = 3] = "Vector3";
      InterpolableValueType[InterpolableValueType["Vector4"] = 4] = "Vector4";
      InterpolableValueType[InterpolableValueType["Quaternion"] = 5] = "Quaternion";
    })(exports3.InterpolableValueType || (exports3.InterpolableValueType = {}));
    var AnimatorUtils = /* @__PURE__ */ function() {
      function AnimatorUtils2() {
      }
      AnimatorUtils2.scaleWeight = function scaleWeight(s, w, out) {
        var sX = s.x;
        var sY = s.y;
        var sZ = s.z;
        out.x = sX > 0 ? Math.pow(Math.abs(sX), w) : -Math.pow(Math.abs(sX), w);
        out.y = sY > 0 ? Math.pow(Math.abs(sY), w) : -Math.pow(Math.abs(sY), w);
        out.z = sZ > 0 ? Math.pow(Math.abs(sZ), w) : -Math.pow(Math.abs(sZ), w);
      };
      AnimatorUtils2.scaleBlend = function scaleBlend(sa, sb, w, out) {
        var saw = AnimatorUtils2._tempVector30;
        var sbw = AnimatorUtils2._tempVector31;
        AnimatorUtils2.scaleWeight(sa, 1 - w, saw);
        AnimatorUtils2.scaleWeight(sb, w, sbw);
        var sng = w > 0.5 ? sb : sa;
        out.x = sng.x > 0 ? Math.abs(saw.x * sbw.x) : -Math.abs(saw.x * sbw.x);
        out.y = sng.y > 0 ? Math.abs(saw.y * sbw.y) : -Math.abs(saw.y * sbw.y);
        out.z = sng.z > 0 ? Math.abs(saw.z * sbw.z) : -Math.abs(saw.z * sbw.z);
      };
      AnimatorUtils2.quaternionWeight = function quaternionWeight(s, w, out) {
        out.x = s.x * w;
        out.y = s.y * w;
        out.z = s.z * w;
        out.w = s.w;
      };
      return AnimatorUtils2;
    }();
    AnimatorUtils._tempVector30 = new miniprogram2.Vector3();
    AnimatorUtils._tempVector31 = new miniprogram2.Vector3();
    exports3.AnimatorLayerBlendingMode = void 0;
    (function(AnimatorLayerBlendingMode) {
      AnimatorLayerBlendingMode[AnimatorLayerBlendingMode["Override"] = 0] = "Override";
      AnimatorLayerBlendingMode[AnimatorLayerBlendingMode["Additive"] = 1] = "Additive";
    })(exports3.AnimatorLayerBlendingMode || (exports3.AnimatorLayerBlendingMode = {}));
    var AnimatorStatePlayState;
    (function(AnimatorStatePlayState2) {
      AnimatorStatePlayState2[AnimatorStatePlayState2["UnStarted"] = 0] = "UnStarted";
      AnimatorStatePlayState2[AnimatorStatePlayState2["Playing"] = 1] = "Playing";
      AnimatorStatePlayState2[AnimatorStatePlayState2["Finished"] = 2] = "Finished";
    })(AnimatorStatePlayState || (AnimatorStatePlayState = {}));
    var LayerState;
    (function(LayerState2) {
      LayerState2[LayerState2["Standby"] = 0] = "Standby";
      LayerState2[LayerState2["Playing"] = 1] = "Playing";
      LayerState2[LayerState2["CrossFading"] = 2] = "CrossFading";
      LayerState2[LayerState2["FixedCrossFading"] = 3] = "FixedCrossFading";
    })(LayerState || (LayerState = {}));
    var AnimationCurveOwner = /* @__PURE__ */ function() {
      function AnimationCurveOwner2(target, type, property) {
        this.crossCurveMark = 0;
        this.crossCurveIndex = void 0;
        this.target = void 0;
        this.type = void 0;
        this.property = void 0;
        this.component = void 0;
        this.defaultValue = void 0;
        this.fixedPoseValue = void 0;
        this._hasSavedDefaultValue = false;
        this.target = target;
        this.type = type;
        this.property = property;
        switch (property) {
          case exports3.AnimationProperty.Position:
            this.defaultValue = new miniprogram2.Vector3();
            this.fixedPoseValue = new miniprogram2.Vector3();
            this.component = target.transform;
            break;
          case exports3.AnimationProperty.Rotation:
            this.defaultValue = new miniprogram2.Quaternion();
            this.fixedPoseValue = new miniprogram2.Quaternion();
            this.component = target.transform;
            break;
          case exports3.AnimationProperty.Scale:
            this.defaultValue = new miniprogram2.Vector3();
            this.fixedPoseValue = new miniprogram2.Vector3();
            this.component = target.transform;
            break;
          case exports3.AnimationProperty.BlendShapeWeights:
            this.component = target.getComponent(SkinnedMeshRenderer);
            var weightLength = this.component.blendShapeWeights.length;
            this.defaultValue = new Float32Array(weightLength);
            this.fixedPoseValue = new Float32Array(weightLength);
            break;
        }
      }
      var _proto = AnimationCurveOwner2.prototype;
      _proto.saveDefaultValue = function saveDefaultValue() {
        switch (this.property) {
          case exports3.AnimationProperty.Position:
            this.defaultValue.copyFrom(this.target.transform.position);
            break;
          case exports3.AnimationProperty.Rotation:
            this.defaultValue.copyFrom(this.target.transform.rotationQuaternion);
            break;
          case exports3.AnimationProperty.Scale:
            this.defaultValue.copyFrom(this.target.transform.scale);
            break;
          case exports3.AnimationProperty.BlendShapeWeights:
            var _ref = this.component, blendShapeWeights = _ref.blendShapeWeights;
            for (var i = 0, length2 = blendShapeWeights.length; i < length2; ++i) {
              this.defaultValue[i] = blendShapeWeights[i];
            }
            break;
        }
        this._hasSavedDefaultValue = true;
      };
      _proto.saveFixedPoseValue = function saveFixedPoseValue() {
        switch (this.property) {
          case exports3.AnimationProperty.Position:
            this.fixedPoseValue.copyFrom(this.target.transform.position);
            break;
          case exports3.AnimationProperty.Rotation:
            this.fixedPoseValue.copyFrom(this.target.transform.rotationQuaternion);
            break;
          case exports3.AnimationProperty.Scale:
            this.fixedPoseValue.copyFrom(this.target.transform.scale);
            break;
          case exports3.AnimationProperty.BlendShapeWeights:
            var _ref2 = this.component, blendShapeWeights = _ref2.blendShapeWeights;
            for (var i = 0, length2 = blendShapeWeights.length; i < length2; ++i) {
              this.fixedPoseValue[i] = this.component.blendShapeWeights[i];
            }
            break;
        }
      };
      return AnimationCurveOwner2;
    }();
    var AnimationEventHandler = function AnimationEventHandler2() {
      this.event = void 0;
      this.handlers = [];
    };
    var AnimatorStateTransition = function AnimatorStateTransition2() {
      this.duration = 0;
      this.offset = 0;
      this.exitTime = 1;
      this.destinationState = void 0;
    };
    exports3.WrapMode = void 0;
    (function(WrapMode) {
      WrapMode[WrapMode["Once"] = 0] = "Once";
      WrapMode[WrapMode["Loop"] = 1] = "Loop";
    })(exports3.WrapMode || (exports3.WrapMode = {}));
    var AnimatorStatePlayData = /* @__PURE__ */ function() {
      function AnimatorStatePlayData2() {
        this.state = void 0;
        this.stateData = void 0;
        this.frameTime = void 0;
        this.playState = void 0;
        this.clipTime = void 0;
        this.currentEventIndex = void 0;
      }
      var _proto = AnimatorStatePlayData2.prototype;
      _proto.reset = function reset(state, stateData, offsetFrameTime) {
        this.state = state;
        this.frameTime = offsetFrameTime;
        this.stateData = stateData;
        this.playState = AnimatorStatePlayState.UnStarted;
        this.clipTime = state.clipStartTime * state.clip.length;
        this.currentEventIndex = 0;
      };
      _proto.update = function update(isBackwards) {
        var state = this.state;
        var time = this.frameTime;
        var duration = state._getDuration();
        this.playState = AnimatorStatePlayState.Playing;
        if (state.wrapMode === exports3.WrapMode.Loop) {
          time = duration ? time % duration : 0;
        } else {
          if (Math.abs(time) > duration) {
            time = time < 0 ? -duration : duration;
            this.playState = AnimatorStatePlayState.Finished;
          }
        }
        if (isBackwards && time === 0) {
          this.clipTime = state.clipEndTime * state.clip.length;
        } else {
          time < 0 && (time += duration);
          this.clipTime = time + state.clipStartTime * state.clip.length;
        }
      };
      return AnimatorStatePlayData2;
    }();
    var AnimatorLayerData = /* @__PURE__ */ function() {
      function AnimatorLayerData2() {
        this.animatorStateDataMap = {};
        this.srcPlayData = new AnimatorStatePlayData();
        this.destPlayData = new AnimatorStatePlayData();
        this.layerState = LayerState.Standby;
        this.crossCurveMark = 0;
        this.manuallyTransition = new AnimatorStateTransition();
        this.crossFadeTransition = void 0;
      }
      var _proto = AnimatorLayerData2.prototype;
      _proto.switchPlayData = function switchPlayData() {
        var srcPlayData = this.destPlayData;
        var switchTemp = this.srcPlayData;
        this.srcPlayData = srcPlayData;
        this.destPlayData = switchTemp;
      };
      return AnimatorLayerData2;
    }();
    var AnimatorStateData = function AnimatorStateData2() {
      this.curveOwners = [];
      this.eventHandlers = [];
    };
    var AnimatorStateInfo = function AnimatorStateInfo2() {
      this.layerIndex = void 0;
      this.state = void 0;
    };
    var CrossCurveData = function CrossCurveData2() {
      this.curveOwner = void 0;
      this.srcCurveIndex = void 0;
      this.destCurveIndex = void 0;
    };
    var AnimatorTempValue = /* @__PURE__ */ function() {
      function AnimatorTempValue2() {
        this.vector2 = new miniprogram2.Vector2();
        this.vector3 = new miniprogram2.Vector3();
        this.vector4 = new miniprogram2.Vector4();
        this.quaternion = new miniprogram2.Quaternion();
        this._floatArrayPool = [];
      }
      var _proto = AnimatorTempValue2.prototype;
      _proto.getFloatArray = function getFloatArray(length2) {
        var floatArray = this._floatArrayPool[length2];
        if (!floatArray) {
          this._floatArrayPool[length2] = floatArray = new Float32Array(length2);
        }
        return floatArray;
      };
      return AnimatorTempValue2;
    }();
    var _class4, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _class22;
    var Animator = (_class4 = (_class22 = /* @__PURE__ */ function(_Component) {
      _inheritsLoose2(Animator2, _Component);
      function Animator2(entity) {
        var _this;
        _this = _Component.call(this, entity) || this;
        _this._animatorController = void 0;
        _initializerDefineProperty(_this, "_speed", _descriptor, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_controllerUpdateFlag", _descriptor2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_animatorLayersData", _descriptor3, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_crossCurveDataCollection", _descriptor4, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_animationCurveOwners", _descriptor5, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_crossCurveDataPool", _descriptor6, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_animationEventHandlerPool", _descriptor7, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_baseTempValue", _descriptor8, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_crossTempValue", _descriptor9, _assertThisInitialized(_this));
        return _this;
      }
      var _proto = Animator2.prototype;
      _proto.play = function play(stateName, layerIndex, normalizedTimeOffset) {
        var _this$_controllerUpda;
        if (layerIndex === void 0) {
          layerIndex = -1;
        }
        if (normalizedTimeOffset === void 0) {
          normalizedTimeOffset = 0;
        }
        if ((_this$_controllerUpda = this._controllerUpdateFlag) !== null && _this$_controllerUpda !== void 0 && _this$_controllerUpda.flag) {
          this._clearPlayData();
        }
        var animatorInfo = this._getAnimatorStateInfo(stateName, layerIndex, Animator2._animatorInfo);
        var state = animatorInfo.state;
        if (!state) {
          return;
        }
        if (!state.clip) {
          console.warn("The state named " + stateName + " has no AnimationClip data.");
          return;
        }
        var animatorLayerData = this._getAnimatorLayerData(animatorInfo.layerIndex);
        var srcPlayData = animatorLayerData.srcPlayData;
        var curState = srcPlayData.state;
        if (curState && curState !== state) {
          this._revertDefaultValue(srcPlayData.state, srcPlayData.stateData);
        }
        var animatorStateData = this._getAnimatorStateData(stateName, state, animatorLayerData);
        animatorLayerData.layerState = LayerState.Playing;
        srcPlayData.reset(state, animatorStateData, state._getDuration() * normalizedTimeOffset);
        this._saveDefaultValues(animatorStateData);
      };
      _proto._reset = function _reset() {
        var animatorController = this._animatorController;
        if (animatorController) {
          var layers = animatorController.layers;
          for (var i = 0, n = layers.length; i < n; ++i) {
            var states = layers[i].stateMachine.states;
            var animatorLayerData = this._getAnimatorLayerData(i);
            for (var j = 0, m = states.length; j < m; ++j) {
              var state = states[j];
              var animatorStateData = this._getAnimatorStateData(state.name, state, animatorLayerData);
              this._revertDefaultValue(state, animatorStateData);
            }
          }
        }
        this._clearPlayData();
      };
      _proto.crossFade = function crossFade(stateName, normalizedTransitionDuration, layerIndex, normalizedTimeOffset) {
        var _this$_controllerUpda2;
        if (layerIndex === void 0) {
          layerIndex = -1;
        }
        if (normalizedTimeOffset === void 0) {
          normalizedTimeOffset = 0;
        }
        if ((_this$_controllerUpda2 = this._controllerUpdateFlag) !== null && _this$_controllerUpda2 !== void 0 && _this$_controllerUpda2.flag) {
          this._clearPlayData();
        }
        var _this$_getAnimatorSta = this._getAnimatorStateInfo(stateName, layerIndex, Animator2._animatorInfo), state = _this$_getAnimatorSta.state;
        var _this$_getAnimatorLay = this._getAnimatorLayerData(layerIndex), manuallyTransition = _this$_getAnimatorLay.manuallyTransition;
        manuallyTransition.duration = normalizedTransitionDuration;
        manuallyTransition.offset = normalizedTimeOffset;
        manuallyTransition.destinationState = state;
        this._crossFadeByTransition(manuallyTransition, layerIndex);
      };
      _proto.update = function update(deltaTime) {
        var _this$_controllerUpda3;
        if (this.speed === 0) {
          return;
        }
        var animatorController = this._animatorController;
        if (!animatorController) {
          return;
        }
        if ((_this$_controllerUpda3 = this._controllerUpdateFlag) !== null && _this$_controllerUpda3 !== void 0 && _this$_controllerUpda3.flag) {
          return;
        }
        deltaTime *= this.speed;
        for (var i = 0, n = animatorController.layers.length; i < n; i++) {
          var animatorLayerData = this._getAnimatorLayerData(i);
          if (animatorLayerData.layerState === LayerState.Standby) {
            continue;
          }
          this._updateLayer(i, i === 0, deltaTime / 1e3);
        }
      };
      _proto.getCurrentAnimatorState = function getCurrentAnimatorState(layerIndex) {
        var _this$_animatorLayers, _this$_animatorLayers2;
        return (_this$_animatorLayers = this._animatorLayersData[layerIndex]) === null || _this$_animatorLayers === void 0 ? void 0 : (_this$_animatorLayers2 = _this$_animatorLayers.srcPlayData) === null || _this$_animatorLayers2 === void 0 ? void 0 : _this$_animatorLayers2.state;
      };
      _proto._onEnable = function _onEnable() {
        this.engine._componentsManager.addOnUpdateAnimations(this);
      };
      _proto._onDisable = function _onDisable() {
        this.engine._componentsManager.removeOnUpdateAnimations(this);
      };
      _proto._getAnimatorStateInfo = function _getAnimatorStateInfo(stateName, layerIndex, out) {
        var state = null;
        var animatorController = this._animatorController;
        if (animatorController) {
          var layers = animatorController.layers;
          if (layerIndex === -1) {
            for (var i = 0, n = layers.length; i < n; i++) {
              state = layers[i].stateMachine.findStateByName(stateName);
              if (state) {
                layerIndex = i;
                break;
              }
            }
          } else {
            state = layers[layerIndex].stateMachine.findStateByName(stateName);
          }
        }
        out.layerIndex = layerIndex;
        out.state = state;
        return out;
      };
      _proto._saveDefaultValues = function _saveDefaultValues(stateData) {
        var curveOwners = stateData.curveOwners;
        for (var i = curveOwners.length - 1; i >= 0; i--) {
          curveOwners[i].saveDefaultValue();
        }
      };
      _proto._getAnimatorStateData = function _getAnimatorStateData(stateName, animatorState, animatorLayerData) {
        var animatorStateDataCollection = animatorLayerData.animatorStateDataMap;
        var animatorStateData = animatorStateDataCollection[stateName];
        if (!animatorStateData) {
          animatorStateData = new AnimatorStateData();
          animatorStateDataCollection[stateName] = animatorStateData;
          this._saveAnimatorStateData(animatorState, animatorStateData);
          this._saveAnimatorEventHandlers(animatorState, animatorStateData);
        }
        return animatorStateData;
      };
      _proto._saveAnimatorStateData = function _saveAnimatorStateData(animatorState, animatorStateData) {
        var entity = this.entity, animationCureOwners = this._animationCurveOwners;
        var curveOwners = animatorStateData.curveOwners;
        var curves = animatorState.clip._curveBindings;
        for (var i = curves.length - 1; i >= 0; i--) {
          var curve = curves[i];
          var targetEntity = curve.relativePath === "" ? entity : entity.findByPath(curve.relativePath);
          var property = curve.property;
          var _targetEntity = targetEntity, instanceId = _targetEntity.instanceId;
          var propertyOwners = animationCureOwners[instanceId] || (animationCureOwners[instanceId] = []);
          curveOwners[i] = propertyOwners[property] || (propertyOwners[property] = new AnimationCurveOwner(targetEntity, curve.type, property));
        }
      };
      _proto._saveAnimatorEventHandlers = function _saveAnimatorEventHandlers(state, animatorStateData) {
        var eventHandlerPool = this._animationEventHandlerPool;
        var scripts = this._entity._scripts;
        var scriptCount = scripts.length;
        var eventHandlers = animatorStateData.eventHandlers;
        var events = state.clip.events;
        eventHandlers.length = 0;
        for (var i = 0, n = events.length; i < n; i++) {
          var event = events[i];
          var eventHandler = eventHandlerPool.getFromPool();
          var funcName = event.functionName;
          var handlers = eventHandler.handlers;
          eventHandler.event = event;
          handlers.length = 0;
          for (var j = scriptCount - 1; j >= 0; j--) {
            var handler = scripts.get(j)[funcName];
            handler && handlers.push(handler);
          }
          eventHandlers.push(eventHandler);
        }
      };
      _proto._clearCrossData = function _clearCrossData(animatorLayerData) {
        animatorLayerData.crossCurveMark++;
        this._crossCurveDataCollection.length = 0;
        this._crossCurveDataPool.resetPool();
      };
      _proto._addCrossCurveData = function _addCrossCurveData(crossCurveData, owner, curCurveIndex, nextCurveIndex) {
        var dataItem = this._crossCurveDataPool.getFromPool();
        dataItem.curveOwner = owner;
        dataItem.srcCurveIndex = curCurveIndex;
        dataItem.destCurveIndex = nextCurveIndex;
        crossCurveData.push(dataItem);
      };
      _proto._prepareCrossFading = function _prepareCrossFading(animatorLayerData) {
        var crossCurveData = this._crossCurveDataCollection;
        var crossCurveMark = animatorLayerData.crossCurveMark;
        this._prepareSrcCrossData(crossCurveData, animatorLayerData.srcPlayData, crossCurveMark, false);
        this._prepareDestCrossData(crossCurveData, animatorLayerData.destPlayData, crossCurveMark, false);
      };
      _proto._prepareStandbyCrossFading = function _prepareStandbyCrossFading(animatorLayerData) {
        var crossCurveData = this._crossCurveDataCollection;
        var srcPlayData = animatorLayerData.srcPlayData, crossCurveMark = animatorLayerData.crossCurveMark;
        srcPlayData.state && this._prepareSrcCrossData(crossCurveData, srcPlayData, crossCurveMark, true);
        this._prepareDestCrossData(crossCurveData, animatorLayerData.destPlayData, crossCurveMark, true);
      };
      _proto._prepareFixedPoseCrossFading = function _prepareFixedPoseCrossFading(animatorLayerData) {
        var crossCurveData = this._crossCurveDataCollection;
        for (var i = crossCurveData.length - 1; i >= 0; i--) {
          var item = crossCurveData[i];
          item.curveOwner.saveFixedPoseValue();
          item.destCurveIndex = -1;
        }
        this._prepareDestCrossData(crossCurveData, animatorLayerData.destPlayData, animatorLayerData.crossCurveMark, true);
      };
      _proto._prepareSrcCrossData = function _prepareSrcCrossData(crossCurveData, srcPlayData, crossCurveMark, saveFixed) {
        var curveOwners = srcPlayData.stateData.curveOwners;
        for (var i = curveOwners.length - 1; i >= 0; i--) {
          var owner = curveOwners[i];
          owner.crossCurveMark = crossCurveMark;
          owner.crossCurveIndex = crossCurveData.length;
          saveFixed && owner.saveFixedPoseValue();
          this._addCrossCurveData(crossCurveData, owner, i, -1);
        }
      };
      _proto._prepareDestCrossData = function _prepareDestCrossData(crossCurveData, destPlayData, crossCurveMark, saveFixed) {
        var curveOwners = destPlayData.stateData.curveOwners;
        for (var i = curveOwners.length - 1; i >= 0; i--) {
          var owner = curveOwners[i];
          if (owner.crossCurveMark === crossCurveMark) {
            crossCurveData[owner.crossCurveIndex].destCurveIndex = i;
          } else {
            owner.saveDefaultValue();
            saveFixed && owner.saveFixedPoseValue();
            owner.crossCurveMark = crossCurveMark;
            owner.crossCurveIndex = crossCurveData.length;
            this._addCrossCurveData(crossCurveData, owner, -1, i);
          }
        }
      };
      _proto._evaluateCurve = function _evaluateCurve(property, curve, time, additive, tempValue) {
        var baseValue;
        if (additive) {
          baseValue = curve.keys[0].value;
        }
        switch (curve._valueType) {
          case exports3.InterpolableValueType.Float: {
            var value = curve.evaluate(time);
            if (additive) {
              return value - baseValue;
            }
            return value;
          }
          case exports3.InterpolableValueType.FloatArray: {
            var _value = tempValue.getFloatArray(curve._valueSize);
            curve._evaluate(time, _value);
            if (additive) {
              for (var i = 0, n = _value.length; i < n; i++) {
                _value[i] = _value[i] - baseValue[i];
              }
            }
            return _value;
          }
          case exports3.InterpolableValueType.Vector2: {
            var _value2 = tempValue.vector2;
            curve._evaluate(time, _value2);
            if (additive) {
              if (property === exports3.AnimationProperty.Scale) {
                miniprogram2.Vector2.divide(_value2, baseValue, _value2);
              } else {
                miniprogram2.Vector2.subtract(_value2, baseValue, _value2);
              }
            }
            return _value2;
          }
          case exports3.InterpolableValueType.Vector3: {
            var _value3 = tempValue.vector3;
            curve._evaluate(time, _value3);
            if (additive) {
              if (property === exports3.AnimationProperty.Scale) {
                miniprogram2.Vector3.divide(_value3, baseValue, _value3);
              } else {
                miniprogram2.Vector3.subtract(_value3, baseValue, _value3);
              }
            }
            return _value3;
          }
          case exports3.InterpolableValueType.Vector4: {
            var _value4 = tempValue.vector4;
            curve._evaluate(time, _value4);
            if (additive) {
              miniprogram2.Vector4.subtract(_value4, baseValue, _value4);
            }
            return _value4;
          }
          case exports3.InterpolableValueType.Quaternion: {
            var _value5 = tempValue.quaternion;
            curve._evaluate(time, _value5);
            if (additive) {
              var tempQuat = Animator2._tempQuat;
              miniprogram2.Quaternion.conjugate(baseValue, tempQuat);
              miniprogram2.Quaternion.multiply(tempQuat, _value5, _value5);
            }
            return _value5;
          }
        }
      };
      _proto._getAnimatorLayerData = function _getAnimatorLayerData(layerIndex) {
        var animatorLayerData = this._animatorLayersData[layerIndex];
        animatorLayerData || (this._animatorLayersData[layerIndex] = animatorLayerData = new AnimatorLayerData());
        return animatorLayerData;
      };
      _proto._updateLayer = function _updateLayer(layerIndex, firstLayer, deltaTime) {
        var _this$_animatorContro = this._animatorController.layers[layerIndex], blendingMode = _this$_animatorContro.blendingMode, weight = _this$_animatorContro.weight;
        var animLayerData = this._animatorLayersData[layerIndex];
        var srcPlayData = animLayerData.srcPlayData, destPlayData = animLayerData.destPlayData, crossFadeTransitionInfo = animLayerData.crossFadeTransition;
        var layerAdditive = blendingMode === exports3.AnimatorLayerBlendingMode.Additive;
        var layerWeight = firstLayer ? 1 : weight;
        animLayerData.layerState !== LayerState.FixedCrossFading && this._checkTransition(srcPlayData, crossFadeTransitionInfo, layerIndex);
        switch (animLayerData.layerState) {
          case LayerState.Playing:
            this._updatePlayingState(srcPlayData, animLayerData, layerIndex, layerWeight, deltaTime, layerAdditive);
            break;
          case LayerState.FixedCrossFading:
            this._updateCrossFadeFromPose(destPlayData, animLayerData, layerIndex, layerWeight, deltaTime, layerAdditive);
            break;
          case LayerState.CrossFading:
            this._updateCrossFade(srcPlayData, destPlayData, animLayerData, layerIndex, layerWeight, deltaTime, layerAdditive);
            break;
        }
      };
      _proto._updatePlayingState = function _updatePlayingState(playData, layerData, layerIndex, weight, delta, additive) {
        var _playData$stateData = playData.stateData, curveOwners = _playData$stateData.curveOwners, eventHandlers = _playData$stateData.eventHandlers;
        var state = playData.state, lastPlayState = playData.playState, lastClipTime = playData.clipTime;
        var curves = state.clip._curveBindings;
        playData.update(this.speed < 0);
        var clipTime = playData.clipTime, playState = playData.playState;
        eventHandlers.length && this._fireAnimationEvents(playData, eventHandlers, lastClipTime, clipTime);
        for (var i = curves.length - 1; i >= 0; i--) {
          var owner = curveOwners[i];
          var value = this._evaluateCurve(owner.property, curves[i].curve, clipTime, additive, this._baseTempValue);
          if (additive) {
            this._applyClipValueAdditive(owner, value, weight);
          } else {
            this._applyClipValue(owner, value, weight);
          }
        }
        playData.frameTime += state.speed * delta;
        if (playState === AnimatorStatePlayState.Finished) {
          layerData.layerState = LayerState.Standby;
        }
        if (lastPlayState === AnimatorStatePlayState.UnStarted) {
          this._callAnimatorScriptOnEnter(state, layerIndex);
        }
        if (playState === AnimatorStatePlayState.Finished) {
          this._callAnimatorScriptOnExit(state, layerIndex);
        } else {
          this._callAnimatorScriptOnUpdate(state, layerIndex);
        }
      };
      _proto._updateCrossFade = function _updateCrossFade(srcPlayData, destPlayData, layerData, layerIndex, weight, delta, additive) {
        var crossCurveDataCollection = this._crossCurveDataCollection;
        var srcCurves = srcPlayData.state.clip._curveBindings;
        var srcState = srcPlayData.state, srcStateData = srcPlayData.stateData, lastSrcPlayState = srcPlayData.playState;
        var srcEventHandler = srcStateData.eventHandlers;
        var destState = destPlayData.state, destStateData = destPlayData.stateData, lastDstPlayState = destPlayData.playState;
        var destEventHandler = destStateData.eventHandlers;
        var destCurves = destState.clip._curveBindings;
        var lastSrcClipTime = srcPlayData.clipTime;
        var lastDestClipTime = destPlayData.clipTime;
        var crossWeight = Math.abs(destPlayData.frameTime) / (destState._getDuration() * layerData.crossFadeTransition.duration);
        crossWeight >= 1 && (crossWeight = 1);
        srcPlayData.update(this.speed < 0);
        destPlayData.update(this.speed < 0);
        var srcPlayState = srcPlayData.playState;
        var destPlayState = destPlayData.playState;
        this._updateCrossFadeData(layerData, crossWeight, delta, false);
        var srcClipTime = srcPlayData.clipTime;
        var destClipTime = destPlayData.clipTime;
        srcEventHandler.length && this._fireAnimationEvents(srcPlayData, srcEventHandler, lastSrcClipTime, srcClipTime);
        destEventHandler.length && this._fireAnimationEvents(destPlayData, destEventHandler, lastDestClipTime, destClipTime);
        if (lastSrcPlayState === AnimatorStatePlayState.UnStarted) {
          this._callAnimatorScriptOnEnter(srcState, layerIndex);
        }
        if (crossWeight === 1 || srcPlayState === AnimatorStatePlayState.Finished) {
          this._callAnimatorScriptOnExit(srcState, layerIndex);
        } else {
          this._callAnimatorScriptOnUpdate(srcState, layerIndex);
        }
        if (lastDstPlayState === AnimatorStatePlayState.UnStarted) {
          this._callAnimatorScriptOnEnter(destState, layerIndex);
        }
        if (destPlayState === AnimatorStatePlayState.Finished) {
          this._callAnimatorScriptOnExit(destState, layerIndex);
        } else {
          this._callAnimatorScriptOnUpdate(destState, layerIndex);
        }
        for (var i = crossCurveDataCollection.length - 1; i >= 0; i--) {
          var _crossCurveDataCollec = crossCurveDataCollection[i], curveOwner = _crossCurveDataCollec.curveOwner, srcCurveIndex = _crossCurveDataCollec.srcCurveIndex, destCurveIndex = _crossCurveDataCollec.destCurveIndex;
          var property = curveOwner.property, defaultValue = curveOwner.defaultValue;
          var srcValue = srcCurveIndex >= 0 ? this._evaluateCurve(property, srcCurves[srcCurveIndex].curve, srcClipTime, additive, this._baseTempValue) : defaultValue;
          var destValue = destCurveIndex >= 0 ? this._evaluateCurve(property, destCurves[destCurveIndex].curve, destClipTime, additive, this._crossTempValue) : defaultValue;
          this._applyCrossClipValue(curveOwner, srcValue, destValue, crossWeight, weight, additive);
        }
      };
      _proto._updateCrossFadeFromPose = function _updateCrossFadeFromPose(destPlayData, layerData, layerIndex, weight, delta, additive) {
        var crossCurveDataCollection = this._crossCurveDataCollection;
        var state = destPlayData.state, stateData = destPlayData.stateData, lastPlayState = destPlayData.playState;
        var eventHandlers = stateData.eventHandlers;
        var curves = state.clip._curveBindings;
        var lastDestClipTime = destPlayData.clipTime;
        var crossWeight = Math.abs(destPlayData.frameTime) / (state._getDuration() * layerData.crossFadeTransition.duration);
        crossWeight >= 1 && (crossWeight = 1);
        destPlayData.update(this.speed < 0);
        var playState = destPlayData.playState;
        this._updateCrossFadeData(layerData, crossWeight, delta, true);
        var destClipTime = destPlayData.clipTime;
        eventHandlers.length && this._fireAnimationEvents(destPlayData, eventHandlers, lastDestClipTime, destClipTime);
        if (lastPlayState === AnimatorStatePlayState.UnStarted) {
          this._callAnimatorScriptOnEnter(state, layerIndex);
        }
        if (playState === AnimatorStatePlayState.Finished) {
          this._callAnimatorScriptOnExit(state, layerIndex);
        } else {
          this._callAnimatorScriptOnUpdate(state, layerIndex);
        }
        for (var i = crossCurveDataCollection.length - 1; i >= 0; i--) {
          var _crossCurveDataCollec2 = crossCurveDataCollection[i], curveOwner = _crossCurveDataCollec2.curveOwner, destCurveIndex = _crossCurveDataCollec2.destCurveIndex;
          var destValue = destCurveIndex >= 0 ? this._evaluateCurve(curveOwner.property, curves[destCurveIndex].curve, destClipTime, additive, this._crossTempValue) : curveOwner.defaultValue;
          this._applyCrossClipValue(curveOwner, curveOwner.fixedPoseValue, destValue, crossWeight, weight, additive);
        }
      };
      _proto._updateCrossFadeData = function _updateCrossFadeData(layerData, crossWeight, delta, fixed) {
        var destPlayData = layerData.destPlayData;
        destPlayData.frameTime += destPlayData.state.speed * delta;
        if (crossWeight === 1) {
          if (destPlayData.playState === AnimatorStatePlayState.Finished) {
            layerData.layerState = LayerState.Standby;
          } else {
            layerData.layerState = LayerState.Playing;
          }
          layerData.switchPlayData();
        } else {
          fixed || (layerData.srcPlayData.frameTime += layerData.srcPlayData.state.speed * delta);
        }
      };
      _proto._applyCrossClipValue = function _applyCrossClipValue(owner, srcValue, destValue, crossWeight, layerWeight, additive) {
        var value;
        if (owner.type === Transform) {
          switch (owner.property) {
            case exports3.AnimationProperty.Position:
              value = this._baseTempValue.vector3;
              miniprogram2.Vector3.lerp(srcValue, destValue, crossWeight, value);
              break;
            case exports3.AnimationProperty.Rotation:
              value = this._baseTempValue.quaternion;
              miniprogram2.Quaternion.slerp(srcValue, destValue, crossWeight, value);
              break;
            case exports3.AnimationProperty.Scale: {
              value = this._baseTempValue.vector3;
              miniprogram2.Vector3.lerp(srcValue, destValue, crossWeight, value);
              break;
            }
          }
        } else if (owner.type === SkinnedMeshRenderer) {
          switch (owner.property) {
            case exports3.AnimationProperty.BlendShapeWeights:
              value = this._baseTempValue.getFloatArray(srcValue.length);
              for (var i = 0, length2 = value.length; i < length2; ++i) {
                value[i] = srcValue[i] + (destValue[i] - srcValue[i]) * crossWeight;
              }
              break;
          }
        }
        if (additive) {
          this._applyClipValueAdditive(owner, value, layerWeight);
        } else {
          this._applyClipValue(owner, value, layerWeight);
        }
      };
      _proto._applyClipValue = function _applyClipValue(owner, value, weight) {
        if (owner.type === Transform) {
          var transform = owner.target.transform;
          switch (owner.property) {
            case exports3.AnimationProperty.Position:
              if (weight === 1) {
                transform.position = value;
              } else {
                var position = transform.position;
                miniprogram2.Vector3.lerp(position, value, weight, position);
              }
              break;
            case exports3.AnimationProperty.Rotation:
              if (weight === 1) {
                transform.rotationQuaternion = value;
              } else {
                var rotationQuaternion = transform.rotationQuaternion;
                miniprogram2.Quaternion.slerp(rotationQuaternion, value, weight, rotationQuaternion);
              }
              break;
            case exports3.AnimationProperty.Scale:
              if (weight === 1) {
                transform.scale = value;
              } else {
                var scale = transform.scale;
                miniprogram2.Vector3.lerp(scale, value, weight, scale);
              }
              break;
          }
        } else if (owner.type === SkinnedMeshRenderer) {
          switch (owner.property) {
            case exports3.AnimationProperty.BlendShapeWeights:
              if (weight === 1) {
                owner.component.blendShapeWeights = value;
              } else {
                var _ref = owner.component, blendShapeWeights = _ref.blendShapeWeights;
                for (var i = 0, length2 = blendShapeWeights.length; i < length2; ++i) {
                  blendShapeWeights[i] += (value[i] - blendShapeWeights[i]) * weight;
                }
              }
              break;
          }
        }
      };
      _proto._applyClipValueAdditive = function _applyClipValueAdditive(owner, additiveValue, weight) {
        if (owner.type === Transform) {
          var transform = owner.target.transform;
          switch (owner.property) {
            case exports3.AnimationProperty.Position:
              var position = transform.position;
              position.x += additiveValue.x * weight;
              position.y += additiveValue.y * weight;
              position.z += additiveValue.z * weight;
              transform.position = position;
              break;
            case exports3.AnimationProperty.Rotation:
              var rotationQuaternion = transform.rotationQuaternion;
              AnimatorUtils.quaternionWeight(additiveValue, weight, additiveValue);
              additiveValue.normalize();
              rotationQuaternion.multiply(additiveValue);
              transform.rotationQuaternion = rotationQuaternion;
              break;
            case exports3.AnimationProperty.Scale:
              var scale = transform.scale;
              AnimatorUtils.scaleWeight(scale, weight, scale);
              miniprogram2.Vector3.multiply(scale, additiveValue, scale);
              transform.scale = scale;
              break;
            case exports3.AnimationProperty.BlendShapeWeights:
              var _ref2 = owner.component, blendShapeWeights = _ref2.blendShapeWeights;
              for (var i = 0, length2 = blendShapeWeights.length; i < length2; ++i) {
                owner.component.blendShapeWeights[i] += additiveValue[i] * weight;
              }
              break;
          }
        }
      };
      _proto._revertDefaultValue = function _revertDefaultValue(state, stateData) {
        var clip = state.clip;
        if (clip) {
          var curves = clip._curveBindings;
          var curveOwners = stateData.curveOwners;
          for (var i = curves.length - 1; i >= 0; i--) {
            var owner = curveOwners[i];
            var transform = owner.target.transform;
            if (!owner._hasSavedDefaultValue)
              continue;
            switch (owner.property) {
              case exports3.AnimationProperty.Position:
                transform.position = owner.defaultValue;
                break;
              case exports3.AnimationProperty.Rotation:
                transform.rotationQuaternion = owner.defaultValue;
                break;
              case exports3.AnimationProperty.Scale:
                transform.scale = owner.defaultValue;
                break;
              case exports3.AnimationProperty.BlendShapeWeights:
                var _ref3 = owner.component, blendShapeWeights = _ref3.blendShapeWeights;
                for (var j = 0, length2 = blendShapeWeights.length; j < length2; ++j) {
                  owner.component.blendShapeWeights[j] = owner.defaultValue[j];
                }
                break;
            }
          }
        }
      };
      _proto._checkTransition = function _checkTransition(stateData, crossFadeTransition, layerIndex) {
        var state = stateData.state, clipTime = stateData.clipTime;
        var duration = state._getDuration();
        var transitions = state.transitions;
        for (var i = 0, n = transitions.length; i < n; ++i) {
          var transition = transitions[i];
          if (duration * transition.exitTime <= clipTime) {
            crossFadeTransition !== transition && this._crossFadeByTransition(transition, layerIndex);
          }
        }
      };
      _proto._crossFadeByTransition = function _crossFadeByTransition(transition, layerIndex) {
        var name = transition.destinationState.name;
        var animatorStateInfo = this._getAnimatorStateInfo(name, layerIndex, Animator2._animatorInfo);
        var crossState = animatorStateInfo.state;
        if (!crossState) {
          return;
        }
        if (!crossState.clip) {
          console.warn("The state named " + name + " has no AnimationClip data.");
          return;
        }
        var animatorLayerData = this._getAnimatorLayerData(animatorStateInfo.layerIndex);
        var layerState = animatorLayerData.layerState;
        var destPlayData = animatorLayerData.destPlayData;
        var animatorStateData = this._getAnimatorStateData(name, crossState, animatorLayerData);
        var duration = crossState._getDuration();
        var offset = duration * transition.offset;
        destPlayData.reset(crossState, animatorStateData, offset);
        switch (layerState) {
          case LayerState.Standby:
            animatorLayerData.layerState = LayerState.FixedCrossFading;
            this._clearCrossData(animatorLayerData);
            this._prepareStandbyCrossFading(animatorLayerData);
            break;
          case LayerState.Playing:
            animatorLayerData.layerState = LayerState.CrossFading;
            this._clearCrossData(animatorLayerData);
            this._prepareCrossFading(animatorLayerData);
            break;
          case LayerState.CrossFading:
            animatorLayerData.layerState = LayerState.FixedCrossFading;
            this._prepareFixedPoseCrossFading(animatorLayerData);
            break;
          case LayerState.FixedCrossFading:
            this._prepareFixedPoseCrossFading(animatorLayerData);
            break;
        }
        animatorLayerData.crossFadeTransition = transition;
      };
      _proto._fireAnimationEvents = function _fireAnimationEvents(playState, eventHandlers, lastClipTime, clipTime) {
        var state = playState.state;
        var clipDuration = state.clip.length;
        if (this.speed >= 0) {
          if (clipTime < lastClipTime) {
            this._fireSubAnimationEvents(playState, eventHandlers, lastClipTime, state.clipEndTime * clipDuration);
            playState.currentEventIndex = 0;
            this._fireSubAnimationEvents(playState, eventHandlers, state.clipStartTime * clipDuration, clipTime);
          } else {
            this._fireSubAnimationEvents(playState, eventHandlers, lastClipTime, clipTime);
          }
        } else {
          if (clipTime > lastClipTime) {
            this._fireBackwardSubAnimationEvents(playState, eventHandlers, lastClipTime, state.clipStartTime * clipDuration);
            playState.currentEventIndex = eventHandlers.length - 1;
            this._fireBackwardSubAnimationEvents(playState, eventHandlers, state.clipEndTime * clipDuration, clipTime);
          } else {
            this._fireBackwardSubAnimationEvents(playState, eventHandlers, lastClipTime, clipTime);
          }
        }
      };
      _proto._fireSubAnimationEvents = function _fireSubAnimationEvents(playState, eventHandlers, lastClipTime, curClipTime) {
        var eventIndex = playState.currentEventIndex;
        for (var n = eventHandlers.length; eventIndex < n; eventIndex++) {
          var eventHandler = eventHandlers[eventIndex];
          var _eventHandler$event = eventHandler.event, time = _eventHandler$event.time, parameter = _eventHandler$event.parameter;
          if (time > curClipTime) {
            break;
          }
          var _eventHandler = eventHandler, handlers = _eventHandler.handlers;
          if (time >= lastClipTime) {
            for (var j = handlers.length - 1; j >= 0; j--) {
              handlers[j](parameter);
            }
            playState.currentEventIndex = Math.min(eventIndex + 1, n - 1);
          }
        }
      };
      _proto._fireBackwardSubAnimationEvents = function _fireBackwardSubAnimationEvents(playState, eventHandlers, lastClipTime, curClipTime) {
        var eventIndex = playState.currentEventIndex;
        for (; eventIndex >= 0; eventIndex--) {
          var eventHandler = eventHandlers[eventIndex];
          var _eventHandler$event2 = eventHandler.event, time = _eventHandler$event2.time, parameter = _eventHandler$event2.parameter;
          if (time < curClipTime) {
            break;
          }
          var _eventHandler2 = eventHandler, handlers = _eventHandler2.handlers;
          if (time <= lastClipTime) {
            for (var j = handlers.length - 1; j >= 0; j--) {
              handlers[j](parameter);
            }
            playState.currentEventIndex = Math.max(eventIndex - 1, 0);
          }
        }
      };
      _proto._callAnimatorScriptOnEnter = function _callAnimatorScriptOnEnter(state, layerIndex) {
        var scripts = state._onStateEnterScripts;
        for (var i = 0, n = scripts.length; i < n; i++) {
          scripts[i].onStateEnter(this, state, layerIndex);
        }
      };
      _proto._callAnimatorScriptOnUpdate = function _callAnimatorScriptOnUpdate(state, layerIndex) {
        var scripts = state._onStateUpdateScripts;
        for (var i = 0, n = scripts.length; i < n; i++) {
          scripts[i].onStateUpdate(this, state, layerIndex);
        }
      };
      _proto._callAnimatorScriptOnExit = function _callAnimatorScriptOnExit(state, layerIndex) {
        var scripts = state._onStateExitScripts;
        for (var i = 0, n = scripts.length; i < n; i++) {
          scripts[i].onStateExit(this, state, layerIndex);
        }
      };
      _proto._clearPlayData = function _clearPlayData() {
        this._animatorLayersData.length = 0;
        this._crossCurveDataCollection.length = 0;
        this._animationCurveOwners.length = 0;
        this._animationEventHandlerPool.resetPool();
        if (this._controllerUpdateFlag) {
          this._controllerUpdateFlag.flag = false;
        }
      };
      _createClass2(Animator2, [{
        key: "speed",
        get: function get() {
          return this._speed;
        },
        set: function set(value) {
          this._speed = value;
        }
      }, {
        key: "animatorController",
        get: function get() {
          return this._animatorController;
        },
        set: function set(animatorController) {
          if (animatorController !== this._animatorController) {
            this._controllerUpdateFlag && this._controllerUpdateFlag.destroy();
            this._controllerUpdateFlag = animatorController && animatorController._registerChangeFlag();
            this._animatorController = animatorController;
          }
        }
      }]);
      return Animator2;
    }(Component), _class22._tempQuat = new miniprogram2.Quaternion(), _class22._animatorInfo = new AnimatorStateInfo(), _class22), _descriptor = _applyDecoratedDescriptor(_class4.prototype, "_speed", [assignmentClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class4.prototype, "_controllerUpdateFlag", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor3 = _applyDecoratedDescriptor(_class4.prototype, "_animatorLayersData", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return [];
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class4.prototype, "_crossCurveDataCollection", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return [];
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class4.prototype, "_animationCurveOwners", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return [];
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class4.prototype, "_crossCurveDataPool", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new ClassPool(CrossCurveData);
      }
    }), _descriptor7 = _applyDecoratedDescriptor(_class4.prototype, "_animationEventHandlerPool", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new ClassPool(AnimationEventHandler);
      }
    }), _descriptor8 = _applyDecoratedDescriptor(_class4.prototype, "_baseTempValue", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new AnimatorTempValue();
      }
    }), _descriptor9 = _applyDecoratedDescriptor(_class4.prototype, "_crossTempValue", [ignoreClone], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new AnimatorTempValue();
      }
    }), _class4);
    var AnimatorController = /* @__PURE__ */ function() {
      function AnimatorController2() {
        this._updateFlagManager = new UpdateFlagManager();
        this._layers = [];
        this._layersMap = {};
      }
      var _proto = AnimatorController2.prototype;
      _proto.findLayerByName = function findLayerByName(name) {
        return this._layersMap[name];
      };
      _proto.addLayer = function addLayer(layer) {
        this._layers.push(layer);
        this._layersMap[layer.name] = layer;
        this._distributeUpdateFlag();
      };
      _proto.removeLayer = function removeLayer(layerIndex) {
        var theLayer = this.layers[layerIndex];
        this._layers.splice(layerIndex, 1);
        delete this._layersMap[theLayer.name];
        this._distributeUpdateFlag();
      };
      _proto.clearLayers = function clearLayers() {
        this._layers.length = 0;
        for (var name in this._layersMap) {
          delete this._layersMap[name];
        }
        this._distributeUpdateFlag();
      };
      _proto._registerChangeFlag = function _registerChangeFlag() {
        return this._updateFlagManager.createFlag(BoolUpdateFlag);
      };
      _proto._distributeUpdateFlag = function _distributeUpdateFlag() {
        this._updateFlagManager.dispatch();
      };
      _createClass2(AnimatorController2, [{
        key: "layers",
        get: function get() {
          return this._layers;
        }
      }]);
      return AnimatorController2;
    }();
    var AnimatorControllerLayer = function AnimatorControllerLayer2(name) {
      this.name = name;
      this.weight = 1;
      this.blendingMode = exports3.AnimatorLayerBlendingMode.Override;
      this.stateMachine = void 0;
    };
    var StateMachineScript = /* @__PURE__ */ function() {
      function StateMachineScript2() {
        this._destroyed = false;
        this._state = void 0;
      }
      var _proto = StateMachineScript2.prototype;
      _proto.onStateEnter = function onStateEnter(animator, animatorState, layerIndex) {
      };
      _proto.onStateUpdate = function onStateUpdate(animator, animatorState, layerIndex) {
      };
      _proto.onStateExit = function onStateExit(animator, animatorState, layerIndex) {
      };
      _proto.destroy = function destroy() {
        if (this._destroyed) {
          return;
        }
        this._state._removeStateMachineScript(this);
        this._destroyed = true;
      };
      return StateMachineScript2;
    }();
    var AnimatorState = /* @__PURE__ */ function() {
      function AnimatorState2(name) {
        this.name = name;
        this.speed = 1;
        this.wrapMode = exports3.WrapMode.Loop;
        this._onStateEnterScripts = [];
        this._onStateUpdateScripts = [];
        this._onStateExitScripts = [];
        this._clipStartTime = 0;
        this._clipEndTime = 1;
        this._clip = void 0;
        this._transitions = [];
      }
      var _proto = AnimatorState2.prototype;
      _proto.addTransition = function addTransition(transition) {
        this._transitions.push(transition);
      };
      _proto.removeTransition = function removeTransition(transition) {
        var index = this._transitions.indexOf(transition);
        index !== -1 && this._transitions.splice(index, 1);
      };
      _proto.addStateMachineScript = function addStateMachineScript(scriptType) {
        var script = new scriptType();
        script._state = this;
        var prototype = StateMachineScript.prototype;
        if (script.onStateEnter !== prototype.onStateEnter) {
          this._onStateEnterScripts.push(script);
        }
        if (script.onStateUpdate !== prototype.onStateUpdate) {
          this._onStateUpdateScripts.push(script);
        }
        if (script.onStateExit !== prototype.onStateExit) {
          this._onStateExitScripts.push(script);
        }
        return script;
      };
      _proto.clearTransitions = function clearTransitions() {
        this._transitions.length = 0;
      };
      _proto._getDuration = function _getDuration() {
        if (this.clip) {
          return (this._clipEndTime - this._clipStartTime) * this.clip.length;
        }
        return null;
      };
      _proto._removeStateMachineScript = function _removeStateMachineScript(script) {
        var prototype = StateMachineScript.prototype;
        if (script.onStateEnter !== prototype.onStateEnter) {
          var index = this._onStateEnterScripts.indexOf(script);
          index !== -1 && this._onStateEnterScripts.splice(index, 1);
        }
        if (script.onStateUpdate !== prototype.onStateUpdate) {
          var _index = this._onStateUpdateScripts.indexOf(script);
          _index !== -1 && this._onStateUpdateScripts.splice(_index, 1);
        }
        if (script.onStateExit !== prototype.onStateExit) {
          var _index2 = this._onStateExitScripts.indexOf(script);
          _index2 !== -1 && this._onStateExitScripts.splice(_index2, 1);
        }
      };
      _createClass2(AnimatorState2, [{
        key: "transitions",
        get: function get() {
          return this._transitions;
        }
      }, {
        key: "clip",
        get: function get() {
          return this._clip;
        },
        set: function set(clip) {
          this._clip = clip;
          this._clipEndTime = Math.min(this._clipEndTime, 1);
        }
      }, {
        key: "clipStartTime",
        get: function get() {
          return this._clipStartTime;
        },
        set: function set(time) {
          this._clipStartTime = Math.max(time, 0);
        }
      }, {
        key: "clipEndTime",
        get: function get() {
          return this._clipEndTime;
        },
        set: function set(time) {
          this._clipEndTime = Math.min(time, 1);
        }
      }]);
      return AnimatorState2;
    }();
    var AnimatorStateMachine = /* @__PURE__ */ function() {
      function AnimatorStateMachine2() {
        this.states = [];
        this._statesMap = {};
      }
      var _proto = AnimatorStateMachine2.prototype;
      _proto.addState = function addState(name) {
        var state = this.findStateByName(name);
        if (!state) {
          state = new AnimatorState(name);
          this.states.push(state);
          this._statesMap[name] = state;
        } else {
          console.warn("The state named " + name + " has existed.");
        }
        return state;
      };
      _proto.removeState = function removeState(state) {
        var name = state.name;
        var index = this.states.indexOf(state);
        if (index > -1) {
          this.states.splice(index, 1);
        }
        delete this._statesMap[name];
      };
      _proto.findStateByName = function findStateByName(name) {
        return this._statesMap[name];
      };
      _proto.makeUniqueStateName = function makeUniqueStateName(name) {
        var _statesMap = this._statesMap;
        var originName = name;
        var index = 0;
        while (_statesMap[name]) {
          name = originName + " " + index;
          index++;
        }
        return name;
      };
      return AnimatorStateMachine2;
    }();
    exports3.InterpolationType = void 0;
    (function(InterpolationType) {
      InterpolationType[InterpolationType["Linear"] = 0] = "Linear";
      InterpolationType[InterpolationType["CubicSpine"] = 1] = "CubicSpine";
      InterpolationType[InterpolationType["Step"] = 2] = "Step";
      InterpolationType[InterpolationType["Hermite"] = 3] = "Hermite";
    })(exports3.InterpolationType || (exports3.InterpolationType = {}));
    var AnimationCurve = /* @__PURE__ */ function() {
      function AnimationCurve2() {
        this.keys = [];
        this.interpolation = void 0;
        this._valueSize = void 0;
        this._valueType = void 0;
        this._tempValue = void 0;
        this._length = 0;
        this._currentIndex = 0;
      }
      var _proto = AnimationCurve2.prototype;
      _proto.addKey = function addKey(key) {
        var time = key.time;
        this.keys.push(key);
        if (time > this._length) {
          this._length = time;
        }
        if (!this._valueSize) {
          if (typeof key.value == "number") {
            this._valueSize = 1;
            this._valueType = exports3.InterpolableValueType.Float;
            this._tempValue = 0;
          }
          if (key.value instanceof miniprogram2.Vector2) {
            this._valueSize = 2;
            this._valueType = exports3.InterpolableValueType.Vector2;
            this._tempValue = new miniprogram2.Vector2();
          }
          if (key.value instanceof miniprogram2.Vector3) {
            this._valueSize = 3;
            this._valueType = exports3.InterpolableValueType.Vector3;
            this._tempValue = new miniprogram2.Vector3();
          }
          if (key.value instanceof miniprogram2.Vector4) {
            this._valueSize = 4;
            this._valueType = exports3.InterpolableValueType.Vector4;
            this._tempValue = new miniprogram2.Vector4();
          }
          if (key.value instanceof miniprogram2.Quaternion) {
            this._valueSize = 4;
            this._valueType = exports3.InterpolableValueType.Quaternion;
            this._tempValue = new miniprogram2.Quaternion();
          }
          if (key.value instanceof Float32Array) {
            var size = key.value.length;
            this._valueSize = size;
            this._valueType = exports3.InterpolableValueType.FloatArray;
            this._tempValue = new Float32Array(size);
          }
        }
        this.keys.sort(function(a, b) {
          return a.time - b.time;
        });
      };
      _proto.evaluate = function evaluate(time) {
        return this._evaluate(time, this._tempValue);
      };
      _proto.moveKey = function moveKey(index, key) {
        this.keys[index] = key;
      };
      _proto.removeKey = function removeKey(index) {
        this.keys.splice(index, 1);
        var keys = this.keys;
        var count = this.keys.length;
        var newLength = 0;
        for (var i = count - 1; i >= 0; i--) {
          if (keys[i].time > length) {
            newLength = keys[i].time;
          }
        }
        this._length = newLength;
      };
      _proto._evaluate = function _evaluate(time, out) {
        var keys = this.keys, interpolation = this.interpolation;
        this._valueType;
        var length2 = this.keys.length;
        var curIndex = this._currentIndex;
        if (curIndex !== -1 && time < keys[curIndex].time) {
          curIndex = -1;
        }
        var nextIndex = curIndex + 1;
        while (nextIndex < length2) {
          if (time < keys[nextIndex].time) {
            break;
          }
          curIndex++;
          nextIndex++;
        }
        this._currentIndex = curIndex;
        var value;
        if (curIndex === -1) {
          value = this._evaluateStep(0, out);
        } else if (nextIndex === length2) {
          value = this._evaluateStep(curIndex, out);
        } else {
          var curFrameTime = keys[curIndex].time;
          var duration = keys[nextIndex].time - curFrameTime;
          var t = (time - curFrameTime) / duration;
          var dur = duration;
          switch (interpolation) {
            case exports3.InterpolationType.Linear:
              value = this._evaluateLinear(curIndex, nextIndex, t, out);
              break;
            case exports3.InterpolationType.Step:
              value = this._evaluateStep(curIndex, out);
              break;
            case exports3.InterpolationType.CubicSpine:
            case exports3.InterpolationType.Hermite:
              value = this._evaluateHermite(curIndex, nextIndex, t, dur, out);
          }
        }
        return value;
      };
      _proto._evaluateLinear = function _evaluateLinear(frameIndex, nextFrameIndex, t, out) {
        var _valueType = this._valueType, keys = this.keys;
        switch (_valueType) {
          case exports3.InterpolableValueType.Float:
            return keys[frameIndex].value * (1 - t) + keys[nextFrameIndex].value * t;
          case exports3.InterpolableValueType.FloatArray:
            var value = keys[frameIndex].value;
            var nextValue = keys[nextFrameIndex].value;
            for (var i = 0, n = value.length; i < n; i++) {
              out[i] = value[i] * (1 - t) + nextValue[i] * t;
            }
            return out;
          case exports3.InterpolableValueType.Vector2:
            miniprogram2.Vector2.lerp(keys[frameIndex].value, keys[nextFrameIndex].value, t, out);
            return out;
          case exports3.InterpolableValueType.Vector3:
            miniprogram2.Vector3.lerp(keys[frameIndex].value, keys[nextFrameIndex].value, t, out);
            return out;
          case exports3.InterpolableValueType.Vector4:
            miniprogram2.Vector4.lerp(keys[frameIndex].value, keys[nextFrameIndex].value, t, out);
            return out;
          case exports3.InterpolableValueType.Quaternion:
            miniprogram2.Quaternion.slerp(keys[frameIndex].value, keys[nextFrameIndex].value, t, out);
            return out;
        }
      };
      _proto._evaluateStep = function _evaluateStep(frameIndex, out) {
        var _valueType = this._valueType, keys = this.keys;
        switch (_valueType) {
          case exports3.InterpolableValueType.Float:
            return keys[frameIndex].value;
          case exports3.InterpolableValueType.FloatArray:
            var value = keys[frameIndex].value;
            for (var i = 0, n = value.length; i < n; i++) {
              out[i] = value[i];
            }
            return out;
          case exports3.InterpolableValueType.Vector2:
          case exports3.InterpolableValueType.Vector3:
          case exports3.InterpolableValueType.Vector4:
          case exports3.InterpolableValueType.Quaternion:
            out.copyFrom(keys[frameIndex].value);
            return out;
        }
      };
      _proto._evaluateHermite = function _evaluateHermite(frameIndex, nextFrameIndex, t, dur, out) {
        var _valueSize = this._valueSize, keys = this.keys;
        var curKey = keys[frameIndex];
        var nextKey = keys[nextFrameIndex];
        switch (_valueSize) {
          case 1: {
            var t0 = curKey.outTangent, t1 = nextKey.inTangent, p0 = curKey.value, p1 = nextKey.value;
            if (Number.isFinite(t0) && Number.isFinite(t1)) {
              var t2 = t * t;
              var t3 = t2 * t;
              var a = 2 * t3 - 3 * t2 + 1;
              var b = t3 - 2 * t2 + t;
              var c = t3 - t2;
              var d = -2 * t3 + 3 * t2;
              return a * p0 + b * t0 * dur + c * t1 * dur + d * p1;
            } else {
              return curKey.value;
            }
          }
          case 2: {
            var _p = curKey.value;
            var tan0 = curKey.outTangent;
            var _p2 = nextKey.value;
            var tan1 = nextKey.inTangent;
            var _t = t * t;
            var _t2 = _t * t;
            var _a = 2 * _t2 - 3 * _t + 1;
            var _b = _t2 - 2 * _t + t;
            var _c = _t2 - _t;
            var _d = -2 * _t2 + 3 * _t;
            var _t3 = tan0.x, _t4 = tan1.x;
            if (Number.isFinite(_t3) && Number.isFinite(_t4)) {
              out.x = _a * _p.x + _b * _t3 * dur + _c * _t4 * dur + _d * _p2.x;
            } else {
              out.x = _p.x;
            }
            _t3 = tan0.y, _t4 = tan1.y;
            if (Number.isFinite(_t3) && Number.isFinite(_t4))
              out.y = _a * _p.y + _b * _t3 * dur + _c * _t4 * dur + _d * _p2.y;
            else {
              out.y = _p.y;
            }
            return out;
          }
          case 3: {
            var _p3 = curKey.value;
            var _tan = curKey.outTangent;
            var _p4 = nextKey.value;
            var _tan2 = nextKey.inTangent;
            var _t5 = t * t;
            var _t6 = _t5 * t;
            var _a2 = 2 * _t6 - 3 * _t5 + 1;
            var _b2 = _t6 - 2 * _t5 + t;
            var _c2 = _t6 - _t5;
            var _d2 = -2 * _t6 + 3 * _t5;
            var _t7 = _tan.x, _t8 = _tan2.x;
            if (Number.isFinite(_t7) && Number.isFinite(_t8)) {
              out.x = _a2 * _p3.x + _b2 * _t7 * dur + _c2 * _t8 * dur + _d2 * _p4.x;
            } else {
              out.x = _p3.x;
            }
            _t7 = _tan.y, _t8 = _tan2.y;
            if (Number.isFinite(_t7) && Number.isFinite(_t8)) {
              out.y = _a2 * _p3.y + _b2 * _t7 * dur + _c2 * _t8 * dur + _d2 * _p4.y;
            } else {
              out.y = _p3.y;
            }
            _t7 = _tan.z, _t8 = _tan2.z;
            if (Number.isFinite(_t7) && Number.isFinite(_t8)) {
              out.z = _a2 * _p3.z + _b2 * _t7 * dur + _c2 * _t8 * dur + _d2 * _p4.z;
            } else {
              out.z = _p3.z;
            }
            return out;
          }
          case 4: {
            var _p5 = curKey.value;
            var _tan3 = curKey.outTangent;
            var _p6 = nextKey.value;
            var _tan4 = nextKey.inTangent;
            var _t9 = t * t;
            var _t10 = _t9 * t;
            var _a3 = 2 * _t10 - 3 * _t9 + 1;
            var _b3 = _t10 - 2 * _t9 + t;
            var _c3 = _t10 - _t9;
            var _d3 = -2 * _t10 + 3 * _t9;
            var _t11 = _tan3.x, _t12 = _tan4.x;
            if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
              out.x = _a3 * _p5.x + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.x;
            } else {
              out.x = _p5.x;
            }
            _t11 = _tan3.y, _t12 = _tan4.y;
            if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
              out.y = _a3 * _p5.y + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.y;
            } else {
              out.y = _p5.y;
            }
            _t11 = _tan3.z, _t12 = _tan4.z;
            if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
              out.z = _a3 * _p5.z + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.z;
            } else {
              out.z = _p5.z;
            }
            _t11 = _tan3.w, _t12 = _tan4.w;
            if (Number.isFinite(_t11) && Number.isFinite(_t12)) {
              out.w = _a3 * _p5.w + _b3 * _t11 * dur + _c3 * _t12 * dur + _d3 * _p6.w;
            } else {
              out.w = _p5.w;
            }
            return out;
          }
        }
      };
      _createClass2(AnimationCurve2, [{
        key: "length",
        get: function get() {
          return this._length;
        }
      }]);
      return AnimationCurve2;
    }();
    var Keyframe = function Keyframe2() {
      this.time = void 0;
      this.value = void 0;
    };
    var InterpolableKeyframe = /* @__PURE__ */ function(_Keyframe) {
      _inheritsLoose2(InterpolableKeyframe2, _Keyframe);
      function InterpolableKeyframe2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _Keyframe.call.apply(_Keyframe, [this].concat(args)) || this;
        _this.inTangent = void 0;
        _this.outTangent = void 0;
        return _this;
      }
      return InterpolableKeyframe2;
    }(Keyframe);
    exports3.AnimatorConditionMode = void 0;
    (function(AnimatorConditionMode) {
      AnimatorConditionMode[AnimatorConditionMode["If"] = 0] = "If";
      AnimatorConditionMode[AnimatorConditionMode["IfNot"] = 1] = "IfNot";
      AnimatorConditionMode[AnimatorConditionMode["Greater"] = 2] = "Greater";
      AnimatorConditionMode[AnimatorConditionMode["Less"] = 3] = "Less";
      AnimatorConditionMode[AnimatorConditionMode["Equals"] = 4] = "Equals";
      AnimatorConditionMode[AnimatorConditionMode["NotEquals"] = 5] = "NotEquals";
    })(exports3.AnimatorConditionMode || (exports3.AnimatorConditionMode = {}));
    var SkyBoxMaterial = /* @__PURE__ */ function(_Material) {
      _inheritsLoose2(SkyBoxMaterial2, _Material);
      function SkyBoxMaterial2(engine) {
        var _this;
        _this = _Material.call(this, engine, Shader.find("skybox")) || this;
        _this._decodeParam = new miniprogram2.Vector4(0, 5, 0, 0);
        _this.renderState.rasterState.cullMode = exports3.CullMode.Off;
        _this.renderState.depthState.compareFunction = exports3.CompareFunction.LessEqual;
        _this.shaderData.setVector4("u_cubeDecodeParam", _this._decodeParam);
        return _this;
      }
      _createClass2(SkyBoxMaterial2, [{
        key: "textureDecodeRGBM",
        get: function get() {
          return Boolean(this._decodeParam.x);
        },
        set: function set(value) {
          this._decodeParam.x = Number(value);
        }
      }, {
        key: "RGBMDecodeFactor",
        get: function get() {
          return this._decodeParam.y;
        },
        set: function set(value) {
          this._decodeParam.y = value;
        }
      }, {
        key: "textureCubeMap",
        get: function get() {
          return this.shaderData.getTexture("u_cube");
        },
        set: function set(v) {
          this.shaderData.setTexture("u_cube", v);
        }
      }]);
      return SkyBoxMaterial2;
    }(Material);
    var DirtyFlagType;
    (function(DirtyFlagType2) {
      DirtyFlagType2[DirtyFlagType2["Position"] = 1] = "Position";
      DirtyFlagType2[DirtyFlagType2["Velocity"] = 2] = "Velocity";
      DirtyFlagType2[DirtyFlagType2["Acceleration"] = 4] = "Acceleration";
      DirtyFlagType2[DirtyFlagType2["Color"] = 8] = "Color";
      DirtyFlagType2[DirtyFlagType2["Alpha"] = 16] = "Alpha";
      DirtyFlagType2[DirtyFlagType2["Size"] = 32] = "Size";
      DirtyFlagType2[DirtyFlagType2["StartAngle"] = 64] = "StartAngle";
      DirtyFlagType2[DirtyFlagType2["StartTime"] = 128] = "StartTime";
      DirtyFlagType2[DirtyFlagType2["LifeTime"] = 256] = "LifeTime";
      DirtyFlagType2[DirtyFlagType2["RotateVelocity"] = 512] = "RotateVelocity";
      DirtyFlagType2[DirtyFlagType2["Scale"] = 1024] = "Scale";
      DirtyFlagType2[DirtyFlagType2["Everything"] = 4294967295] = "Everything";
    })(DirtyFlagType || (DirtyFlagType = {}));
    exports3.ParticleRendererBlendMode = void 0;
    (function(ParticleRendererBlendMode) {
      ParticleRendererBlendMode[ParticleRendererBlendMode["Transparent"] = 0] = "Transparent";
      ParticleRendererBlendMode[ParticleRendererBlendMode["Additive"] = 1] = "Additive";
    })(exports3.ParticleRendererBlendMode || (exports3.ParticleRendererBlendMode = {}));
    var ParticleRenderer = /* @__PURE__ */ function(_MeshRenderer) {
      _inheritsLoose2(ParticleRenderer2, _MeshRenderer);
      ParticleRenderer2._getRandom = function _getRandom() {
        return Math.random() - 0.5;
      };
      function ParticleRenderer2(props) {
        var _this;
        _this = _MeshRenderer.call(this, props) || this;
        _this._vertexStride = void 0;
        _this._vertices = void 0;
        _this._vertexBuffer = void 0;
        _this._maxCount = 1e3;
        _this._position = new miniprogram2.Vector3();
        _this._positionRandomness = new miniprogram2.Vector3();
        _this._positionArray = void 0;
        _this._velocity = new miniprogram2.Vector3();
        _this._velocityRandomness = new miniprogram2.Vector3();
        _this._acceleration = new miniprogram2.Vector3();
        _this._accelerationRandomness = new miniprogram2.Vector3();
        _this._color = new miniprogram2.Color(1, 1, 1, 1);
        _this._colorRandomness = 0;
        _this._size = 1;
        _this._sizeRandomness = 0;
        _this._alpha = 1;
        _this._alphaRandomness = 0;
        _this._startAngle = 0;
        _this._startAngleRandomness = 0;
        _this._rotateVelocity = 0;
        _this._rotateVelocityRandomness = 0;
        _this._lifetime = 5;
        _this._startTimeRandomness = 0;
        _this._scale = 1;
        _this._isOnce = false;
        _this._onceTime = 0;
        _this._time = 0;
        _this._isInit = false;
        _this._isStart = false;
        _this._updateDirtyFlag = DirtyFlagType.Everything;
        _this._isRotateToVelocity = false;
        _this._isUseOriginColor = false;
        _this._isScaleByLifetime = false;
        _this._is2d = true;
        _this._isFadeIn = false;
        _this._isFadeOut = false;
        _this._playOnEnable = true;
        _this._blendMode = exports3.ParticleRendererBlendMode.Transparent;
        _this.spriteSheet = void 0;
        _this.setMaterial(_this._createMaterial());
        return _this;
      }
      var _proto = ParticleRenderer2.prototype;
      _proto.update = function update(deltaTime) {
        if (!this._isInit || !this._isStart) {
          return;
        }
        if (this._isOnce && this._time > this._onceTime) {
          return this.stop();
        }
        if (this._updateDirtyFlag) {
          this._updateBuffer();
          this._updateDirtyFlag = 0;
        }
        this._time += deltaTime / 1e3;
        this.shaderData.setFloat("u_time", this._time);
      };
      _proto._onEnable = function _onEnable() {
        _MeshRenderer.prototype._onEnable.call(this);
        if (this._playOnEnable) {
          this.start();
        }
      };
      _proto.start = function start2() {
        this._isStart = true;
        this._time = 0;
      };
      _proto.stop = function stop() {
        this._isStart = false;
      };
      _proto._createMaterial = function _createMaterial() {
        var material = new Material(this.engine, Shader.find("particle-shader"));
        var renderState = material.renderState;
        var target = renderState.blendState.targetBlendState;
        target.enabled = true;
        target.sourceColorBlendFactor = exports3.BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = exports3.BlendFactor.OneMinusSourceAlpha;
        target.sourceAlphaBlendFactor = exports3.BlendFactor.One;
        target.destinationAlphaBlendFactor = exports3.BlendFactor.OneMinusSourceAlpha;
        renderState.depthState.writeEnabled = false;
        material.renderQueueType = exports3.RenderQueueType.Transparent;
        this.isUseOriginColor = true;
        this.is2d = true;
        this.isFadeOut = true;
        return material;
      };
      _proto._createMesh = function _createMesh() {
        var mesh = new BufferMesh(this._entity.engine, "particleMesh");
        var vertexStride = 96;
        var vertexCount = this._maxCount * 4;
        var vertexFloatCount = vertexCount * vertexStride;
        var vertices = new Float32Array(vertexFloatCount);
        var indices = null;
        var useUint32 = false;
        if (vertexCount > ParticleRenderer2._uint16VertexLimit) {
          if (this.engine._hardwareRenderer.canIUse(exports3.GLCapabilityType.elementIndexUint)) {
            useUint32 = true;
            indices = new Uint32Array(6 * this._maxCount);
          } else {
            throw Error("The vertex count is over limit.");
          }
        } else {
          indices = new Uint16Array(6 * this._maxCount);
        }
        for (var i = 0, idx = 0; i < this._maxCount; ++i) {
          var startIndex = i * 4;
          indices[idx++] = startIndex;
          indices[idx++] = startIndex + 1;
          indices[idx++] = startIndex + 2;
          indices[idx++] = startIndex;
          indices[idx++] = startIndex + 2;
          indices[idx++] = startIndex + 3;
        }
        var vertexElements = [new VertexElement("a_position", 0, exports3.VertexElementFormat.Vector3, 0), new VertexElement("a_velocity", 12, exports3.VertexElementFormat.Vector3, 0), new VertexElement("a_acceleration", 24, exports3.VertexElementFormat.Vector3, 0), new VertexElement("a_color", 36, exports3.VertexElementFormat.Vector4, 0), new VertexElement("a_lifeAndSize", 52, exports3.VertexElementFormat.Vector4, 0), new VertexElement("a_rotation", 68, exports3.VertexElementFormat.Vector2, 0), new VertexElement("a_uv", 76, exports3.VertexElementFormat.Vector3, 0), new VertexElement("a_normalizedUv", 88, exports3.VertexElementFormat.Vector2, 0)];
        var vertexBuffer = new Buffer2(this.engine, exports3.BufferBindFlag.VertexBuffer, vertexFloatCount * 4, exports3.BufferUsage.Dynamic);
        var indexBuffer = new Buffer2(this.engine, exports3.BufferBindFlag.IndexBuffer, indices, exports3.BufferUsage.Dynamic);
        mesh.setVertexBufferBinding(vertexBuffer, vertexStride);
        mesh.setIndexBufferBinding(indexBuffer, useUint32 ? exports3.IndexFormat.UInt32 : exports3.IndexFormat.UInt16);
        mesh.setVertexElements(vertexElements);
        mesh.addSubMesh(0, indices.length);
        this._vertexBuffer = vertexBuffer;
        this._vertexStride = vertexStride / 4;
        this._vertices = vertices;
        return mesh;
      };
      _proto._updateBuffer = function _updateBuffer() {
        for (var x = 0; x < this._maxCount; x++) {
          this._updateSingleBuffer(x);
        }
        this._vertexBuffer.setData(this._vertices);
      };
      _proto._updateSingleBuffer = function _updateSingleBuffer(i) {
        var _updateDirtyFlag = this._updateDirtyFlag, vertices = this._vertices, vertexStride = this._vertexStride;
        var getRandom = ParticleRenderer2._getRandom;
        var offset = i * 4;
        var k0 = offset * vertexStride;
        var k1 = (offset + 1) * vertexStride;
        var k2 = (offset + 2) * vertexStride;
        var k3 = (offset + 3) * vertexStride;
        if (_updateDirtyFlag & DirtyFlagType.Position) {
          var _this$_position = this._position, x = _this$_position.x, y = _this$_position.y, z = _this$_position.z;
          var _positionArray = this._positionArray, _positionRandomness = this._positionRandomness;
          if (_positionArray) {
            if (_positionArray.length !== this._maxCount) {
              throw Error("The length of positionArray must be equal to maxCount.");
            }
            var pos = _positionArray[i];
            x += pos.x;
            y += pos.y;
            z += pos.z;
          } else {
            x += getRandom() * _positionRandomness.x;
            y += getRandom() * _positionRandomness.y;
            z += getRandom() * _positionRandomness.z;
          }
          vertices[k0] = vertices[k1] = vertices[k2] = vertices[k3] = x;
          vertices[k0 + 1] = vertices[k1 + 1] = vertices[k2 + 1] = vertices[k3 + 1] = y;
          vertices[k0 + 2] = vertices[k1 + 2] = vertices[k2 + 2] = vertices[k3 + 2] = z;
        }
        if (_updateDirtyFlag & DirtyFlagType.Velocity) {
          var _velocity = this._velocity, _velocityRandomness = this._velocityRandomness;
          vertices[k0 + 3] = vertices[k1 + 3] = vertices[k2 + 3] = vertices[k3 + 3] = _velocity.x + getRandom() * _velocityRandomness.x;
          vertices[k0 + 4] = vertices[k1 + 4] = vertices[k2 + 4] = vertices[k3 + 4] = _velocity.y + getRandom() * _velocityRandomness.y;
          vertices[k0 + 5] = vertices[k1 + 5] = vertices[k2 + 5] = vertices[k3 + 5] = _velocity.z + getRandom() * _velocityRandomness.z;
        }
        if (_updateDirtyFlag & DirtyFlagType.Acceleration) {
          var _acceleration = this._acceleration, _accelerationRandomness = this._accelerationRandomness;
          vertices[k0 + 6] = vertices[k1 + 6] = vertices[k2 + 6] = vertices[k3 + 6] = _acceleration.x + getRandom() * _accelerationRandomness.x;
          vertices[k0 + 7] = vertices[k1 + 7] = vertices[k2 + 7] = vertices[k3 + 7] = _acceleration.y + getRandom() * _accelerationRandomness.y;
          vertices[k0 + 8] = vertices[k1 + 8] = vertices[k2 + 8] = vertices[k3 + 8] = _acceleration.z + getRandom() * _accelerationRandomness.z;
        }
        if (_updateDirtyFlag & DirtyFlagType.Color) {
          var _color = this._color, _colorRandomness = this._colorRandomness;
          vertices[k0 + 9] = vertices[k1 + 9] = vertices[k2 + 9] = vertices[k3 + 9] = miniprogram2.MathUtil.clamp(_color.r + getRandom() * _colorRandomness, 0, 1);
          vertices[k0 + 10] = vertices[k1 + 10] = vertices[k2 + 10] = vertices[k3 + 10] = miniprogram2.MathUtil.clamp(_color.g + getRandom() * _colorRandomness, 0, 1);
          vertices[k0 + 11] = vertices[k1 + 11] = vertices[k2 + 11] = vertices[k3 + 11] = miniprogram2.MathUtil.clamp(_color.b + getRandom() * _colorRandomness, 0, 1);
        }
        if (_updateDirtyFlag & DirtyFlagType.Alpha) {
          vertices[k0 + 12] = vertices[k1 + 12] = vertices[k2 + 12] = vertices[k3 + 12] = miniprogram2.MathUtil.clamp(this._alpha + getRandom() * this._alphaRandomness, 0, 1);
        }
        if (_updateDirtyFlag & DirtyFlagType.StartTime) {
          vertices[k0 + 13] = vertices[k1 + 13] = vertices[k2 + 13] = vertices[k3 + 13] = Math.random() * this._startTimeRandomness;
        }
        if (_updateDirtyFlag & DirtyFlagType.LifeTime) {
          var _lifetime = this._lifetime;
          vertices[k0 + 14] = vertices[k1 + 14] = vertices[k2 + 14] = vertices[k3 + 14] = _lifetime + getRandom() * _lifetime;
        }
        if (_updateDirtyFlag & DirtyFlagType.StartTime || _updateDirtyFlag & DirtyFlagType.LifeTime) {
          this._onceTime = Math.max(this._onceTime, vertices[k0 + 13] + vertices[k0 + 14]);
        }
        if (_updateDirtyFlag & DirtyFlagType.Size) {
          var _size = this._size;
          vertices[k0 + 15] = vertices[k1 + 15] = vertices[k2 + 15] = vertices[k3 + 15] = Math.max(_size + getRandom() * this._sizeRandomness * _size * 2, 0);
        }
        if (_updateDirtyFlag & DirtyFlagType.Scale) {
          vertices[k0 + 16] = vertices[k1 + 16] = vertices[k2 + 16] = vertices[k3 + 16] = this._scale;
        }
        if (_updateDirtyFlag & DirtyFlagType.StartAngle) {
          vertices[k0 + 17] = vertices[k1 + 17] = vertices[k2 + 17] = vertices[k3 + 17] = this._startAngle + getRandom() * Math.PI * this._startAngleRandomness * 2;
        }
        if (_updateDirtyFlag & DirtyFlagType.RotateVelocity) {
          vertices[k0 + 18] = vertices[k1 + 18] = vertices[k2 + 18] = vertices[k3 + 18] = this._rotateVelocity + getRandom() * this._rotateVelocityRandomness;
        }
        this._updateSingleUv(i, k0, k1, k2, k3);
      };
      _proto._updateSingleUv = function _updateSingleUv(i, k0, k1, k2, k3) {
        var spriteSheet = this.spriteSheet;
        var texture = this.getMaterial().shaderData.getTexture("u_texture");
        var vertices = this._vertices;
        if (texture) {
          var width = texture.width;
          var height = texture.height;
          if (spriteSheet) {
            var _spriteSheet = spriteSheet[i % spriteSheet.length], x = _spriteSheet.x, y = _spriteSheet.y, w = _spriteSheet.w, h = _spriteSheet.h;
            var u = x / width;
            var v = y / height;
            var p = u + w / width;
            var q = v + h / height;
            var ratio = h / w;
            vertices[k0 + 19] = u;
            vertices[k0 + 20] = q;
            vertices[k0 + 21] = ratio;
            vertices[k1 + 19] = p;
            vertices[k1 + 20] = q;
            vertices[k1 + 21] = ratio;
            vertices[k2 + 19] = p;
            vertices[k2 + 20] = v;
            vertices[k2 + 21] = ratio;
            vertices[k3 + 19] = u;
            vertices[k3 + 20] = v;
            vertices[k3 + 21] = ratio;
          } else {
            var _ratio = height / width;
            vertices[k0 + 19] = 0;
            vertices[k0 + 20] = 1;
            vertices[k0 + 21] = _ratio;
            vertices[k1 + 19] = 1;
            vertices[k1 + 20] = 1;
            vertices[k1 + 21] = _ratio;
            vertices[k2 + 19] = 1;
            vertices[k2 + 20] = 0;
            vertices[k2 + 21] = _ratio;
            vertices[k3 + 19] = 0;
            vertices[k3 + 20] = 0;
            vertices[k3 + 21] = _ratio;
          }
        } else {
          vertices[k0 + 19] = 0;
          vertices[k0 + 20] = 0;
          vertices[k0 + 21] = 1;
          vertices[k1 + 19] = 1;
          vertices[k1 + 20] = 0;
          vertices[k1 + 21] = 1;
          vertices[k2 + 19] = 1;
          vertices[k2 + 20] = 1;
          vertices[k2 + 21] = 1;
          vertices[k3 + 19] = 0;
          vertices[k3 + 20] = 1;
          vertices[k3 + 21] = 1;
        }
        vertices[k0 + 22] = -0.5;
        vertices[k0 + 23] = -0.5;
        vertices[k1 + 22] = 0.5;
        vertices[k1 + 23] = -0.5;
        vertices[k2 + 22] = 0.5;
        vertices[k2 + 23] = 0.5;
        vertices[k3 + 22] = -0.5;
        vertices[k3 + 23] = 0.5;
      };
      _createClass2(ParticleRenderer2, [{
        key: "texture",
        get: function get() {
          return this.getMaterial().shaderData.getTexture("u_texture");
        },
        set: function set(texture) {
          if (texture) {
            this.shaderData.enableMacro("particleTexture");
            this.getMaterial().shaderData.setTexture("u_texture", texture);
          } else {
            this.shaderData.disableMacro("particleTexture");
          }
        }
      }, {
        key: "position",
        get: function get() {
          return this._position;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.Position;
          this._position = value;
        }
      }, {
        key: "positionRandomness",
        get: function get() {
          return this._positionRandomness;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.Position;
          this._positionRandomness = value;
        }
      }, {
        key: "positionArray",
        get: function get() {
          return this._positionArray;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.Position;
          this._positionArray = value;
        }
      }, {
        key: "velocity",
        get: function get() {
          return this._velocity;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.Velocity;
          this._velocity = value;
        }
      }, {
        key: "velocityRandomness",
        get: function get() {
          return this._velocityRandomness;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.Velocity;
          this._velocityRandomness = value;
        }
      }, {
        key: "acceleration",
        get: function get() {
          return this._acceleration;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.Acceleration;
          this._acceleration = value;
        }
      }, {
        key: "accelerationRandomness",
        get: function get() {
          return this._accelerationRandomness;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.Acceleration;
          this._accelerationRandomness = value;
        }
      }, {
        key: "color",
        get: function get() {
          return this._color;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.Color;
          this._color = value;
        }
      }, {
        key: "colorRandomness",
        get: function get() {
          return this._colorRandomness;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.Color;
          this._colorRandomness = value;
        }
      }, {
        key: "size",
        get: function get() {
          return this._size;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.Size;
          this._size = value;
        }
      }, {
        key: "sizeRandomness",
        get: function get() {
          return this._sizeRandomness;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.Size;
          this._sizeRandomness = value;
        }
      }, {
        key: "alpha",
        get: function get() {
          return this._alpha;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.Alpha;
          this._alpha = value;
        }
      }, {
        key: "alphaRandomness",
        get: function get() {
          return this._alphaRandomness;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.Alpha;
          this._alphaRandomness = value;
        }
      }, {
        key: "angle",
        get: function get() {
          return this._startAngle;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.StartAngle;
          this._startAngle = value;
        }
      }, {
        key: "angleRandomness",
        get: function get() {
          return this._startAngleRandomness;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.StartAngle;
          this._startAngleRandomness = value;
        }
      }, {
        key: "rotateVelocity",
        get: function get() {
          return this._rotateVelocity;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.RotateVelocity;
          this._rotateVelocity = value;
        }
      }, {
        key: "rotateVelocityRandomness",
        get: function get() {
          return this._rotateVelocityRandomness;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.RotateVelocity;
          this._rotateVelocityRandomness = value;
        }
      }, {
        key: "lifetime",
        get: function get() {
          return this._lifetime;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.LifeTime;
          this._lifetime = value;
          this._onceTime = 0;
        }
      }, {
        key: "startTimeRandomness",
        get: function get() {
          return this._startTimeRandomness;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.StartTime;
          this._startTimeRandomness = value;
          this._onceTime = 0;
        }
      }, {
        key: "scale",
        get: function get() {
          return this._scale;
        },
        set: function set(value) {
          this._updateDirtyFlag |= DirtyFlagType.Scale;
          this._scale = value;
        }
      }, {
        key: "maxCount",
        get: function get() {
          return this._maxCount;
        },
        set: function set(value) {
          this._isStart = false;
          this._isInit = false;
          this._maxCount = value;
          this._updateDirtyFlag = DirtyFlagType.Everything;
          this.mesh = this._createMesh();
          this._updateBuffer();
          this._isInit = true;
          this.shaderData.setFloat("u_time", 0);
        }
      }, {
        key: "isOnce",
        get: function get() {
          return this._isOnce;
        },
        set: function set(value) {
          this._time = 0;
          this.shaderData.setInt("u_once", value ? 1 : 0);
          this._isOnce = value;
        }
      }, {
        key: "isRotateToVelocity",
        get: function get() {
          return this._isRotateToVelocity;
        },
        set: function set(value) {
          if (value) {
            this.shaderData.enableMacro("rotateToVelocity");
          } else {
            this.shaderData.disableMacro("rotateToVelocity");
          }
          this._isRotateToVelocity = value;
        }
      }, {
        key: "isUseOriginColor",
        get: function get() {
          return this._isUseOriginColor;
        },
        set: function set(value) {
          if (value) {
            this.shaderData.enableMacro("useOriginColor");
          } else {
            this.shaderData.disableMacro("useOriginColor");
          }
          this._isUseOriginColor = value;
        }
      }, {
        key: "isScaleByLifetime",
        get: function get() {
          return this._isScaleByLifetime;
        },
        set: function set(value) {
          if (value) {
            this.shaderData.enableMacro("isScaleByLifetime");
          } else {
            this.shaderData.disableMacro("isScaleByLifetime");
          }
          this._isScaleByLifetime = value;
        }
      }, {
        key: "is2d",
        get: function get() {
          return this._is2d;
        },
        set: function set(value) {
          if (value) {
            this.shaderData.enableMacro("is2d");
          } else {
            this.shaderData.disableMacro("is2d");
            this.getMaterial().renderState.rasterState.cullMode = exports3.CullMode.Off;
          }
          this._is2d = value;
        }
      }, {
        key: "isFadeIn",
        get: function get() {
          return this._isFadeIn;
        },
        set: function set(value) {
          if (value) {
            this.shaderData.enableMacro("fadeIn");
          } else {
            this.shaderData.disableMacro("fadeIn");
          }
          this._isFadeIn = value;
        }
      }, {
        key: "isFadeOut",
        get: function get() {
          return this._isFadeOut;
        },
        set: function set(value) {
          if (value) {
            this.shaderData.enableMacro("fadeOut");
          } else {
            this.shaderData.disableMacro("fadeOut");
          }
          this._isFadeOut = value;
        }
      }, {
        key: "playOnEnable",
        get: function get() {
          return this._playOnEnable;
        },
        set: function set(value) {
          this._playOnEnable = value;
          if (value) {
            this.start();
          } else {
            this.stop();
          }
        }
      }, {
        key: "blendMode",
        get: function get() {
          return this._blendMode;
        },
        set: function set(value) {
          var blendState = this.getMaterial().renderState.blendState;
          var target = blendState.targetBlendState;
          if (value === exports3.ParticleRendererBlendMode.Transparent) {
            target.enabled = true;
            target.sourceColorBlendFactor = exports3.BlendFactor.SourceAlpha;
            target.destinationColorBlendFactor = exports3.BlendFactor.OneMinusSourceAlpha;
            target.sourceAlphaBlendFactor = exports3.BlendFactor.One;
            target.destinationAlphaBlendFactor = exports3.BlendFactor.OneMinusSourceAlpha;
          } else if (value === exports3.ParticleRendererBlendMode.Additive) {
            target.enabled = true;
            target.sourceColorBlendFactor = exports3.BlendFactor.SourceAlpha;
            target.destinationColorBlendFactor = exports3.BlendFactor.One;
            target.sourceAlphaBlendFactor = exports3.BlendFactor.One;
            target.destinationAlphaBlendFactor = exports3.BlendFactor.OneMinusSourceAlpha;
          }
          this._blendMode = value;
        }
      }]);
      return ParticleRenderer2;
    }(MeshRenderer);
    ParticleRenderer._uint16VertexLimit = 65535;
    var FRAG_SHADER = "#define GLSLIFY 1\nvarying vec2 v_uv;uniform sampler2D u_texture;void main(void){gl_FragColor=texture2D(u_texture,v_uv);}";
    var VERT_SHADER = "#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;uniform mat4 u_projMat;uniform mat4 u_viewMat;void main(){gl_Position=u_projMat*u_viewMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";
    Shader.create("trail", VERT_SHADER, FRAG_SHADER);
    var TrailMaterial = /* @__PURE__ */ function(_Material) {
      _inheritsLoose2(TrailMaterial2, _Material);
      function TrailMaterial2(engine) {
        var _this;
        _this = _Material.call(this, engine, Shader.find("trail")) || this;
        var target = _this.renderState.blendState.targetBlendState;
        target.enabled = true;
        target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = exports3.BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = exports3.BlendFactor.One;
        _this.renderState.depthState.writeEnabled = false;
        return _this;
      }
      return TrailMaterial2;
    }(Material);
    var _tempVector3 = new miniprogram2.Vector3();
    var TrailRenderer = /* @__PURE__ */ function(_MeshRenderer) {
      _inheritsLoose2(TrailRenderer2, _MeshRenderer);
      function TrailRenderer2(entity, props) {
        var _this;
        _this = _MeshRenderer.call(this, entity) || this;
        _this._vertexStride = void 0;
        _this._vertices = void 0;
        _this._vertexBuffer = void 0;
        _this._stroke = void 0;
        _this._minSeg = void 0;
        _this._lifetime = void 0;
        _this._maxPointNum = void 0;
        _this._points = void 0;
        _this._pointStates = void 0;
        _this._strapPoints = void 0;
        _this._curPointNum = void 0;
        _this._prePointsNum = void 0;
        _this._stroke = props.stroke || 0.2;
        _this._minSeg = props.minSeg || 0.02;
        _this._lifetime = props.lifetime || 1e3;
        _this._maxPointNum = _this._lifetime / 1e3 * entity.engine.targetFrameRate;
        _this._points = [];
        _this._pointStates = [];
        _this._strapPoints = [];
        for (var i = 0; i < _this._maxPointNum; i++) {
          _this._points.push(new miniprogram2.Vector3());
          _this._pointStates.push(_this._lifetime);
          _this._strapPoints.push(new miniprogram2.Vector3());
          _this._strapPoints.push(new miniprogram2.Vector3());
        }
        _this._curPointNum = 0;
        var mtl = props.material || new TrailMaterial(_this.engine);
        _this.setMaterial(mtl);
        _this.setTexture(props.texture);
        _this._initGeometry();
        return _this;
      }
      var _proto = TrailRenderer2.prototype;
      _proto.update = function update(deltaTime) {
        var mov = 0, newIdx = 0;
        for (var i = 0; i < this._curPointNum; i++) {
          this._pointStates[i] -= deltaTime;
          if (this._pointStates[i] < 0) {
            mov++;
          } else if (mov > 0) {
            newIdx = i - mov;
            this._pointStates[newIdx] = this._pointStates[i];
            this._points[newIdx].copyFrom(this._points[i]);
          }
        }
        this._curPointNum -= mov;
        var appendNewPoint = true;
        if (this._curPointNum === this._maxPointNum) {
          appendNewPoint = false;
        } else if (this._curPointNum > 0) {
          var lastPoint = this._points[this._points.length - 1];
          if (miniprogram2.Vector3.distance(this.entity.transform.worldPosition, lastPoint) < this._minSeg) {
            appendNewPoint = false;
          }
        }
        if (appendNewPoint) {
          this._pointStates[this._curPointNum] = this._lifetime;
          this._points[this._curPointNum].copyFrom(this.entity.transform.worldPosition);
          this._curPointNum++;
        }
      };
      _proto._render = function _render(camera) {
        this._updateStrapVertices(camera, this._points);
        this._updateStrapCoords();
        this._vertexBuffer.setData(this._vertices);
        _MeshRenderer.prototype._render.call(this, camera);
      };
      _proto.setTexture = function setTexture(texture) {
        if (texture) {
          this.getMaterial().shaderData.setTexture("u_texture", texture);
        }
      };
      _proto._initGeometry = function _initGeometry() {
        var mesh = new BufferMesh(this._entity.engine);
        var vertexStride = 20;
        var vertexCount = this._maxPointNum * 2;
        var vertexFloatCount = vertexCount * vertexStride;
        var vertices = new Float32Array(vertexFloatCount);
        var vertexElements = [new VertexElement("POSITION", 0, exports3.VertexElementFormat.Vector3, 0), new VertexElement("TEXCOORD_0", 12, exports3.VertexElementFormat.Vector2, 0)];
        var vertexBuffer = new Buffer2(this.engine, vertexFloatCount * 4, exports3.BufferUsage.Dynamic);
        mesh.setVertexBufferBinding(vertexBuffer, vertexStride);
        mesh.setVertexElements(vertexElements);
        mesh.addSubMesh(0, vertexCount, exports3.MeshTopology.TriangleStrip);
        this._vertexBuffer = vertexBuffer;
        this._vertexStride = vertexStride;
        this._vertices = vertices;
        this.mesh = mesh;
      };
      _proto._updateStrapVertices = function _updateStrapVertices(camera, points) {
        var m = camera.viewMatrix;
        var e = m.elements;
        var vx = new miniprogram2.Vector3(e[0], e[4], e[8]);
        var vy = new miniprogram2.Vector3(e[1], e[5], e[9]);
        var vz = new miniprogram2.Vector3(e[2], e[6], e[10]);
        var s = this._stroke;
        vy.scale(s);
        var up = new miniprogram2.Vector3();
        var down = new miniprogram2.Vector3();
        var rotation = new miniprogram2.Quaternion();
        miniprogram2.Vector3.transformByQuat(vx, rotation, vx);
        miniprogram2.Vector3.transformByQuat(vy, rotation, vy);
        var dy = new miniprogram2.Vector3();
        var cross = new miniprogram2.Vector3();
        var perpVector = new miniprogram2.Vector3();
        vx.normalize();
        var vertices = this._vertices;
        for (var i = 0; i < this._maxPointNum; i++) {
          if (i < this._curPointNum) {
            var p = points[i];
            if (i === this._curPointNum - 1 && i !== 0) {
              miniprogram2.Vector3.subtract(p, points[i - 1], perpVector);
            } else {
              miniprogram2.Vector3.subtract(points[i + 1], p, perpVector);
            }
            this._projectOnPlane(perpVector, vz, perpVector);
            perpVector.normalize();
            var angle = Math.acos(miniprogram2.Vector3.dot(vx, perpVector));
            miniprogram2.Vector3.cross(vx, perpVector, cross);
            if (miniprogram2.Vector3.dot(cross, vz) <= 0) {
              angle = Math.PI * 2 - angle;
            }
            miniprogram2.Quaternion.rotationAxisAngle(vz, angle, rotation);
            miniprogram2.Vector3.transformByQuat(vy, rotation, dy);
            miniprogram2.Vector3.add(p, dy, up);
            miniprogram2.Vector3.subtract(p, dy, down);
          }
          var p0 = i * 2 * this._vertexStride / 4;
          var p1 = (i * 2 + 1) * this._vertexStride / 4;
          vertices[p0] = up.x;
          vertices[p0 + 1] = up.y;
          vertices[p0 + 2] = up.z;
          vertices[p1] = down.x;
          vertices[p1 + 1] = down.y;
          vertices[p1 + 2] = down.z;
        }
      };
      _proto._updateStrapCoords = function _updateStrapCoords() {
        if (this._prePointsNum === this._curPointNum) {
          return;
        }
        this._prePointsNum = this._curPointNum;
        var count = this._curPointNum;
        var texDelta = 1 / count;
        var vertices = this._vertices;
        for (var i = 0; i < count; i++) {
          var d = 1 - i * texDelta;
          var p0 = i * 2 * this._vertexStride / 4;
          var p1 = (i * 2 + 1) * this._vertexStride / 4;
          vertices[p0] = 0;
          vertices[p0 + 1] = d;
          vertices[p1] = 1;
          vertices[p1 + 1] = d;
        }
      };
      _proto._projectOnVector = function _projectOnVector(a, p, out) {
        var n_p = p.clone();
        miniprogram2.Vector3.normalize(n_p, n_p);
        var cosine = miniprogram2.Vector3.dot(a, n_p);
        out.x = n_p.x * cosine;
        out.y = n_p.y * cosine;
        out.z = n_p.z * cosine;
      };
      _proto._projectOnPlane = function _projectOnPlane(a, n, out) {
        this._projectOnVector(a, n, _tempVector3);
        miniprogram2.Vector3.subtract(a, _tempVector3, out);
      };
      return TrailRenderer2;
    }(MeshRenderer);
    var Fog = /* @__PURE__ */ function(_Component) {
      _inheritsLoose2(Fog2, _Component);
      function Fog2(entity) {
        var _this;
        _this = _Component.call(this, entity) || this;
        _this._color = new miniprogram2.Color(1, 0, 0, 1);
        _this.color = _this._color;
        return _this;
      }
      var _proto = Fog2.prototype;
      _proto._onEnable = function _onEnable() {
        this.scene.shaderData.enableMacro("O3_HAS_FOG");
      };
      _proto._onDisable = function _onDisable() {
        this.scene.shaderData.disableMacro("O3_HAS_FOG");
      };
      _createClass2(Fog2, [{
        key: "color",
        get: function get() {
          return this._color;
        },
        set: function set(value) {
          this._color = value;
          this.scene.shaderData.setColor(Fog2._colorProperty, value);
        }
      }]);
      return Fog2;
    }(Component);
    Fog._colorProperty = Shader.getPropertyByName("u_fogColor");
    var EXP2Fog = /* @__PURE__ */ function(_Fog) {
      _inheritsLoose2(EXP2Fog2, _Fog);
      function EXP2Fog2(entity) {
        var _this;
        _this = _Fog.call(this, entity) || this;
        _this._density = 25e-4;
        _this.density = _this._density;
        return _this;
      }
      var _proto = EXP2Fog2.prototype;
      _proto._onEnable = function _onEnable() {
        this.scene.shaderData.enableMacro("O3_FOG_EXP2");
      };
      _proto._onDisable = function _onDisable() {
        this.scene.shaderData.disableMacro("O3_FOG_EXP2");
      };
      _createClass2(EXP2Fog2, [{
        key: "density",
        get: function get() {
          return this._density;
        },
        set: function set(value) {
          this._density = value;
          this.scene.shaderData.setFloat(EXP2Fog2._densityProperty, value);
        }
      }]);
      return EXP2Fog2;
    }(Fog);
    EXP2Fog._densityProperty = Shader.getPropertyByName("u_fogDensity");
    var LinearFog = /* @__PURE__ */ function(_Fog) {
      _inheritsLoose2(LinearFog2, _Fog);
      function LinearFog2(entity) {
        var _this;
        _this = _Fog.call(this, entity) || this;
        _this._near = 1;
        _this._far = 1e3;
        _this.near = _this._near;
        _this.far = _this._far;
        return _this;
      }
      _createClass2(LinearFog2, [{
        key: "near",
        get: function get() {
          return this._near;
        },
        set: function set(value) {
          this._near = value;
          this.scene.shaderData.setFloat(LinearFog2._nearProperty, value);
        }
      }, {
        key: "far",
        get: function get() {
          return this._far;
        },
        set: function set(value) {
          this._far = value;
          this.scene.shaderData.setFloat(LinearFog2._farProperty, value);
        }
      }]);
      return LinearFog2;
    }(Fog);
    LinearFog._nearProperty = Shader.getPropertyByName("u_fogNear");
    LinearFog._farProperty = Shader.getPropertyByName("u_fogFar");
    var Probe = /* @__PURE__ */ function(_Script) {
      _inheritsLoose2(Probe2, _Script);
      function Probe2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _Script.call.apply(_Script, [this].concat(args)) || this;
        _this.probeLayer = exports3.Layer.Everything;
        _this.width = 1024;
        _this.height = 1024;
        _this.antiAliasing = 1;
        _this._isCube = false;
        _this._oriCameraRenderTarget = void 0;
        _this._renderTarget = void 0;
        _this._renderTargetSwap = void 0;
        _this._activeRenderTarget = void 0;
        _this._camera = void 0;
        _this._oriCameraCullingMask = void 0;
        return _this;
      }
      var _proto = Probe2.prototype;
      _proto.onTextureChange = function onTextureChange(renderColorTexture) {
      };
      _proto.onBeginRender = function onBeginRender(camera) {
        if (!this.enabled)
          return;
        this._camera = camera;
        this._oriCameraCullingMask = camera.cullingMask;
        camera.cullingMask = this.probeLayer;
        if (!this._activeRenderTarget || this._activeRenderTarget.width !== this.width || this._activeRenderTarget.height !== this.height || this._activeRenderTarget.antiAliasing !== this.antiAliasing) {
          this._renderTarget = new RenderTarget(this.engine, this.width, this.height, this._isCube ? new TextureCube(this.engine, this.width) : new Texture2D(this.engine, this.width, this.height), exports3.RenderBufferDepthFormat.Depth, this.antiAliasing);
          this._renderTargetSwap = new RenderTarget(this.engine, this.width, this.height, this._isCube ? new TextureCube(this.engine, this.width) : new Texture2D(this.engine, this.width, this.height), exports3.RenderBufferDepthFormat.Depth, this.antiAliasing);
          this._activeRenderTarget = this._renderTarget;
        }
        this._oriCameraRenderTarget = camera.renderTarget;
        camera.renderTarget = this._activeRenderTarget;
      };
      _proto.onEndRender = function onEndRender(camera) {
        if (!this.enabled)
          return;
        this.onTextureChange && this.onTextureChange(this._texture);
        this._activeRenderTarget = this._activeRenderTarget === this._renderTarget ? this._renderTargetSwap : this._renderTarget;
      };
      _proto._reset = function _reset() {
        if (!this.enabled)
          return;
        this._camera.renderTarget = this._oriCameraRenderTarget;
        this._camera.cullingMask = this._oriCameraCullingMask;
      };
      _createClass2(Probe2, [{
        key: "_texture",
        get: function get() {
          var _this$_activeRenderTa;
          return (_this$_activeRenderTa = this._activeRenderTarget) === null || _this$_activeRenderTa === void 0 ? void 0 : _this$_activeRenderTa.getColorTexture();
        }
      }]);
      return Probe2;
    }(Script);
    var cacheTarget = new miniprogram2.Vector3();
    var cacheUp = new miniprogram2.Vector3();
    var cacheDir = new miniprogram2.Vector3();
    var CubeProbe = /* @__PURE__ */ function(_Probe) {
      _inheritsLoose2(CubeProbe2, _Probe);
      function CubeProbe2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _Probe.call.apply(_Probe, [this].concat(args)) || this;
        _this.position = new miniprogram2.Vector3(0, 0, 0);
        _this._isCube = true;
        _this.oriViewMatrix = new miniprogram2.Matrix();
        _this._oriFieldOfView = void 0;
        return _this;
      }
      var _proto = CubeProbe2.prototype;
      _proto.onBeginRender = function onBeginRender(camera) {
        if (!this.enabled)
          return;
        _Probe.prototype.onBeginRender.call(this, camera);
        this._storeCamera(camera);
        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
          this._setCamera(faceIndex, camera);
          camera.render(exports3.TextureCubeFace.PositiveX + faceIndex);
        }
        this._restoreCamera(camera);
        _Probe.prototype._reset.call(this);
      };
      _proto._storeCamera = function _storeCamera(camera) {
        this.oriViewMatrix.copyFrom(camera.viewMatrix);
        this._oriFieldOfView = camera.fieldOfView;
      };
      _proto._restoreCamera = function _restoreCamera(camera) {
        camera.viewMatrix.copyFrom(this.oriViewMatrix);
        camera.fieldOfView = this._oriFieldOfView;
      };
      _proto._setCamera = function _setCamera(faceIndex, camera) {
        switch (faceIndex) {
          case 0:
            cacheUp.set(0, -1, 0);
            cacheDir.set(1, 0, 0);
            break;
          case 1:
            cacheUp.set(0, -1, 0);
            cacheDir.set(-1, 0, 0);
            break;
          case 2:
            cacheUp.set(0, 0, 1);
            cacheDir.set(0, 1, 0);
            break;
          case 3:
            cacheUp.set(0, 0, -1);
            cacheDir.set(0, -1, 0);
            break;
          case 4:
            cacheUp.set(0, -1, 0);
            cacheDir.set(0, 0, 1);
            break;
          case 5:
            cacheUp.set(0, -1, 0);
            cacheDir.set(0, 0, -1);
            break;
        }
        miniprogram2.Vector3.add(this.position, cacheDir, cacheTarget);
        miniprogram2.Matrix.lookAt(this.position, cacheTarget, cacheUp, camera.viewMatrix);
        camera.fieldOfView = 90;
      };
      return CubeProbe2;
    }(Probe);
    var LightShadow = /* @__PURE__ */ function() {
      LightShadow2._updateShaderData = function _updateShaderData(shaderData) {
        var data = LightShadow2._combinedData;
        shaderData.setFloatArray(LightShadow2._viewMatFromLightProperty, data.viewMatrix);
        shaderData.setFloatArray(LightShadow2._projMatFromLightProperty, data.projectionMatrix);
        shaderData.setFloatArray(LightShadow2._shadowBiasProperty, data.bias);
        shaderData.setFloatArray(LightShadow2._shadowIntensityProperty, data.intensity);
        shaderData.setFloatArray(LightShadow2._shadowRadiusProperty, data.radius);
        shaderData.setFloatArray(LightShadow2._shadowMapSizeProperty, data.mapSize);
        shaderData.setTextureArray(LightShadow2._shadowMapsProperty, data.map);
      };
      LightShadow2.clearMap = function clearMap() {
        LightShadow2._combinedData.map.length = 0;
      };
      function LightShadow2(light, props) {
        if (props === void 0) {
          props = {
            engine: null,
            width: 512,
            height: 512
          };
        }
        this._mapSize = void 0;
        this._renderTarget = void 0;
        this.light = void 0;
        this.bias = 5e-3;
        this.intensity = 0.2;
        this.radius = 1;
        this.projectionMatrix = new miniprogram2.Matrix();
        this.light = light;
        var _props = props, engine = _props.engine, width = _props.width, height = _props.height;
        this._mapSize = new miniprogram2.Vector2(width, height);
        this._renderTarget = new RenderTarget(engine, width, height, new Texture2D(engine, width, height));
      }
      var _proto = LightShadow2.prototype;
      _proto.initShadowProjectionMatrix = function initShadowProjectionMatrix(light) {
        if (light instanceof DirectLight) {
          miniprogram2.Matrix.ortho(-5, 5, -5, 5, 0.1, 50, this.projectionMatrix);
        }
        if (light instanceof PointLight) {
          miniprogram2.Matrix.perspective(miniprogram2.MathUtil.degreeToRadian(50), 1, 0.5, 50, this.projectionMatrix);
        }
        if (light instanceof SpotLight) {
          var fov = Math.min(Math.PI / 2, light.angle * 2 * Math.sqrt(2));
          miniprogram2.Matrix.perspective(fov, 1, 0.1, light.distance + 5, this.projectionMatrix);
        }
      };
      _proto.appendData = function appendData(lightIndex) {
        var viewStart = lightIndex * 16;
        var projectionStart = lightIndex * 16;
        var biasStart = lightIndex;
        var intensityStart = lightIndex;
        var radiusStart = lightIndex;
        var mapSizeStart = lightIndex * 2;
        var mapStart = lightIndex;
        var data = LightShadow2._combinedData;
        data.viewMatrix.set(this.light.viewMatrix.elements, viewStart);
        data.projectionMatrix.set(this.projectionMatrix.elements, projectionStart);
        data.bias[biasStart] = this.bias;
        data.intensity[intensityStart] = this.intensity;
        data.radius[radiusStart] = this.radius;
        data.mapSize[mapSizeStart] = this.mapSize.x;
        data.mapSize[mapSizeStart + 1] = this.mapSize.y;
        data.map[mapStart] = this.map;
      };
      _createClass2(LightShadow2, [{
        key: "renderTarget",
        get: function get() {
          return this._renderTarget;
        }
      }, {
        key: "map",
        get: function get() {
          return this._renderTarget.getColorTexture();
        }
      }, {
        key: "mapSize",
        get: function get() {
          return this._mapSize;
        }
      }]);
      return LightShadow2;
    }();
    LightShadow._viewMatFromLightProperty = Shader.getPropertyByName("u_viewMatFromLight");
    LightShadow._projMatFromLightProperty = Shader.getPropertyByName("u_projMatFromLight");
    LightShadow._shadowBiasProperty = Shader.getPropertyByName("u_shadowBias");
    LightShadow._shadowIntensityProperty = Shader.getPropertyByName("u_shadowIntensity");
    LightShadow._shadowRadiusProperty = Shader.getPropertyByName("u_shadowRadius");
    LightShadow._shadowMapSizeProperty = Shader.getPropertyByName("u_shadowMapSize");
    LightShadow._shadowMapsProperty = Shader.getPropertyByName("u_shadowMaps");
    LightShadow._maxLight = 3;
    LightShadow._combinedData = {
      viewMatrix: new Float32Array(16 * LightShadow._maxLight),
      projectionMatrix: new Float32Array(16 * LightShadow._maxLight),
      bias: new Float32Array(LightShadow._maxLight),
      intensity: new Float32Array(LightShadow._maxLight),
      radius: new Float32Array(LightShadow._maxLight),
      mapSize: new Float32Array(2 * LightShadow._maxLight),
      map: []
    };
    Object.defineProperty(Light.prototype, "enableShadow", {
      get: function get() {
        return this._enableShadow;
      },
      set: function set(enabled) {
        this._enableShadow = enabled;
        if (this._enableShadow) {
          if (this instanceof AmbientLight) {
            this._enableShadow = false;
            Logger.warn("Has no shadow!");
            return;
          }
          this.shadow = this.shadow || new LightShadow(this, {
            engine: this.engine,
            width: 512,
            height: 512
          });
          this.shadow.initShadowProjectionMatrix(this);
        }
      }
    });
    Object.defineProperty(Component.prototype, "receiveShadow", {
      get: function get() {
        return this._receiveShadow;
      },
      set: function set(enabled) {
        this._receiveShadow = enabled;
      }
    });
    Object.defineProperty(Component.prototype, "castShadow", {
      get: function get() {
        return this._castShadow;
      },
      set: function set(enabled) {
        this._castShadow = enabled;
      }
    });
    var ShadowMapMaterial = /* @__PURE__ */ function(_Material) {
      _inheritsLoose2(ShadowMapMaterial2, _Material);
      function ShadowMapMaterial2(engine) {
        var _this;
        _this = _Material.call(this, engine, Shader.find("shadow-map")) || this;
        _this.shaderData.enableMacro("O3_GENERATE_SHADOW_MAP");
        return _this;
      }
      return ShadowMapMaterial2;
    }(Material);
    var ShadowMapPass = /* @__PURE__ */ function(_RenderPass) {
      _inheritsLoose2(ShadowMapPass2, _RenderPass);
      function ShadowMapPass2(name, priority, renderTarget, replaceMaterial, mask, light) {
        var _this;
        _this = _RenderPass.call(this, name, priority, renderTarget, replaceMaterial, mask) || this;
        _this.light = void 0;
        _this.light = light;
        _this.clearColor = new miniprogram2.Color(1, 1, 1, 1);
        return _this;
      }
      var _proto = ShadowMapPass2.prototype;
      _proto.preRender = function preRender(camera, queue) {
        var shaderData = this.replaceMaterial.shaderData;
        shaderData.setMatrix(ShadowMapPass2._viewMatFromLightProperty, this.light.viewMatrix);
        shaderData.setMatrix(ShadowMapPass2._projMatFromLightProperty, this.light.shadow.projectionMatrix);
      };
      return ShadowMapPass2;
    }(RenderPass);
    ShadowMapPass._viewMatFromLightProperty = Shader.getPropertyByName("u_viewMatFromLight");
    ShadowMapPass._projMatFromLightProperty = Shader.getPropertyByName("u_projMatFromLight");
    var ShadowMaterial = /* @__PURE__ */ function(_Material) {
      _inheritsLoose2(ShadowMaterial2, _Material);
      function ShadowMaterial2(engine) {
        var _this;
        _this = _Material.call(this, engine, Shader.find("shadow")) || this;
        var targetBlendState = _this.renderState.blendState.targetBlendState;
        targetBlendState.enabled = true;
        targetBlendState.sourceColorBlendFactor = targetBlendState.sourceAlphaBlendFactor = exports3.BlendFactor.DestinationColor;
        targetBlendState.destinationColorBlendFactor = targetBlendState.destinationAlphaBlendFactor = exports3.BlendFactor.Zero;
        _this.renderState.depthState.compareFunction = exports3.CompareFunction.LessEqual;
        _this.renderQueueType = exports3.RenderQueueType.Transparent;
        return _this;
      }
      return ShadowMaterial2;
    }(Material);
    var ShadowPass = /* @__PURE__ */ function(_RenderPass) {
      _inheritsLoose2(ShadowPass2, _RenderPass);
      function ShadowPass2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _RenderPass.call.apply(_RenderPass, [this].concat(args)) || this;
        _this.clearFlags = exports3.CameraClearFlags.None;
        return _this;
      }
      var _proto = ShadowPass2.prototype;
      _proto.preRender = function preRender(camera, queue) {
        this.enabled = false;
        var lightMgr = camera.scene.findFeature(LightFeature);
        var lights = lightMgr.visibleLights;
        var shaderData = this.replaceMaterial.shaderData;
        var pass = camera._renderPipeline.defaultRenderPass;
        this.renderTarget = pass.renderTarget;
        var shadowMapCount = 0;
        LightShadow.clearMap();
        for (var i = 0, len = lights.length; i < len; i++) {
          var lgt = lights[i];
          if (lgt.enableShadow) {
            lgt.shadow.appendData(shadowMapCount++);
          }
        }
        if (shadowMapCount) {
          this.enabled = true;
          LightShadow._updateShaderData(shaderData);
          shaderData.enableMacro("O3_SHADOW_MAP_COUNT", shadowMapCount.toString());
        } else {
          shaderData.disableMacro("O3_SHADOW_MAP_COUNT");
        }
      };
      return ShadowPass2;
    }(RenderPass);
    var ShadowFeature = /* @__PURE__ */ function(_SceneFeature) {
      _inheritsLoose2(ShadowFeature2, _SceneFeature);
      function ShadowFeature2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _SceneFeature.call.apply(_SceneFeature, [this].concat(args)) || this;
        _this._shadowPass = void 0;
        _this._shadowMapMaterial = void 0;
        return _this;
      }
      var _proto = ShadowFeature2.prototype;
      _proto.preRender = function preRender(scene, camera) {
        var lights = scene.findFeature(LightFeature).visibleLights;
        if (lights.length > 0) {
          if (!this._shadowPass) {
            this.addShadowPass(camera);
          }
          var renderPipeline = camera._renderPipeline;
          for (var i = 0, len = lights.length; i < len; i++) {
            var lgt = lights[i];
            if (lgt.enableShadow && !lgt.shadowMapPass) {
              lgt.shadowMapPass = this.addShadowMapPass(camera, lgt);
            } else if (!lgt.enableShadow && lgt.shadowMapPass) {
              renderPipeline.removeRenderPass(lgt.shadowMapPass);
              lgt.shadowMapPass = null;
            }
          }
          this.updatePassRenderFlag(renderPipeline._opaqueQueue);
          this.updatePassRenderFlag(renderPipeline._alphaTestQueue);
          this.updatePassRenderFlag(renderPipeline._transparentQueue);
        }
      };
      _proto.addShadowPass = function addShadowPass(camera) {
        var shadowMaterial = new ShadowMaterial(camera.engine);
        this._shadowPass = new ShadowPass("ShadowPass", 1, null, shadowMaterial, exports3.Layer.Layer30);
        var renderer = camera._renderPipeline;
        renderer.addRenderPass(this._shadowPass);
      };
      _proto.addShadowMapPass = function addShadowMapPass(camera, light) {
        this._shadowMapMaterial = this._shadowMapMaterial || new ShadowMapMaterial(camera.engine);
        var shadowMapPass = new ShadowMapPass(
          "ShadowMapPass",
          -1,
          light.shadow.renderTarget,
          this._shadowMapMaterial,
          exports3.Layer.Layer31,
          light
        );
        var renderer = camera._renderPipeline;
        renderer.addRenderPass(shadowMapPass);
        return shadowMapPass;
      };
      _proto.updatePassRenderFlag = function updatePassRenderFlag(renderQueue) {
        var items = renderQueue.items;
        for (var i = 0, len = items.length; i < len; i++) {
          var item = items[i];
          var component = item.component;
          var receiveShadow = component.receiveShadow;
          var castShadow = component.castShadow;
          if (receiveShadow === true) {
            component.entity.layer |= exports3.Layer.Layer30;
          } else if (receiveShadow === false) {
            component.entity.layer &= ~exports3.Layer.Layer30;
          }
          if (castShadow === true) {
            component.entity.layer |= exports3.Layer.Layer31;
          } else if (castShadow === false) {
            component.entity.layer &= ~exports3.Layer.Layer31;
          }
        }
      };
      return ShadowFeature2;
    }(SceneFeature);
    Scene.registerFeature(ShadowFeature);
    Scene.registerFeature(LightFeature);
    Scene.prototype.hasLight = hasLight;
    exports3.AmbientLight = AmbientLight;
    exports3.AnimationClip = AnimationClip;
    exports3.AnimationClipCurveBinding = AnimationClipCurveBinding;
    exports3.AnimationCurve = AnimationCurve;
    exports3.AnimationEvent = AnimationEvent;
    exports3.Animator = Animator;
    exports3.AnimatorController = AnimatorController;
    exports3.AnimatorControllerLayer = AnimatorControllerLayer;
    exports3.AnimatorState = AnimatorState;
    exports3.AnimatorStateMachine = AnimatorStateMachine;
    exports3.AnimatorStateTransition = AnimatorStateTransition;
    exports3.AssetPromise = AssetPromise;
    exports3.Background = Background;
    exports3.BaseMaterial = BaseMaterial;
    exports3.BasicRenderPipeline = BasicRenderPipeline;
    exports3.BlendShape = BlendShape;
    exports3.BlendShapeFrame = BlendShapeFrame;
    exports3.BlinnPhongMaterial = BlinnPhongMaterial;
    exports3.BoolUpdateFlag = BoolUpdateFlag;
    exports3.BoxColliderShape = BoxColliderShape;
    exports3.Buffer = Buffer2;
    exports3.BufferMesh = BufferMesh;
    exports3.BufferUtil = BufferUtil;
    exports3.Camera = Camera;
    exports3.CapsuleColliderShape = CapsuleColliderShape;
    exports3.CharacterController = CharacterController;
    exports3.CloneManager = CloneManager;
    exports3.Collider = Collider;
    exports3.ColliderShape = ColliderShape;
    exports3.Component = Component;
    exports3.CubeProbe = CubeProbe;
    exports3.DirectLight = DirectLight;
    exports3.DynamicCollider = DynamicCollider;
    exports3.EXP2Fog = EXP2Fog;
    exports3.Engine = Engine;
    exports3.EngineFeature = EngineFeature;
    exports3.EngineObject = EngineObject;
    exports3.Entity = Entity;
    exports3.Event = Event;
    exports3.EventDispatcher = EventDispatcher;
    exports3.FixedJoint = FixedJoint;
    exports3.Fog = Fog;
    exports3.Font = Font;
    exports3.HingeJoint = HingeJoint;
    exports3.HitResult = HitResult;
    exports3.IndexBufferBinding = IndexBufferBinding;
    exports3.InputManager = InputManager;
    exports3.InterpolableKeyframe = InterpolableKeyframe;
    exports3.Joint = Joint;
    exports3.JointLimits = JointLimits;
    exports3.JointMotor = JointMotor;
    exports3.Keyframe = Keyframe;
    exports3.Light = Light;
    exports3.LinearFog = LinearFog;
    exports3.ListenerUpdateFlag = ListenerUpdateFlag;
    exports3.Loader = Loader;
    exports3.Logger = Logger;
    exports3.Material = Material;
    exports3.Mesh = Mesh;
    exports3.MeshRenderElement = MeshRenderElement;
    exports3.MeshRenderer = MeshRenderer;
    exports3.ModelMesh = ModelMesh;
    exports3.ObjectValues = ObjectValues;
    exports3.PBRBaseMaterial = PBRBaseMaterial;
    exports3.PBRMaterial = PBRMaterial;
    exports3.PBRSpecularMaterial = PBRSpecularMaterial;
    exports3.ParticleRenderer = ParticleRenderer;
    exports3.PhysicsManager = PhysicsManager;
    exports3.PhysicsMaterial = PhysicsMaterial;
    exports3.PlaneColliderShape = PlaneColliderShape;
    exports3.PointLight = PointLight;
    exports3.Pointer = Pointer;
    exports3.PrimitiveMesh = PrimitiveMesh;
    exports3.Probe = Probe;
    exports3.RefObject = RefObject;
    exports3.RenderPass = RenderPass;
    exports3.RenderQueue = RenderQueue;
    exports3.RenderTarget = RenderTarget;
    exports3.Renderer = Renderer;
    exports3.ResourceManager = ResourceManager;
    exports3.Scene = Scene;
    exports3.SceneFeature = SceneFeature;
    exports3.SceneManager = SceneManager;
    exports3.Script = Script;
    exports3.Shader = Shader;
    exports3.ShaderData = ShaderData;
    exports3.ShaderFactory = ShaderFactory;
    exports3.ShaderProperty = ShaderProperty;
    exports3.Skin = Skin;
    exports3.SkinnedMeshRenderer = SkinnedMeshRenderer;
    exports3.Sky = Sky;
    exports3.SkyBoxMaterial = SkyBoxMaterial;
    exports3.SphereColliderShape = SphereColliderShape;
    exports3.SpotLight = SpotLight;
    exports3.SpringJoint = SpringJoint;
    exports3.Sprite = Sprite;
    exports3.SpriteAtlas = SpriteAtlas;
    exports3.SpriteElement = SpriteElement;
    exports3.SpriteMask = SpriteMask;
    exports3.SpriteRenderer = SpriteRenderer;
    exports3.StateMachineScript = StateMachineScript;
    exports3.StaticCollider = StaticCollider;
    exports3.SubMesh = SubMesh;
    exports3.SystemInfo = SystemInfo;
    exports3.TextRenderer = TextRenderer;
    exports3.Texture = Texture;
    exports3.Texture2D = Texture2D;
    exports3.Texture2DArray = Texture2DArray;
    exports3.TextureCube = TextureCube;
    exports3.Time = Time;
    exports3.TrailMaterial = TrailMaterial;
    exports3.TrailRenderer = TrailRenderer;
    exports3.Transform = Transform;
    exports3.UnlitMaterial = UnlitMaterial;
    exports3.Util = Util;
    exports3.VertexBufferBinding = VertexBufferBinding;
    exports3.VertexElement = VertexElement;
    exports3.assignmentClone = assignmentClone;
    exports3.deepClone = deepClone;
    exports3.dependentComponents = dependentComponents;
    exports3.ignoreClone = ignoreClone;
    exports3.request = request;
    exports3.resourceLoader = resourceLoader;
    exports3.shallowClone = shallowClone;
  })(miniprogram$9);
  var miniprogram$7 = {};
  var miniprogram$6 = {};
  (function(exports3) {
    Object.defineProperty(exports3, "__esModule", { value: true });
    var miniprogramAdapter2 = require$$0__default.default;
    var miniprogram2 = miniprogram$8;
    var miniprogram$12 = miniprogram$9;
    exports3.GLCompressedTextureInternalFormat = void 0;
    (function(GLCompressedTextureInternalFormat) {
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_4X4_KHR"] = 37808] = "RGBA_ASTC_4X4_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_5X4_KHR"] = 37809] = "RGBA_ASTC_5X4_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_5X5_KHR"] = 37810] = "RGBA_ASTC_5X5_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_6X5_KHR"] = 37811] = "RGBA_ASTC_6X5_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_6X6_KHR"] = 37812] = "RGBA_ASTC_6X6_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X5_KHR"] = 37813] = "RGBA_ASTC_8X5_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X6_KHR"] = 37814] = "RGBA_ASTC_8X6_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X8_KHR"] = 37815] = "RGBA_ASTC_8X8_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X5_KHR"] = 37816] = "RGBA_ASTC_10X5_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X6_KHR"] = 37817] = "RGBA_ASTC_10X6_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X8_KHR"] = 37818] = "RGBA_ASTC_10X8_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X10_KHR"] = 37819] = "RGBA_ASTC_10X10_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_12X10_KHR"] = 37820] = "RGBA_ASTC_12X10_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_12X12_KHR"] = 37821] = "RGBA_ASTC_12X12_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_4X4_KHR"] = 37840] = "SRGB8_ALPHA8_ASTC_4X4_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_5X4_KHR"] = 37841] = "SRGB8_ALPHA8_ASTC_5X4_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_5X5_KHR"] = 37842] = "SRGB8_ALPHA8_ASTC_5X5_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_6X5_KHR"] = 37843] = "SRGB8_ALPHA8_ASTC_6X5_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_6X6_KHR"] = 37844] = "SRGB8_ALPHA8_ASTC_6X6_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X5_KHR"] = 37845] = "SRGB8_ALPHA8_ASTC_8X5_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X6_KHR"] = 37846] = "SRGB8_ALPHA8_ASTC_8X6_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X8_KHR"] = 37847] = "SRGB8_ALPHA8_ASTC_8X8_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X5_KHR"] = 37848] = "SRGB8_ALPHA8_ASTC_10X5_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X6_KHR"] = 37849] = "SRGB8_ALPHA8_ASTC_10X6_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X8_KHR"] = 37850] = "SRGB8_ALPHA8_ASTC_10X8_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X10_KHR"] = 37851] = "SRGB8_ALPHA8_ASTC_10X10_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_12X10_KHR"] = 37852] = "SRGB8_ALPHA8_ASTC_12X10_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_12X12_KHR"] = 37853] = "SRGB8_ALPHA8_ASTC_12X12_KHR";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_ETC1_WEBGL"] = 36196] = "RGB_ETC1_WEBGL";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["R11_EAC"] = 37488] = "R11_EAC";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SIGNED_R11_EAC"] = 37489] = "SIGNED_R11_EAC";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RG11_EAC"] = 37490] = "RG11_EAC";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SIGNED_RG11_EAC"] = 37491] = "SIGNED_RG11_EAC";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB8_ETC2"] = 37492] = "RGB8_ETC2";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ETC2"] = 37493] = "SRGB8_ETC2";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA8_ETC2_EAC"] = 37496] = "RGBA8_ETC2_EAC";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "SRGB8_ALPHA8_ETC2_EAC";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_PVRTC_4BPPV1_IMG"] = 35840] = "RGB_PVRTC_4BPPV1_IMG";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_PVRTC_2BPPV1_IMG"] = 35841] = "RGB_PVRTC_2BPPV1_IMG";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "RGBA_PVRTC_4BPPV1_IMG";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "RGBA_PVRTC_2BPPV1_IMG";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_S3TC_DXT1_EXT"] = 33776] = "RGB_S3TC_DXT1_EXT";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT1_EXT"] = 33777] = "RGBA_S3TC_DXT1_EXT";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT3_EXT"] = 33778] = "RGBA_S3TC_DXT3_EXT";
      GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT5_EXT"] = 33779] = "RGBA_S3TC_DXT5_EXT";
    })(exports3.GLCompressedTextureInternalFormat || (exports3.GLCompressedTextureInternalFormat = {}));
    function ownKeys2(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread22(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
          _defineProperty2(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperties2(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties2(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _inheritsLoose2(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o, p) {
      _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf2(o, p);
    }
    var WebCanvas = /* @__PURE__ */ function() {
      var _proto = WebCanvas2.prototype;
      _proto.resizeByClientSize = function resizeByClientSize(pixelRatio) {
        if (pixelRatio === void 0) {
          pixelRatio = miniprogramAdapter2.window.devicePixelRatio;
        }
        var webCanvas = this._webCanvas;
        if (typeof miniprogramAdapter2.OffscreenCanvas === "undefined" || !(webCanvas instanceof miniprogramAdapter2.OffscreenCanvas)) {
          this.width = webCanvas.clientWidth * pixelRatio;
          this.height = webCanvas.clientHeight * pixelRatio;
        }
      };
      function WebCanvas2(webCanvas) {
        this._webCanvas = void 0;
        this._width = void 0;
        this._height = void 0;
        this._scale = new miniprogram2.Vector2();
        var width = webCanvas.width;
        var height = webCanvas.height;
        this._webCanvas = webCanvas;
        this._width = width;
        this._height = height;
      }
      _proto.setScale = function setScale(x, y) {
        this._scale.set(x, y);
        this.scale = this._scale;
      };
      _createClass2(WebCanvas2, [{
        key: "width",
        get: function get() {
          return this._width;
        },
        set: function set(value) {
          if (this._width !== value) {
            this._webCanvas.width = value;
            this._width = value;
          }
        }
      }, {
        key: "height",
        get: function get() {
          return this._height;
        },
        set: function set(value) {
          if (this._height !== value) {
            this._webCanvas.height = value;
            this._height = value;
          }
        }
      }, {
        key: "scale",
        get: function get() {
          var webCanvas = this._webCanvas;
          if (typeof miniprogramAdapter2.OffscreenCanvas === "undefined" || !(webCanvas instanceof miniprogramAdapter2.OffscreenCanvas)) {
            this._scale.set(webCanvas.clientWidth * miniprogramAdapter2.devicePixelRatio / webCanvas.width, webCanvas.clientHeight * miniprogramAdapter2.devicePixelRatio / webCanvas.height);
          }
          return this._scale;
        },
        set: function set(value) {
          var webCanvas = this._webCanvas;
          if (typeof miniprogramAdapter2.OffscreenCanvas === "undefined" || !(webCanvas instanceof miniprogramAdapter2.OffscreenCanvas)) {
            webCanvas.style.transformOrigin = "left top";
            webCanvas.style.transform = "scale(" + value.x + ", " + value.y + ")";
          }
        }
      }]);
      return WebCanvas2;
    }();
    var GLCapability = /* @__PURE__ */ function() {
      function GLCapability2(rhi) {
        this._maxDrawBuffers = void 0;
        this._maxAnisoLevel = void 0;
        this._maxAntiAliasing = void 0;
        this._rhi = void 0;
        this.capabilityList = void 0;
        this._rhi = rhi;
        this.capabilityList = /* @__PURE__ */ new Map();
        this._init();
        this._compatibleAllInterface();
      }
      var _proto = GLCapability2.prototype;
      _proto.canIUse = function canIUse(capabilityType) {
        return this.capabilityList.get(capabilityType);
      };
      _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(internalType) {
        var RGBA_ASTC_4X4_KHR = exports3.GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR, RGBA_ASTC_12X12_KHR = exports3.GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR, SRGB8_ALPHA8_ASTC_4X4_KHR = exports3.GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_4X4_KHR, SRGB8_ALPHA8_ASTC_12X12_KHR = exports3.GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_12X12_KHR, RGB_ETC1_WEBGL = exports3.GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL, R11_EAC = exports3.GLCompressedTextureInternalFormat.R11_EAC, SRGB8_ALPHA8_ETC2_EAC = exports3.GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ETC2_EAC, RGB_PVRTC_4BPPV1_IMG = exports3.GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG, RGBA_PVRTC_2BPPV1_IMG = exports3.GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG, RGB_S3TC_DXT1_EXT = exports3.GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT, RGBA_S3TC_DXT5_EXT = exports3.GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT;
        if (internalType >= RGBA_ASTC_4X4_KHR && RGBA_ASTC_12X12_KHR <= RGBA_ASTC_12X12_KHR || internalType >= SRGB8_ALPHA8_ASTC_4X4_KHR && internalType <= SRGB8_ALPHA8_ASTC_12X12_KHR) {
          return this.canIUse(miniprogram$12.GLCapabilityType.astc);
        } else if (internalType === RGB_ETC1_WEBGL) {
          return this.canIUse(miniprogram$12.GLCapabilityType.etc1);
        } else if (internalType >= R11_EAC && internalType <= SRGB8_ALPHA8_ETC2_EAC) {
          return this.canIUse(miniprogram$12.GLCapabilityType.etc);
        } else if (internalType >= RGB_PVRTC_4BPPV1_IMG && internalType <= RGBA_PVRTC_2BPPV1_IMG) {
          return this.canIUse(miniprogram$12.GLCapabilityType.pvrtc);
        } else if (internalType >= RGB_S3TC_DXT1_EXT && internalType <= RGBA_S3TC_DXT5_EXT) {
          return this.canIUse(miniprogram$12.GLCapabilityType.s3tc);
        }
        return false;
      };
      _proto._init = function _init() {
        var cap = this.capabilityList;
        var isWebGL2 = this.rhi.isWebGL2;
        var requireExtension = this.rhi.requireExtension.bind(this.rhi);
        var shaderVertexID = miniprogram$12.GLCapabilityType.shaderVertexID, standardDerivatives = miniprogram$12.GLCapabilityType.standardDerivatives, shaderTextureLod = miniprogram$12.GLCapabilityType.shaderTextureLod, elementIndexUint = miniprogram$12.GLCapabilityType.elementIndexUint, depthTexture = miniprogram$12.GLCapabilityType.depthTexture, vertexArrayObject = miniprogram$12.GLCapabilityType.vertexArrayObject, instancedArrays = miniprogram$12.GLCapabilityType.instancedArrays, multipleSample = miniprogram$12.GLCapabilityType.multipleSample, drawBuffers = miniprogram$12.GLCapabilityType.drawBuffers, astc = miniprogram$12.GLCapabilityType.astc, astc_webkit = miniprogram$12.GLCapabilityType.astc_webkit, etc = miniprogram$12.GLCapabilityType.etc, etc_webkit = miniprogram$12.GLCapabilityType.etc_webkit, etc1 = miniprogram$12.GLCapabilityType.etc1, etc1_webkit = miniprogram$12.GLCapabilityType.etc1_webkit, pvrtc = miniprogram$12.GLCapabilityType.pvrtc, pvrtc_webkit = miniprogram$12.GLCapabilityType.pvrtc_webkit, s3tc = miniprogram$12.GLCapabilityType.s3tc, s3tc_webkit = miniprogram$12.GLCapabilityType.s3tc_webkit, textureFloat = miniprogram$12.GLCapabilityType.textureFloat, textureHalfFloat = miniprogram$12.GLCapabilityType.textureHalfFloat, textureFloatLinear = miniprogram$12.GLCapabilityType.textureFloatLinear, textureHalfFloatLinear = miniprogram$12.GLCapabilityType.textureHalfFloatLinear, WEBGL_colorBufferFloat = miniprogram$12.GLCapabilityType.WEBGL_colorBufferFloat, colorBufferFloat = miniprogram$12.GLCapabilityType.colorBufferFloat, colorBufferHalfFloat = miniprogram$12.GLCapabilityType.colorBufferHalfFloat, textureFilterAnisotropic = miniprogram$12.GLCapabilityType.textureFilterAnisotropic;
        cap.set(shaderVertexID, isWebGL2);
        cap.set(standardDerivatives, isWebGL2 || !!requireExtension(standardDerivatives));
        cap.set(shaderTextureLod, isWebGL2 || !!requireExtension(shaderTextureLod));
        cap.set(elementIndexUint, isWebGL2 || !!requireExtension(elementIndexUint));
        cap.set(depthTexture, isWebGL2 || !!requireExtension(depthTexture));
        cap.set(vertexArrayObject, isWebGL2 || !!requireExtension(vertexArrayObject));
        cap.set(instancedArrays, isWebGL2 || !!requireExtension(instancedArrays));
        cap.set(multipleSample, isWebGL2);
        cap.set(drawBuffers, isWebGL2 || !!requireExtension(drawBuffers));
        cap.set(textureFloat, isWebGL2 || !!requireExtension(textureFloat));
        cap.set(textureHalfFloat, isWebGL2 || !!requireExtension(textureHalfFloat));
        cap.set(textureFloatLinear, !!requireExtension(textureFloatLinear));
        cap.set(textureHalfFloatLinear, isWebGL2 || !!requireExtension(textureHalfFloatLinear));
        cap.set(colorBufferFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(WEBGL_colorBufferFloat));
        cap.set(colorBufferHalfFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(colorBufferHalfFloat));
        cap.set(textureFilterAnisotropic, !!requireExtension(textureFilterAnisotropic));
        cap.set(astc, !!(requireExtension(astc) || requireExtension(astc_webkit)));
        cap.set(etc, !!(requireExtension(etc) || requireExtension(etc_webkit)));
        cap.set(etc1, !!(requireExtension(etc1) || requireExtension(etc1_webkit)));
        cap.set(pvrtc, !!(requireExtension(pvrtc) || requireExtension(pvrtc_webkit)));
        cap.set(s3tc, !!(requireExtension(s3tc) || requireExtension(s3tc_webkit)));
      };
      _proto._compatibleInterface = function _compatibleInterface(capabilityType, flatItem) {
        var rhi = this.rhi;
        var gl = rhi.gl;
        var ext = null;
        if (ext = rhi.requireExtension(capabilityType)) {
          for (var _glKey in flatItem) {
            var _extensionKey = flatItem[_glKey];
            var extensionVal = ext[_extensionKey];
            if (extensionVal !== null && extensionVal !== void 0 && extensionVal.bind) {
              gl[_glKey] = extensionVal.bind(ext);
            } else {
              gl[_glKey] = extensionVal;
            }
          }
        }
      };
      _proto._compatibleAllInterface = function _compatibleAllInterface() {
        var depthTexture = miniprogram$12.GLCapabilityType.depthTexture, vertexArrayObject = miniprogram$12.GLCapabilityType.vertexArrayObject, instancedArrays = miniprogram$12.GLCapabilityType.instancedArrays, drawBuffers = miniprogram$12.GLCapabilityType.drawBuffers, textureFilterAnisotropic = miniprogram$12.GLCapabilityType.textureFilterAnisotropic, textureHalfFloat = miniprogram$12.GLCapabilityType.textureHalfFloat, colorBufferHalfFloat = miniprogram$12.GLCapabilityType.colorBufferHalfFloat, WEBGL_colorBufferFloat = miniprogram$12.GLCapabilityType.WEBGL_colorBufferFloat;
        var isWebGL2 = this.rhi.isWebGL2;
        if (!isWebGL2) {
          this._compatibleInterface(depthTexture, {
            UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
          });
          this._compatibleInterface(vertexArrayObject, {
            createVertexArray: "createVertexArrayOES",
            deleteVertexArray: "deleteVertexArrayOES",
            isVertexArray: "isVertexArrayOES",
            bindVertexArray: "bindVertexArrayOES"
          });
          this._compatibleInterface(instancedArrays, {
            drawArraysInstanced: "drawArraysInstancedANGLE",
            drawElementsInstanced: "drawElementsInstancedANGLE",
            vertexAttribDivisor: "vertexAttribDivisorANGLE"
          });
          this._compatibleInterface(drawBuffers, {
            MAX_DRAW_BUFFERS: "MAX_DRAW_BUFFERS_WEBGL"
          });
          var items = {};
          if (this.canIUse(miniprogram$12.GLCapabilityType.drawBuffers)) {
            var maxDrawBuffers = this.maxDrawBuffers;
            for (var i = 0; i < maxDrawBuffers; i++) {
              i != 0 && (items["COLOR_ATTACHMENT" + i] = "COLOR_ATTACHMENT" + i + "_WEBGL");
              items["DRAW_BUFFER" + i] = "DRAW_BUFFER" + i + "_WEBGL";
            }
            this._compatibleInterface(drawBuffers, _objectSpread22({
              drawBuffers: "drawBuffersWEBGL"
            }, items));
          }
          this._compatibleInterface(textureHalfFloat, {
            HAFL_FLOAT: "HALF_FLOAT_OES"
          });
          this._compatibleInterface(colorBufferHalfFloat, {
            RGBA16F: "RBGA16F_EXT"
          });
          this._compatibleInterface(WEBGL_colorBufferFloat, {
            RGBA32F: "RBGA32F_EXT"
          });
        }
        this._compatibleInterface(textureFilterAnisotropic, {
          TEXTURE_MAX_ANISOTROPY_EXT: "TEXTURE_MAX_ANISOTROPY_EXT"
        });
      };
      _createClass2(GLCapability2, [{
        key: "maxTextureSize",
        get: function get() {
          return this.rhi.renderStates.getParameter(this.rhi.gl.MAX_TEXTURE_SIZE);
        }
      }, {
        key: "canUseFloatTextureBlendShape",
        get: function get() {
          return this.canIUse(miniprogram$12.GLCapabilityType.shaderVertexID) && this.canIUse(miniprogram$12.GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
        }
      }, {
        key: "canIUseMoreJoints",
        get: function get() {
          return this.canIUse(miniprogram$12.GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
        }
      }, {
        key: "maxDrawBuffers",
        get: function get() {
          if (!this._maxDrawBuffers) {
            if (this.canIUse(miniprogram$12.GLCapabilityType.drawBuffers)) {
              this._maxDrawBuffers = this._rhi.gl.getParameter(this._rhi.gl.MAX_DRAW_BUFFERS);
            } else {
              this._maxDrawBuffers = 1;
            }
          }
          return this._maxDrawBuffers;
        }
      }, {
        key: "maxAnisoLevel",
        get: function get() {
          if (!this._maxAnisoLevel) {
            var ext = this._rhi.requireExtension(miniprogram$12.GLCapabilityType.textureFilterAnisotropic);
            this._maxAnisoLevel = ext ? this._rhi.gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
          }
          return this._maxAnisoLevel;
        }
      }, {
        key: "maxAntiAliasing",
        get: function get() {
          if (!this._maxAntiAliasing) {
            var gl = this._rhi.gl;
            var canMSAA = this.canIUse(miniprogram$12.GLCapabilityType.multipleSample);
            this._maxAntiAliasing = canMSAA ? gl.getParameter(gl.MAX_SAMPLES) : 1;
          }
          return this._maxAntiAliasing;
        }
      }, {
        key: "rhi",
        get: function get() {
          return this._rhi;
        }
      }]);
      return GLCapability2;
    }();
    var GLExtensions = /* @__PURE__ */ function() {
      function GLExtensions2(rhi) {
        this.rhi = void 0;
        this._requireResult = void 0;
        this.rhi = rhi;
        this._requireResult = {};
      }
      var _proto = GLExtensions2.prototype;
      _proto.requireExtension = function requireExtension(ext) {
        if (this._requireResult[ext] !== void 0) {
          return this._requireResult[ext];
        }
        this._requireResult[ext] = this.rhi.gl.getExtension(ext);
        return this._requireResult[ext];
      };
      return GLExtensions2;
    }();
    var GLPrimitive = /* @__PURE__ */ function() {
      function GLPrimitive2(rhi, primitive) {
        this.attribLocArray = [];
        this._primitive = void 0;
        this.canUseInstancedArrays = void 0;
        this.gl = void 0;
        this.vao = /* @__PURE__ */ new Map();
        this._useVao = void 0;
        this._primitive = primitive;
        this.canUseInstancedArrays = rhi.canIUse(miniprogram$12.GLCapabilityType.instancedArrays);
        this._useVao = rhi.canIUse(miniprogram$12.GLCapabilityType.vertexArrayObject);
        this.gl = rhi.gl;
      }
      var _proto = GLPrimitive2.prototype;
      _proto.draw = function draw(shaderProgram, subMesh) {
        var gl = this.gl;
        var primitive = this._primitive;
        var useVao = this._useVao && primitive._enableVAO;
        if (useVao) {
          if (!this.vao.has(shaderProgram.id)) {
            this.registerVAO(shaderProgram);
          }
          var vao = this.vao.get(shaderProgram.id);
          gl.bindVertexArray(vao);
        } else {
          this.bindBufferAndAttrib(shaderProgram);
        }
        var _indexBufferBinding = primitive._indexBufferBinding, _instanceCount = primitive._instanceCount, _glIndexType = primitive._glIndexType, _glIndexByteCount = primitive._glIndexByteCount;
        var topology = subMesh.topology, start2 = subMesh.start, count = subMesh.count;
        if (!_instanceCount) {
          if (_indexBufferBinding) {
            if (useVao) {
              gl.drawElements(topology, count, _glIndexType, start2 * _glIndexByteCount);
            } else {
              var _nativeBuffer = _indexBufferBinding.buffer._nativeBuffer;
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer);
              gl.drawElements(topology, count, _glIndexType, start2 * _glIndexByteCount);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            }
          } else {
            gl.drawArrays(topology, start2, count);
          }
        } else {
          if (this.canUseInstancedArrays) {
            if (_indexBufferBinding) {
              if (this._useVao) {
                gl.drawElementsInstanced(topology, count, _glIndexType, start2 * _glIndexByteCount, _instanceCount);
              } else {
                var _nativeBuffer2 = _indexBufferBinding.buffer._nativeBuffer;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer2);
                gl.drawElementsInstanced(topology, count, _glIndexType, start2 * _glIndexByteCount, _instanceCount);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              }
            } else {
              gl.drawArraysInstanced(topology, start2, count, _instanceCount);
            }
          } else {
            miniprogram$12.Logger.error("ANGLE_instanced_arrays extension is not supported");
          }
        }
        if (this._useVao) {
          gl.bindVertexArray(null);
        } else {
          this.disableAttrib();
        }
      };
      _proto.destroy = function destroy() {
        if (this._useVao) {
          var gl = this.gl;
          this.vao.forEach(function(vao) {
            gl.deleteVertexArray(vao);
          });
          this.vao.clear();
        }
      };
      _proto.bindBufferAndAttrib = function bindBufferAndAttrib(shaderProgram) {
        var gl = this.gl;
        var primitive = this._primitive;
        var vertexBufferBindings = primitive._vertexBufferBindings;
        this.attribLocArray.length = 0;
        var attributeLocation = shaderProgram.attributeLocation;
        var attributes = primitive._vertexElementMap;
        var vbo;
        var lastBoundVbo;
        for (var name in attributeLocation) {
          var loc = attributeLocation[name];
          if (loc === -1)
            continue;
          var element = attributes[name];
          if (element) {
            var _vertexBufferBindings = vertexBufferBindings[element.bindingIndex], buffer = _vertexBufferBindings.buffer, stride = _vertexBufferBindings.stride;
            vbo = buffer._nativeBuffer;
            if (lastBoundVbo !== vbo) {
              lastBoundVbo = vbo;
              gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            }
            gl.enableVertexAttribArray(loc);
            var elementInfo = element._glElementInfo;
            gl.vertexAttribPointer(loc, elementInfo.size, elementInfo.type, elementInfo.normalized, stride, element.offset);
            if (this.canUseInstancedArrays) {
              gl.vertexAttribDivisor(loc, element.instanceStepRate);
            }
            this.attribLocArray.push(loc);
          } else {
            miniprogram$12.Logger.warn("vertex attribute not found: " + name);
          }
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      };
      _proto.disableAttrib = function disableAttrib() {
        var gl = this.gl;
        for (var i = 0, l = this.attribLocArray.length; i < l; i++) {
          gl.disableVertexAttribArray(this.attribLocArray[i]);
        }
      };
      _proto.registerVAO = function registerVAO(shaderProgram) {
        var gl = this.gl;
        var vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        var _indexBufferBinding = this._primitive._indexBufferBinding;
        if (_indexBufferBinding) {
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _indexBufferBinding.buffer._nativeBuffer);
        }
        this.bindBufferAndAttrib(shaderProgram);
        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        this.disableAttrib();
        this.vao.set(shaderProgram.id, vao);
      };
      return GLPrimitive2;
    }();
    var GLRenderStates = /* @__PURE__ */ function() {
      function GLRenderStates2(gl) {
        this._gl = void 0;
        this._parameters = {};
        this._gl = gl;
        this._parameters = {};
        this._parameters[gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        this._parameters[gl.MAX_VERTEX_UNIFORM_VECTORS] = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        this._parameters[gl.MAX_VERTEX_ATTRIBS] = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        this._parameters[gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        this._parameters[gl.MAX_TEXTURE_SIZE] = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.colorMask(true, true, true, true);
        gl.blendColor(0, 0, 0, 0);
        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);
        gl.depthMask(true);
        gl.disable(gl.STENCIL_TEST);
        gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 0, 255);
        gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 0, 255);
        gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMask(255);
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);
        gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(0, 0);
      }
      var _proto = GLRenderStates2.prototype;
      _proto.getParameter = function getParameter(pname) {
        return this._parameters[pname];
      };
      return GLRenderStates2;
    }();
    var GLTexture = /* @__PURE__ */ function() {
      GLTexture2._isPowerOf2 = function _isPowerOf2(v) {
        return (v & v - 1) === 0;
      };
      GLTexture2._getFormatDetail = function _getFormatDetail(format, gl, isWebGL2) {
        switch (format) {
          case miniprogram$12.TextureFormat.R8G8B8:
            return {
              internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
              baseFormat: gl.RGB,
              dataType: gl.UNSIGNED_BYTE,
              isCompressed: false
            };
          case miniprogram$12.TextureFormat.R8G8B8A8:
            return {
              internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
              baseFormat: gl.RGBA,
              dataType: gl.UNSIGNED_BYTE,
              isCompressed: false
            };
          case miniprogram$12.TextureFormat.R4G4B4A4:
            return {
              internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
              baseFormat: gl.RGBA,
              dataType: gl.UNSIGNED_SHORT_4_4_4_4,
              isCompressed: false
            };
          case miniprogram$12.TextureFormat.R5G5B5A1:
            return {
              internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
              baseFormat: gl.RGBA,
              dataType: gl.UNSIGNED_SHORT_5_5_5_1,
              isCompressed: false
            };
          case miniprogram$12.TextureFormat.R5G6B5:
            return {
              internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
              baseFormat: gl.RGB,
              dataType: gl.UNSIGNED_SHORT_5_6_5,
              isCompressed: false
            };
          case miniprogram$12.TextureFormat.Alpha8:
            return {
              internalFormat: gl.ALPHA,
              baseFormat: gl.ALPHA,
              dataType: gl.UNSIGNED_BYTE,
              isCompressed: false
            };
          case miniprogram$12.TextureFormat.LuminanceAlpha:
            return {
              internalFormat: gl.LUMINANCE_ALPHA,
              baseFormat: gl.LUMINANCE_ALPHA,
              dataType: gl.UNSIGNED_BYTE,
              isCompressed: false
            };
          case miniprogram$12.TextureFormat.R16G16B16A16:
            return {
              internalFormat: gl.RGBA16F,
              baseFormat: gl.RGBA,
              dataType: gl.HALF_FLOAT,
              isCompressed: false
            };
          case miniprogram$12.TextureFormat.R32G32B32A32:
            return {
              internalFormat: gl.RGBA32F,
              baseFormat: gl.RGBA,
              dataType: gl.FLOAT,
              isCompressed: false
            };
          case miniprogram$12.TextureFormat.DXT1:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
              isCompressed: true
            };
          case miniprogram$12.TextureFormat.DXT5:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT,
              isCompressed: true
            };
          case miniprogram$12.TextureFormat.ETC1_RGB:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
              isCompressed: true
            };
          case miniprogram$12.TextureFormat.ETC2_RGB:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGB8_ETC2,
              isCompressed: true
            };
          case miniprogram$12.TextureFormat.ETC2_RGBA5:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
              isCompressed: true
            };
          case miniprogram$12.TextureFormat.ETC2_RGBA8:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC,
              isCompressed: true
            };
          case miniprogram$12.TextureFormat.PVRTC_RGB2:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG,
              isCompressed: true
            };
          case miniprogram$12.TextureFormat.PVRTC_RGBA2:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
              isCompressed: true
            };
          case miniprogram$12.TextureFormat.PVRTC_RGB4:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
              isCompressed: true
            };
          case miniprogram$12.TextureFormat.PVRTC_RGBA4:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG,
              isCompressed: true
            };
          case miniprogram$12.TextureFormat.ASTC_4x4:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
              isCompressed: true
            };
          case miniprogram$12.TextureFormat.ASTC_5x5:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR,
              isCompressed: true
            };
          case miniprogram$12.TextureFormat.ASTC_6x6:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR,
              isCompressed: true
            };
          case miniprogram$12.TextureFormat.ASTC_8x8:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR,
              isCompressed: true
            };
          case miniprogram$12.TextureFormat.ASTC_10x10:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR,
              isCompressed: true
            };
          case miniprogram$12.TextureFormat.ASTC_12x12:
            return {
              internalFormat: exports3.GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
              isCompressed: true
            };
          default:
            throw new Error("this TextureFormat is not supported in Oasis Engine: " + format);
        }
      };
      GLTexture2._getRenderBufferDepthFormatDetail = function _getRenderBufferDepthFormatDetail(format, gl, isWebGL2) {
        switch (format) {
          case miniprogram$12.TextureFormat.Depth:
          case miniprogram$12.RenderBufferDepthFormat.Depth:
            return {
              internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16,
              baseFormat: gl.DEPTH_COMPONENT,
              dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_INT,
              isCompressed: false,
              attachment: gl.DEPTH_ATTACHMENT
            };
          case miniprogram$12.TextureFormat.DepthStencil:
          case miniprogram$12.RenderBufferDepthFormat.DepthStencil:
            return {
              internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
              baseFormat: gl.DEPTH_STENCIL,
              dataType: gl.UNSIGNED_INT_24_8,
              isCompressed: false,
              attachment: gl.DEPTH_STENCIL_ATTACHMENT
            };
          case miniprogram$12.TextureFormat.Stencil:
          case miniprogram$12.RenderBufferDepthFormat.Stencil:
            return {
              internalFormat: gl.STENCIL_INDEX8,
              baseFormat: gl.STENCIL_ATTACHMENT,
              dataType: gl.UNSIGNED_BYTE,
              isCompressed: false,
              attachment: gl.STENCIL_ATTACHMENT
            };
          case miniprogram$12.TextureFormat.Depth16:
          case miniprogram$12.RenderBufferDepthFormat.Depth16:
            return {
              internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT16,
              baseFormat: gl.DEPTH_COMPONENT,
              dataType: gl.UNSIGNED_INT,
              isCompressed: false,
              attachment: gl.DEPTH_ATTACHMENT
            };
          case miniprogram$12.TextureFormat.Depth24:
          case miniprogram$12.RenderBufferDepthFormat.Depth24:
            return {
              internalFormat: gl.DEPTH_COMPONENT24,
              baseFormat: gl.DEPTH_COMPONENT,
              dataType: gl.UNSIGNED_INT,
              isCompressed: false,
              attachment: gl.DEPTH_ATTACHMENT
            };
          case miniprogram$12.TextureFormat.Depth32:
          case miniprogram$12.RenderBufferDepthFormat.Depth32:
            return {
              internalFormat: gl.DEPTH_COMPONENT32F,
              baseFormat: gl.DEPTH_COMPONENT,
              dataType: gl.FLOAT,
              isCompressed: false,
              attachment: gl.DEPTH_ATTACHMENT
            };
          case miniprogram$12.TextureFormat.Depth24Stencil8:
          case miniprogram$12.RenderBufferDepthFormat.Depth24Stencil8:
            return {
              internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
              baseFormat: gl.DEPTH_STENCIL,
              dataType: gl.UNSIGNED_INT_24_8,
              isCompressed: false,
              attachment: gl.DEPTH_STENCIL_ATTACHMENT
            };
          case miniprogram$12.TextureFormat.Depth32Stencil8:
          case miniprogram$12.RenderBufferDepthFormat.Depth32Stencil8:
            return {
              internalFormat: gl.DEPTH32F_STENCIL8,
              baseFormat: gl.DEPTH_STENCIL,
              dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,
              isCompressed: false,
              attachment: gl.DEPTH_STENCIL_ATTACHMENT
            };
          default:
            throw new Error("this TextureFormat is not supported in Oasis Engine: " + format);
        }
      };
      GLTexture2._supportTextureFormat = function _supportTextureFormat(format, rhi) {
        var isSupported = true;
        switch (format) {
          case miniprogram$12.TextureFormat.R16G16B16A16:
            {
              if (!rhi.canIUse(miniprogram$12.GLCapabilityType.textureHalfFloat)) {
                isSupported = false;
              }
            }
            break;
          case miniprogram$12.TextureFormat.R32G32B32A32:
            {
              if (!rhi.canIUse(miniprogram$12.GLCapabilityType.textureFloat)) {
                isSupported = false;
              }
            }
            break;
        }
        return isSupported;
      };
      GLTexture2._supportRenderBufferColorFormat = function _supportRenderBufferColorFormat(format, rhi) {
        var isSupported = true;
        switch (format) {
          case miniprogram$12.TextureFormat.R16G16B16A16:
            {
              if (!rhi.canIUse(miniprogram$12.GLCapabilityType.colorBufferHalfFloat) || !rhi.canIUse(miniprogram$12.GLCapabilityType.textureHalfFloat)) {
                isSupported = false;
              }
            }
            break;
          case miniprogram$12.TextureFormat.R32G32B32A32:
            {
              if (!rhi.canIUse(miniprogram$12.GLCapabilityType.colorBufferFloat) || !rhi.canIUse(miniprogram$12.GLCapabilityType.textureFloat)) {
                isSupported = false;
              }
            }
            break;
        }
        return isSupported;
      };
      GLTexture2._supportRenderBufferDepthFormat = function _supportRenderBufferDepthFormat(format, rhi, isTexture) {
        var isWebGL2 = rhi.isWebGL2;
        var isSupported = true;
        if (isTexture && !rhi.canIUse(miniprogram$12.GLCapabilityType.depthTexture)) {
          return false;
        }
        switch (format) {
          case miniprogram$12.RenderBufferDepthFormat.Stencil:
          case miniprogram$12.TextureFormat.Stencil:
            isSupported = false;
            break;
          case miniprogram$12.TextureFormat.Depth24:
          case miniprogram$12.TextureFormat.Depth32:
          case miniprogram$12.TextureFormat.Depth32Stencil8:
          case miniprogram$12.RenderBufferDepthFormat.Depth24:
          case miniprogram$12.RenderBufferDepthFormat.Depth32:
          case miniprogram$12.RenderBufferDepthFormat.Depth32Stencil8:
            if (!isWebGL2) {
              isSupported = false;
            }
            break;
        }
        return isSupported;
      };
      function GLTexture2(rhi, texture, target) {
        this._texture = void 0;
        this._glTexture = void 0;
        this._rhi = void 0;
        this._gl = void 0;
        this._isWebGL2 = void 0;
        this._target = void 0;
        this._formatDetail = void 0;
        this._texture = texture;
        this._rhi = rhi;
        this._gl = rhi.gl;
        this._isWebGL2 = rhi.isWebGL2;
        this._target = target;
        this._glTexture = this._gl.createTexture();
      }
      var _proto = GLTexture2.prototype;
      _proto.destroy = function destroy() {
        this._gl.deleteTexture(this._glTexture);
        this._texture = null;
        this._glTexture = null;
        this._formatDetail = null;
      };
      _proto.generateMipmaps = function generateMipmaps() {
        this._bind();
        this._gl.generateMipmap(this._target);
      };
      _proto._bind = function _bind() {
        this._rhi.bindTexture(this);
      };
      _proto._initMipmap = function _initMipmap(isCube) {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var _this$_formatDetail = this._formatDetail, internalFormat = _this$_formatDetail.internalFormat, baseFormat = _this$_formatDetail.baseFormat, dataType = _this$_formatDetail.dataType;
        var _this$_texture = this._texture, mipmapCount = _this$_texture.mipmapCount, width = _this$_texture.width, height = _this$_texture.height;
        this._bind();
        if (isWebGL2 && !(baseFormat === gl.LUMINANCE_ALPHA || baseFormat === gl.ALPHA)) {
          gl.texStorage2D(this._target, mipmapCount, internalFormat, width, height);
        } else {
          if (baseFormat !== internalFormat) {
            internalFormat = baseFormat;
          }
          if (!isCube) {
            for (var i = 0; i < mipmapCount; i++) {
              var mipWidth = Math.max(1, width >> i);
              var mipHeight = Math.max(1, height >> i);
              gl.texImage2D(this._target, i, internalFormat, mipWidth, mipHeight, 0, baseFormat, dataType, null);
            }
          } else {
            for (var _i = 0; _i < mipmapCount; _i++) {
              var size = Math.max(1, width >> _i);
              for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, _i, internalFormat, size, size, 0, baseFormat, dataType, null);
              }
            }
          }
        }
      };
      _proto._getPixelBuffer = function _getPixelBuffer(face, x, y, width, height, mipLevel, out) {
        var gl = this._gl;
        var _this$_formatDetail2 = this._formatDetail, baseFormat = _this$_formatDetail2.baseFormat, dataType = _this$_formatDetail2.dataType;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._getReadFrameBuffer());
        if (mipLevel > 0 && !this._isWebGL2) {
          mipLevel = 0;
          miniprogram$12.Logger.error("mipLevel only take effect in WebGL2.0");
        }
        if (face != null) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, this._glTexture, mipLevel);
        } else {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, mipLevel);
        }
        gl.readPixels(x, y, width, height, baseFormat, dataType, out);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      };
      _proto._setWrapMode = function _setWrapMode(value, pname) {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var target = this._target;
        var _this$_texture2 = this._texture, width = _this$_texture2.width, height = _this$_texture2.height;
        if (!isWebGL2 && value !== miniprogram$12.TextureWrapMode.Clamp && (!GLTexture2._isPowerOf2(width) || !GLTexture2._isPowerOf2(height))) {
          miniprogram$12.Logger.warn("non-power-2 texture is not supported for REPEAT or MIRRORED_REPEAT in WebGL1,and has automatically downgraded to CLAMP_TO_EDGE");
          value = miniprogram$12.TextureWrapMode.Clamp;
        }
        switch (value) {
          case miniprogram$12.TextureWrapMode.Clamp:
            gl.texParameteri(target, pname, gl.CLAMP_TO_EDGE);
            break;
          case miniprogram$12.TextureWrapMode.Repeat:
            gl.texParameteri(target, pname, gl.REPEAT);
            break;
          case miniprogram$12.TextureWrapMode.Mirror:
            gl.texParameteri(target, pname, gl.MIRRORED_REPEAT);
            break;
        }
      };
      _proto._getReadFrameBuffer = function _getReadFrameBuffer() {
        var frameBuffer = this._rhi._readFrameBuffer;
        if (!frameBuffer) {
          this._rhi._readFrameBuffer = frameBuffer = this._gl.createFramebuffer();
        }
        return frameBuffer;
      };
      _createClass2(GLTexture2, [{
        key: "wrapModeU",
        set: function set(value) {
          this._bind();
          this._setWrapMode(value, this._gl.TEXTURE_WRAP_S);
        }
      }, {
        key: "wrapModeV",
        set: function set(value) {
          this._bind();
          this._setWrapMode(value, this._gl.TEXTURE_WRAP_T);
        }
      }, {
        key: "filterMode",
        set: function set(value) {
          var gl = this._gl;
          var target = this._target;
          var _mipmap = this._texture._mipmap;
          this._bind();
          switch (value) {
            case miniprogram$12.TextureFilterMode.Point:
              gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
              gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);
              break;
            case miniprogram$12.TextureFilterMode.Bilinear:
              gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
              gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR);
              break;
            case miniprogram$12.TextureFilterMode.Trilinear:
              gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
              gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
              break;
          }
        }
      }, {
        key: "anisoLevel",
        set: function set(value) {
          var gl = this._gl;
          this._bind();
          gl.texParameterf(this._target, gl.TEXTURE_MAX_ANISOTROPY_EXT, value);
        }
      }]);
      return GLTexture2;
    }();
    var GLRenderTarget = /* @__PURE__ */ function() {
      function GLRenderTarget2(rhi, target) {
        this._gl = void 0;
        this._isWebGL2 = void 0;
        this._target = void 0;
        this._frameBuffer = void 0;
        this._MSAAFrameBuffer = void 0;
        this._depthRenderBuffer = void 0;
        this._MSAAColorRenderBuffers = [];
        this._MSAADepthRenderBuffer = void 0;
        this._oriDrawBuffers = void 0;
        this._blitDrawBuffers = void 0;
        this._curMipLevel = 0;
        this._gl = rhi.gl;
        this._isWebGL2 = rhi.isWebGL2;
        this._target = target;
        var _colorTextures = target._colorTextures, _depth = target._depth, width = target.width, height = target.height;
        var isDepthTexture = _depth instanceof miniprogram$12.Texture;
        for (var i = 0, n = _colorTextures.length; i < n; i++) {
          var format = _colorTextures[i]._format;
          if (!GLTexture._supportRenderBufferColorFormat(format, rhi)) {
            throw new Error("TextureFormat is not supported:" + miniprogram$12.TextureFormat[format] + " in RenderTarget");
          }
        }
        if (!GLTexture._supportRenderBufferDepthFormat(isDepthTexture ? _depth.format : _depth, rhi, isDepthTexture)) {
          throw new Error("TextureFormat is not supported:" + miniprogram$12.TextureFormat[_depth] + " in RenderTarget");
        }
        if (_colorTextures.length > 1 && !rhi.canIUse(miniprogram$12.GLCapabilityType.drawBuffers)) {
          throw new Error("MRT is not supported");
        }
        if (_colorTextures.some(function(v) {
          return v.width !== width || v.height !== height;
        })) {
          throw new Error("ColorTexture's size must as same as RenderTarget");
        }
        if (isDepthTexture && (_depth.width !== width || _depth.height !== height)) {
          throw new Error("DepthTexture's size must as same as RenderTarget");
        }
        if (_colorTextures.length > 1 && _colorTextures.some(function(v) {
          return v instanceof miniprogram$12.TextureCube;
        })) {
          throw new Error("MRT+Cube+[,MSAA] is not supported");
        }
        var maxAntiAliasing = rhi.capability.maxAntiAliasing;
        if (target.antiAliasing > maxAntiAliasing) {
          miniprogram$12.Logger.warn("MSAA antiAliasing exceeds the limit and is automatically downgraded to:" + maxAntiAliasing);
          target._antiAliasing = maxAntiAliasing;
        }
        this._frameBuffer = this._gl.createFramebuffer();
        this._bindMainFBO();
        if (target.antiAliasing > 1) {
          this._MSAAFrameBuffer = this._gl.createFramebuffer();
          this._bindMSAAFBO();
        }
      }
      var _proto = GLRenderTarget2.prototype;
      _proto.setRenderTargetInfo = function setRenderTargetInfo(faceIndex, mipLevel) {
        var gl = this._gl, target = this._target;
        var depthTexture = target.depthTexture;
        var colorTexture = target.getColorTexture(0);
        var mipChanged = mipLevel !== this._curMipLevel;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        if (colorTexture) {
          var isCube = colorTexture instanceof miniprogram$12.TextureCube;
          if (mipChanged || isCube) {
            gl.framebufferTexture2D(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0,
              isCube ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D,
              colorTexture._platformTexture._glTexture,
              mipLevel
            );
          }
        }
        if (depthTexture) {
          var _isCube = depthTexture instanceof miniprogram$12.TextureCube;
          if (mipChanged || _isCube) {
            var platformTexture = depthTexture._platformTexture;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, platformTexture._formatDetail.attachment, _isCube ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D, platformTexture._glTexture, mipLevel);
          }
        } else {
          if (mipChanged) {
            var _GLTexture$_getRender = GLTexture._getRenderBufferDepthFormatDetail(target._depth, gl, this._isWebGL2), internalFormat = _GLTexture$_getRender.internalFormat;
            gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthRenderBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, target.width >> mipLevel, target.height >> mipLevel);
          }
        }
        this._curMipLevel = mipLevel;
        this._activeRenderTarget();
      };
      _proto.blitRenderTarget = function blitRenderTarget() {
        if (!this._MSAAFrameBuffer)
          return;
        var gl = this._gl;
        var mask = gl.COLOR_BUFFER_BIT | (this._target.depthTexture ? gl.DEPTH_BUFFER_BIT : 0);
        var _this$_target = this._target, colorTextureCount = _this$_target.colorTextureCount, width = _this$_target.width, height = _this$_target.height;
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._MSAAFrameBuffer);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);
        for (var textureIndex = 0; textureIndex < colorTextureCount; textureIndex++) {
          var attachment = gl.COLOR_ATTACHMENT0 + textureIndex;
          this._blitDrawBuffers[textureIndex] = attachment;
          gl.readBuffer(attachment);
          gl.drawBuffers(this._blitDrawBuffers);
          gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);
          this._blitDrawBuffers[textureIndex] = gl.NONE;
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      };
      _proto.destroy = function destroy() {
        var gl = this._gl;
        this._frameBuffer && gl.deleteFramebuffer(this._frameBuffer);
        this._depthRenderBuffer && gl.deleteRenderbuffer(this._depthRenderBuffer);
        this._MSAAFrameBuffer && gl.deleteFramebuffer(this._MSAAFrameBuffer);
        this._MSAADepthRenderBuffer && gl.deleteRenderbuffer(this._MSAADepthRenderBuffer);
        for (var i = 0; i < this._MSAAColorRenderBuffers.length; i++) {
          gl.deleteRenderbuffer(this._MSAAColorRenderBuffers[i]);
        }
        this._frameBuffer = null;
        this._depthRenderBuffer = null;
        this._MSAAFrameBuffer = null;
        this._MSAAColorRenderBuffers.length = 0;
        this._MSAADepthRenderBuffer = null;
      };
      _proto._activeRenderTarget = function _activeRenderTarget() {
        var gl = this._gl;
        if (this._MSAAFrameBuffer) {
          gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
        } else {
          gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        }
      };
      _proto._bindMainFBO = function _bindMainFBO() {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var _this$_target2 = this._target, _depth = _this$_target2._depth, colorTextureCount = _this$_target2.colorTextureCount, width = _this$_target2.width, height = _this$_target2.height;
        var drawBuffers = new Array(colorTextureCount);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        for (var i = 0; i < colorTextureCount; i++) {
          var colorTexture = this._target.getColorTexture(i);
          var attachment = gl.COLOR_ATTACHMENT0 + i;
          drawBuffers[i] = attachment;
          if (!(colorTexture instanceof miniprogram$12.TextureCube)) {
            gl.framebufferTexture2D(
              gl.FRAMEBUFFER,
              attachment,
              gl.TEXTURE_2D,
              colorTexture._platformTexture._glTexture,
              0
            );
          }
        }
        if (colorTextureCount > 1) {
          gl.drawBuffers(drawBuffers);
        }
        this._oriDrawBuffers = drawBuffers;
        if (_depth !== null) {
          if (_depth instanceof miniprogram$12.Texture) {
            if (!(_depth instanceof miniprogram$12.TextureCube)) {
              gl.framebufferTexture2D(
                gl.FRAMEBUFFER,
                _depth._platformTexture._formatDetail.attachment,
                gl.TEXTURE_2D,
                _depth._platformTexture._glTexture,
                0
              );
            }
          } else if (this._target.antiAliasing <= 1) {
            var _GLTexture$_getRender2 = GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2), internalFormat = _GLTexture$_getRender2.internalFormat, _attachment = _GLTexture$_getRender2.attachment;
            var depthRenderBuffer = gl.createRenderbuffer();
            this._depthRenderBuffer = depthRenderBuffer;
            gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, _attachment, gl.RENDERBUFFER, depthRenderBuffer);
          }
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      };
      _proto._bindMSAAFBO = function _bindMSAAFBO() {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var MSAADepthRenderBuffer = gl.createRenderbuffer();
        var _this$_target3 = this._target, _depth = _this$_target3._depth, colorTextureCount = _this$_target3.colorTextureCount, antiAliasing = _this$_target3.antiAliasing, width = _this$_target3.width, height = _this$_target3.height;
        this._blitDrawBuffers = new Array(colorTextureCount);
        this._MSAADepthRenderBuffer = MSAADepthRenderBuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
        for (var i = 0; i < colorTextureCount; i++) {
          var MSAAColorRenderBuffer = gl.createRenderbuffer();
          this._MSAAColorRenderBuffers[i] = MSAAColorRenderBuffer;
          this._blitDrawBuffers[i] = gl.NONE;
          gl.bindRenderbuffer(gl.RENDERBUFFER, MSAAColorRenderBuffer);
          gl.renderbufferStorageMultisample(
            gl.RENDERBUFFER,
            antiAliasing,
            this._target.getColorTexture(i)._platformTexture._formatDetail.internalFormat,
            width,
            height
          );
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, MSAAColorRenderBuffer);
        }
        gl.drawBuffers(this._oriDrawBuffers);
        if (_depth !== null) {
          var _ref = _depth instanceof miniprogram$12.Texture ? _depth._platformTexture._formatDetail : GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2), internalFormat = _ref.internalFormat, attachment = _ref.attachment;
          gl.bindRenderbuffer(gl.RENDERBUFFER, MSAADepthRenderBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing, internalFormat, width, height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, MSAADepthRenderBuffer);
        }
        this._checkFrameBuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      };
      _proto._checkFrameBuffer = function _checkFrameBuffer() {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        switch (e) {
          case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete");
          case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            throw new Error("There is no attachment");
          case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw new Error(" Height and width of the attachment are not the same.");
          case gl.FRAMEBUFFER_UNSUPPORTED:
            throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer");
        }
        if (isWebGL2 && e === gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
          throw new Error("The values of gl.RENDERBUFFER_SAMPLES are different among attached renderbuffers, or are non-zero if the attached images are a mix of renderbuffers and textures.");
        }
      };
      return GLRenderTarget2;
    }();
    var GLTexture2D = /* @__PURE__ */ function(_GLTexture) {
      _inheritsLoose2(GLTexture2D2, _GLTexture);
      function GLTexture2D2(rhi, texture2D) {
        var _this;
        _this = _GLTexture.call(this, rhi, texture2D, rhi.gl.TEXTURE_2D) || this;
        _this._compressedMipFilled = 0;
        var format = texture2D.format, _mipmap = texture2D._mipmap, width = texture2D.width, height = texture2D.height;
        var isWebGL2 = _this._isWebGL2;
        if (!GLTexture._supportTextureFormat(format, rhi)) {
          throw new Error("Texture format is not supported:" + miniprogram$12.TextureFormat[format]);
        }
        if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
          miniprogram$12.Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
          texture2D._mipmap = false;
          texture2D._mipmapCount = texture2D._getMipmapCount();
        }
        _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, isWebGL2);
        _this._formatDetail.isCompressed && !isWebGL2 || _this._initMipmap(false);
        return _this;
      }
      var _proto = GLTexture2D2.prototype;
      _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
        if (mipLevel === void 0) {
          mipLevel = 0;
        }
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var _this$_formatDetail = this._formatDetail, internalFormat = _this$_formatDetail.internalFormat, baseFormat = _this$_formatDetail.baseFormat, dataType = _this$_formatDetail.dataType, isCompressed = _this$_formatDetail.isCompressed;
        var mipWidth = Math.max(1, this._texture.width >> mipLevel);
        var mipHeight = Math.max(1, this._texture.height >> mipLevel);
        width = width || mipWidth - x;
        height = height || mipHeight - y;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        if (isCompressed) {
          var mipBit = 1 << mipLevel;
          if (isWebGL2 || this._compressedMipFilled & mipBit) {
            gl.compressedTexSubImage2D(this._target, mipLevel, x, y, width, height, internalFormat, colorBuffer);
          } else {
            gl.compressedTexImage2D(this._target, mipLevel, internalFormat, width, height, 0, colorBuffer);
            this._compressedMipFilled |= mipBit;
          }
        } else {
          gl.texSubImage2D(this._target, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
        }
      };
      _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        var gl = this._gl;
        var _this$_formatDetail2 = this._formatDetail, baseFormat = _this$_formatDetail2.baseFormat, dataType = _this$_formatDetail2.dataType;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
        gl.texSubImage2D(this._target, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
      };
      _proto.getPixelBuffer = function getPixelBuffer(x, y, width, height, mipLevel, out) {
        if (this._formatDetail.isCompressed) {
          throw new Error("Unable to read compressed texture");
        }
        _GLTexture.prototype._getPixelBuffer.call(this, null, x, y, width, height, mipLevel, out);
      };
      return GLTexture2D2;
    }(GLTexture);
    var GLTexture2DArray = /* @__PURE__ */ function(_GLTexture) {
      _inheritsLoose2(GLTexture2DArray2, _GLTexture);
      function GLTexture2DArray2(rhi, texture2DArray) {
        var _this;
        _this = _GLTexture.call(this, rhi, texture2DArray, rhi.gl.TEXTURE_2D_ARRAY) || this;
        var format = texture2DArray.format, width = texture2DArray.width, height = texture2DArray.height, length2 = texture2DArray.length, mipmapCount = texture2DArray.mipmapCount;
        if (!_this._isWebGL2) {
          throw new Error("Texture2D Array is not supported in WebGL1.0");
        }
        if (!GLTexture._supportTextureFormat(format, rhi)) {
          throw new Error("Texture format is not supported:" + miniprogram$12.TextureFormat[format]);
        }
        _this._bind();
        _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, true);
        _this._gl.texStorage3D(_this._target, mipmapCount, _this._formatDetail.internalFormat, width, height, length2);
        return _this;
      }
      var _proto = GLTexture2DArray2.prototype;
      _proto.setPixelBuffer = function setPixelBuffer(offsetIndex, colorBuffer, mipLevel, x, y, width, height, length2) {
        var target = this._target, gl = this._gl;
        var _this$_formatDetail = this._formatDetail, internalFormat = _this$_formatDetail.internalFormat, baseFormat = _this$_formatDetail.baseFormat, dataType = _this$_formatDetail.dataType, isCompressed = _this$_formatDetail.isCompressed;
        width = width || Math.max(1, this._texture.width >> mipLevel) - x;
        height = height || Math.max(1, this._texture.height >> mipLevel) - y;
        length2 = length2 || this._texture.length;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        if (isCompressed) {
          gl.compressedTexSubImage3D(target, mipLevel, x, y, offsetIndex, width, height, length2, internalFormat, colorBuffer);
        } else {
          gl.texSubImage3D(target, mipLevel, x, y, offsetIndex, width, height, length2, baseFormat, dataType, colorBuffer);
        }
      };
      _proto.setImageSource = function setImageSource(elementIndex, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        var gl = this._gl;
        var _this$_formatDetail2 = this._formatDetail, baseFormat = _this$_formatDetail2.baseFormat, dataType = _this$_formatDetail2.dataType;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
        gl.texSubImage3D(this._target, mipLevel, x, y, elementIndex, imageSource.width, imageSource.height, 1, baseFormat, dataType, imageSource);
      };
      _proto.getPixelBuffer = function getPixelBuffer(elementIndex, x, y, width, height, mipLevel, out) {
        var gl = this._gl, formatDetail = this._formatDetail;
        if (formatDetail.isCompressed) {
          throw new Error("Unable to read compressed texture");
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._getReadFrameBuffer());
        gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, this._glTexture, mipLevel, elementIndex);
        gl.readPixels(x, y, width, height, formatDetail.baseFormat, formatDetail.dataType, out);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      };
      return GLTexture2DArray2;
    }(GLTexture);
    var GLTextureCube = /* @__PURE__ */ function(_GLTexture) {
      _inheritsLoose2(GLTextureCube2, _GLTexture);
      function GLTextureCube2(rhi, textureCube) {
        var _this;
        _this = _GLTexture.call(this, rhi, textureCube, rhi.gl.TEXTURE_CUBE_MAP) || this;
        _this._compressedFaceFilled = [0, 0, 0, 0, 0, 0];
        var format = textureCube.format, _mipmap = textureCube._mipmap, size = textureCube.width;
        var isWebGL2 = _this._isWebGL2;
        if (!GLTexture._supportTextureFormat(format, rhi)) {
          throw new Error("Texture format is not supported:" + miniprogram$12.TextureFormat[format]);
        }
        if (_mipmap && !isWebGL2 && !GLTexture._isPowerOf2(size)) {
          miniprogram$12.Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
          textureCube._mipmap = false;
          textureCube._mipmapCount = textureCube._getMipmapCount();
        }
        _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, isWebGL2);
        _this._formatDetail.isCompressed && !isWebGL2 || _this._initMipmap(true);
        return _this;
      }
      var _proto = GLTextureCube2.prototype;
      _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var _this$_formatDetail = this._formatDetail, internalFormat = _this$_formatDetail.internalFormat, baseFormat = _this$_formatDetail.baseFormat, dataType = _this$_formatDetail.dataType, isCompressed = _this$_formatDetail.isCompressed;
        var mipSize = Math.max(1, this._texture.width >> mipLevel);
        width = width || mipSize - x;
        height = height || mipSize - y;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        if (isCompressed) {
          var mipBit = 1 << mipLevel;
          if (isWebGL2 || this._compressedFaceFilled[face] & mipBit) {
            gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, internalFormat, colorBuffer);
          } else {
            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, internalFormat, width, height, 0, colorBuffer);
            this._compressedFaceFilled[face] |= mipBit;
          }
        } else {
          gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
        }
      };
      _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        var gl = this._gl;
        var _this$_formatDetail2 = this._formatDetail, baseFormat = _this$_formatDetail2.baseFormat, dataType = _this$_formatDetail2.dataType;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
      };
      _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, mipLevel, out) {
        if (this._formatDetail.isCompressed) {
          throw new Error("Unable to read compressed texture");
        }
        _GLTexture.prototype._getPixelBuffer.call(this, face, x, y, width, height, mipLevel, out);
      };
      return GLTextureCube2;
    }(GLTexture);
    exports3.WebGLMode = void 0;
    (function(WebGLMode) {
      WebGLMode[WebGLMode["Auto"] = 0] = "Auto";
      WebGLMode[WebGLMode["WebGL2"] = 1] = "WebGL2";
      WebGLMode[WebGLMode["WebGL1"] = 2] = "WebGL1";
    })(exports3.WebGLMode || (exports3.WebGLMode = {}));
    var WebGLRenderer = /* @__PURE__ */ function() {
      function WebGLRenderer2(options) {
        if (options === void 0) {
          options = {};
        }
        this._readFrameBuffer = void 0;
        this._currentBind = void 0;
        this._options = void 0;
        this._gl = void 0;
        this._renderStates = void 0;
        this._extensions = void 0;
        this._capability = void 0;
        this._isWebGL2 = void 0;
        this._webCanvas = void 0;
        this._activeTextureID = void 0;
        this._activeTextures = new Array(32);
        this._lastViewport = new miniprogram2.Vector4(null, null, null, null);
        this._lastClearColor = new miniprogram2.Color(null, null, null, null);
        this._scissorEnable = false;
        this._options = options;
      }
      var _proto = WebGLRenderer2.prototype;
      _proto.init = function init(canvas) {
        var option = this._options;
        option.alpha === void 0 && (option.alpha = false);
        option.stencil === void 0 && (option.stencil = true);
        var webCanvas = this._webCanvas = canvas._webCanvas;
        var webGLMode = option.webGLMode || exports3.WebGLMode.Auto;
        var gl;
        if (webGLMode == exports3.WebGLMode.Auto || webGLMode == exports3.WebGLMode.WebGL2) {
          gl = webCanvas.getContext("webgl2", option);
          if (!gl && (typeof miniprogramAdapter2.OffscreenCanvas === "undefined" || !(webCanvas instanceof miniprogramAdapter2.OffscreenCanvas))) {
            gl = webCanvas.getContext("experimental-webgl2", option);
          }
          this._isWebGL2 = true;
          if (gl && !gl.deleteQuery) {
            this._isWebGL2 = false;
          }
        }
        if (!gl) {
          if (webGLMode == exports3.WebGLMode.Auto || webGLMode == exports3.WebGLMode.WebGL1) {
            gl = webCanvas.getContext("webgl", option);
            if (!gl && (typeof miniprogramAdapter2.OffscreenCanvas === "undefined" || !(webCanvas instanceof miniprogramAdapter2.OffscreenCanvas))) {
              gl = webCanvas.getContext("experimental-webgl", option);
            }
            this._isWebGL2 = false;
          }
        }
        if (!gl) {
          throw new Error("Get GL Context FAILED.");
        }
        this._gl = gl;
        this._activeTextureID = gl.TEXTURE0;
        this._renderStates = new GLRenderStates(gl);
        this._extensions = new GLExtensions(this);
        this._capability = new GLCapability(this);
        gl.activeTexture(gl.TEXTURE0);
        this._options = null;
      };
      _proto.createPlatformPrimitive = function createPlatformPrimitive(primitive) {
        return new GLPrimitive(this, primitive);
      };
      _proto.createPlatformTexture2D = function createPlatformTexture2D(texture2D) {
        return new GLTexture2D(this, texture2D);
      };
      _proto.createPlatformTexture2DArray = function createPlatformTexture2DArray(texture2D) {
        return new GLTexture2DArray(this, texture2D);
      };
      _proto.createPlatformTextureCube = function createPlatformTextureCube(textureCube) {
        return new GLTextureCube(this, textureCube);
      };
      _proto.createPlatformRenderTarget = function createPlatformRenderTarget(target) {
        return new GLRenderTarget(this, target);
      };
      _proto.requireExtension = function requireExtension(ext) {
        return this._extensions.requireExtension(ext);
      };
      _proto.canIUse = function canIUse(capabilityType) {
        return this.capability.canIUse(capabilityType);
      };
      _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(type) {
        return this.capability.canIUseCompressedTextureInternalFormat(type);
      };
      _proto.viewport = function viewport(x, y, width, height) {
        var gl = this._gl, lv = this._lastViewport;
        if (x !== lv.x || y !== lv.y || width !== lv.z || height !== lv.w) {
          var webCanvas = this._webCanvas;
          if (x === 0 && y === 0 && width === webCanvas.width && height === webCanvas.height) {
            if (this._scissorEnable) {
              gl.disable(gl.SCISSOR_TEST);
              this._scissorEnable = false;
            }
          } else {
            if (!this._scissorEnable) {
              gl.enable(gl.SCISSOR_TEST);
              this._scissorEnable = true;
            }
            gl.scissor(x, y, width, height);
          }
          gl.viewport(x, y, width, height);
          lv.set(x, y, width, height);
        }
      };
      _proto.colorMask = function colorMask(r, g, b, a) {
        this._gl.colorMask(r, g, b, a);
      };
      _proto.clearRenderTarget = function clearRenderTarget(engine, clearFlags, clearColor) {
        var gl = this._gl;
        var _engine$_lastRenderSt = engine._lastRenderState, targetBlendState = _engine$_lastRenderSt.blendState.targetBlendState, depthState = _engine$_lastRenderSt.depthState, stencilState = _engine$_lastRenderSt.stencilState;
        var clearFlag = 0;
        if (clearFlags & miniprogram$12.CameraClearFlags.Color) {
          clearFlag |= gl.COLOR_BUFFER_BIT;
          var lc = this._lastClearColor;
          var r = clearColor.r, g = clearColor.g, b = clearColor.b, a = clearColor.a;
          if (clearColor && (r !== lc.r || g !== lc.g || b !== lc.b || a !== lc.a)) {
            gl.clearColor(r, g, b, a);
            lc.set(r, g, b, a);
          }
          if (targetBlendState.colorWriteMask !== miniprogram$12.ColorWriteMask.All) {
            gl.colorMask(true, true, true, true);
            targetBlendState.colorWriteMask = miniprogram$12.ColorWriteMask.All;
          }
        }
        if (clearFlags & miniprogram$12.CameraClearFlags.Depth) {
          clearFlag |= gl.DEPTH_BUFFER_BIT;
          if (depthState.writeEnabled !== true) {
            gl.depthMask(true);
            depthState.writeEnabled = true;
          }
        }
        if (clearFlags & miniprogram$12.CameraClearFlags.Stencil) {
          clearFlag |= gl.STENCIL_BUFFER_BIT;
          if (stencilState.writeMask !== 255) {
            gl.stencilMask(255);
            stencilState.writeMask = 255;
          }
        }
        gl.clear(clearFlag);
      };
      _proto.drawPrimitive = function drawPrimitive(primitive, subPrimitive, shaderProgram) {
        if (primitive) {
          primitive._draw(shaderProgram, subPrimitive);
        } else {
          miniprogram$12.Logger.error("draw primitive failed.");
        }
      };
      _proto.activeRenderTarget = function activeRenderTarget(renderTarget, camera, mipLevel) {
        var gl = this._gl;
        if (renderTarget) {
          var _renderTarget$_platfo;
          (_renderTarget$_platfo = renderTarget._platformRenderTarget) === null || _renderTarget$_platfo === void 0 ? void 0 : _renderTarget$_platfo._activeRenderTarget();
          var width = renderTarget.width, height = renderTarget.height;
          this.viewport(0, 0, width >> mipLevel, height >> mipLevel);
        } else {
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          var viewport = camera.viewport;
          var drawingBufferWidth = gl.drawingBufferWidth, drawingBufferHeight = gl.drawingBufferHeight;
          var _width = drawingBufferWidth * viewport.z;
          var _height = drawingBufferHeight * viewport.w;
          var x = viewport.x * drawingBufferWidth;
          var y = drawingBufferHeight - viewport.y * drawingBufferHeight - _height;
          this.viewport(x, y, _width, _height);
        }
      };
      _proto.destroy = function destroy() {
      };
      _proto.activeTexture = function activeTexture(textureID) {
        if (this._activeTextureID !== textureID) {
          this._gl.activeTexture(textureID);
          this._activeTextureID = textureID;
        }
      };
      _proto.bindTexture = function bindTexture(texture) {
        var index = this._activeTextureID - this._gl.TEXTURE0;
        if (this._activeTextures[index] !== texture) {
          this._gl.bindTexture(texture._target, texture._glTexture);
          this._activeTextures[index] = texture;
        }
      };
      _createClass2(WebGLRenderer2, [{
        key: "isWebGL2",
        get: function get() {
          return this._isWebGL2;
        }
      }, {
        key: "gl",
        get: function get() {
          return this._gl;
        }
      }, {
        key: "renderStates",
        get: function get() {
          return this._renderStates;
        }
      }, {
        key: "capability",
        get: function get() {
          return this._capability;
        }
      }, {
        key: "canIUseMoreJoints",
        get: function get() {
          return this.capability.canIUseMoreJoints;
        }
      }]);
      return WebGLRenderer2;
    }();
    var WebGLEngine = /* @__PURE__ */ function(_Engine) {
      _inheritsLoose2(WebGLEngine2, _Engine);
      function WebGLEngine2(canvas, webGLRendererOptions) {
        var webCanvas = new WebCanvas(typeof canvas === "string" ? miniprogramAdapter2.document.getElementById(canvas) : canvas);
        var hardwareRenderer = new WebGLRenderer(webGLRendererOptions);
        return _Engine.call(this, webCanvas, hardwareRenderer) || this;
      }
      _createClass2(WebGLEngine2, [{
        key: "canvas",
        get: function get() {
          return this._canvas;
        }
      }]);
      return WebGLEngine2;
    }(miniprogram$12.Engine);
    exports3.WebCanvas = WebCanvas;
    exports3.WebGLEngine = WebGLEngine;
    exports3.WebGLRenderer = WebGLRenderer;
  })(miniprogram$6);
  var miniprogram$5 = {};
  Object.defineProperty(miniprogram$5, "__esModule", { value: true });
  var miniprogramAdapter$1 = require$$0__default.default;
  var miniprogram$4 = miniprogram$9;
  function _defineProperties$3(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass$3(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties$3(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties$3(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  var DRACOWorker = /* @__PURE__ */ function() {
    function DRACOWorker2(workerSourceURL, decoderWASMBinary) {
      var _this = this;
      this._worker = void 0;
      this._costs = {};
      this._currentLoad = 0;
      this._callbacks = {};
      this._worker = new Worker(workerSourceURL);
      this._worker.onmessage = function(e) {
        var message = e.data;
        switch (message.type) {
          case "decode":
            _this._callbacks[message.id].resolve(message.geometry);
            break;
          case "error":
            _this._callbacks[message.id].reject(message);
            break;
          default:
            miniprogram$4.Logger.error('DRACOWorker: Unexpected message, "' + message.type + '"');
        }
      };
      if (decoderWASMBinary) {
        this._worker.postMessage({
          type: "init",
          decoderConfig: {
            wasmBinary: decoderWASMBinary
          }
        });
      } else {
        this._worker.postMessage({
          type: "init",
          decoderConfig: {}
        });
      }
    }
    var _proto = DRACOWorker2.prototype;
    _proto.setCosts = function setCosts(taskId, cost) {
      this._costs[taskId] = cost;
    };
    _proto.addCurrentLoad = function addCurrentLoad(cost) {
      this._currentLoad += cost;
    };
    _proto.setCallback = function setCallback(taskId, resolve, reject) {
      this._callbacks[taskId] = {
        resolve,
        reject
      };
    };
    _proto.decode = function decode2(taskId, taskConfig, buffer) {
      this._worker.postMessage({
        type: "decode",
        id: taskId,
        taskConfig,
        buffer
      }, [buffer]);
    };
    _proto.releaseTask = function releaseTask(taskId) {
      this._currentLoad -= this._costs[taskId];
      delete this._callbacks[taskId];
      delete this._costs[taskId];
    };
    _createClass$3(DRACOWorker2, [{
      key: "currentLoad",
      get: function get() {
        return this._currentLoad;
      }
    }]);
    return DRACOWorker2;
  }();
  var workerString = 'let decoderPending;\nlet decoderConfig;\n\nonmessage = function(e) {\n  const message = e.data;\n\n  switch (message.type) {\n    case "init":\n      decoderConfig = message.decoderConfig;\n      decoderPending = new Promise(function(resolve /*, reject*/) {\n        decoderConfig.onModuleLoaded = function(draco) {\n          // Module is Promise-like. Wrap before resolving to avoid loop.\n          resolve({ draco: draco });\n        };\n        DracoDecoderModule(decoderConfig);\n      });\n      break;\n\n    case "decode":\n      const buffer = message.buffer;\n      const taskConfig = message.taskConfig;\n      decoderPending.then(module => {\n        const draco = module.draco;\n        const decoder = new draco.Decoder();\n        const decoderBuffer = new draco.DecoderBuffer();\n        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n        try {\n          const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n          const buffers = geometry.attributes.map(attr => attr.array.buffer);\n          if (geometry.index) buffers.push(geometry.index.array.buffer);\n          self.postMessage({ type: "decode", id: message.id, geometry }, buffers);\n        } catch (error) {\n          console.error(error);\n          self.postMessage({ type: "error", id: message.id, error: error.message });\n        } finally {\n          draco.destroy(decoderBuffer);\n          draco.destroy(decoder);\n        }\n      });\n      break;\n  }\n};\n\nfunction decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n  const attributeIDs = taskConfig.attributeIDs;\n  const attributeTypes = taskConfig.attributeTypes;\n\n  let dracoGeometry;\n  let decodingStatus;\n\n  const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    dracoGeometry = new draco.Mesh();\n    decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n  } else {\n    throw new Error("DRACODecoder worker: Unexpected geometry type.");\n  }\n\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new Error("DRACODecoder worker: Decoding failed: " + decodingStatus.error_msg());\n  }\n\n  const geometry = { index: null, attributes: [] };\n\n  // Gather all vertex attributes.\n  for (let attributeName in attributeIDs) {\n    const attributeType = self[attributeTypes[attributeName]];\n\n    let attribute;\n    let attributeID;\n\n    // A Draco file may be created with default vertex attributes, whose attribute IDs\n    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n    // a Draco file may contain a custom set of attributes, identified by known unique\n    // IDs. glTF files always do the latter, and .drc files typically do the former.\n    if (taskConfig.useUniqueIDs) {\n      attributeID = attributeIDs[attributeName];\n      attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n    } else {\n      attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n      if (attributeID === -1) continue;\n      attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n    }\n    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n  }\n  // Add index.\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    // Generate mesh faces.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    let dataSize;\n    let ptr;\n    let index;\n    const indexType = self[taskConfig.indexType];\n\n    switch (indexType) {\n      case Uint16Array:\n        dataSize = numIndices * 2;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt16Array(dracoGeometry, dataSize, ptr);\n        index = new Uint16Array(draco.HEAPU16.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      case Uint32Array:\n        dataSize = numIndices * 4;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, dataSize, ptr);\n        index = new Uint32Array(draco.HEAPU32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      default:\n        throw new Error("DRACODecoder: Unexpected index type.");\n    }\n    geometry.index = { array: index, itemSize: 1 };\n  }\n  draco.destroy(dracoGeometry);\n  return geometry;\n}\n\nfunction decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n  const numComponents = attribute.num_components();\n  const numPoints = dracoGeometry.num_points();\n  const numValues = numPoints * numComponents;\n  let ptr;\n  let array;\n  let dataSize;\n  switch (attributeType) {\n    case Float32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr);\n      array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT8, numValues, ptr);\n      array = new Int8Array(draco.HEAP8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr);\n      array = new Int16Array(draco.HEAP16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr);\n      array = new Int32Array(draco.HEAP32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr);\n      array = new Uint8Array(draco.HEAPU8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr);\n      array = new Uint16Array(draco.HEAPU16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr);\n      array = new Uint32Array(draco.HEAPU32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    default:\n      throw new Error("DRACODecoder: Unexpected attribute type.");\n  }\n\n  return {\n    name: attributeName,\n    array: array,\n    itemSize: numComponents\n  };\n}\n';
  var LIB_PATH = "https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/";
  var JS_FILE = "draco_decoder_gltf.js";
  var WASM_FILE = "draco_decoder_gltf.r3bin";
  var WASM_WRAPPER_FILE = "draco_wasm_wrapper_gltf.js";
  var DRACODecoder = /* @__PURE__ */ function() {
    function DRACODecoder2(config) {
      if (config === void 0) {
        config = {
          type: "wasm",
          workerLimit: 4
        };
      }
      this.pool = [];
      this.workerLimit = Math.min(miniprogramAdapter$1.navigator.hardwareConcurrency || 4, 4);
      this.useJS = void 0;
      this.currentTaskId = 1;
      this.taskCache = /* @__PURE__ */ new WeakMap();
      this.loadLibPromise = void 0;
      if (config.workerLimit > this.workerLimit) {
        miniprogram$4.Logger.warn("DRACOWorkerPool: Can not initialize worker pool with limit:" + config.workerLimit);
      } else {
        var _config$workerLimit;
        this.workerLimit = (_config$workerLimit = config.workerLimit) != null ? _config$workerLimit : 4;
      }
      this.useJS = typeof WebAssembly !== "object" || config.type === "js";
      this.loadLibPromise = this.preloadLib();
    }
    var _proto = DRACODecoder2.prototype;
    _proto.preloadLib = function preloadLib() {
      var _this = this;
      if (this.loadLibPromise) {
        return this.loadLibPromise;
      }
      return new Promise(function(resolve, reject) {
        if (_this.useJS) {
          miniprogram$4.request("" + LIB_PATH + JS_FILE, {
            type: "text"
          }).then(function(jsSource) {
            var body = [jsSource, workerString].join("\n");
            var workerSourceURL = miniprogramAdapter$1.URL.createObjectURL(new miniprogramAdapter$1.Blob([body]));
            resolve({
              workerSourceURL,
              decoderWASMBinary: null
            });
          }).catch(function(reason) {
            reject(reason);
          });
        } else {
          Promise.all([miniprogram$4.request("" + LIB_PATH + WASM_WRAPPER_FILE, {
            type: "text"
          }), miniprogram$4.request("" + LIB_PATH + WASM_FILE, {
            type: "arraybuffer"
          })]).then(function(resources) {
            var wrapperSource = resources[0], decoderWASMBinary = resources[1];
            var body = [wrapperSource, workerString].join("\n");
            var workerSourceURL = miniprogramAdapter$1.URL.createObjectURL(new miniprogramAdapter$1.Blob([body]));
            resolve({
              workerSourceURL,
              decoderWASMBinary
            });
          }).catch(function(reason) {
            reject(reason);
          });
        }
      });
    };
    _proto.getWorker = function getWorker() {
      var _this2 = this;
      return this.preloadLib().then(function(worderResources) {
        if (_this2.pool.length < _this2.workerLimit) {
          var dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);
          _this2.pool.push(dracoWorker);
        } else {
          _this2.pool.sort(function(a, b) {
            return a.currentLoad > b.currentLoad ? -1 : 1;
          });
        }
        return _this2.pool[_this2.pool.length - 1];
      });
    };
    _proto.decode = function decode2(buffer, taskConfig) {
      var _this3 = this;
      var taskKey = JSON.stringify(taskConfig);
      if (this.taskCache.has(buffer)) {
        var cachedTask = this.taskCache.get(buffer);
        if (cachedTask.key === taskKey) {
          return cachedTask.promise;
        } else if (buffer.byteLength === 0) {
          throw new Error("DRACODecoder: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
        }
      }
      var taskId = this.currentTaskId++;
      var cost = buffer.byteLength;
      var taskWorker;
      var task = new Promise(function(resolve, reject) {
        _this3.getWorker().then(function(worker) {
          taskWorker = worker;
          worker.setCosts(taskId, cost);
          worker.addCurrentLoad(cost);
          worker.setCallback(taskId, resolve, reject);
          worker.decode(taskId, taskConfig, buffer);
        }).catch(function(e) {
          reject(e);
        });
      });
      task.finally(function() {
        if (taskWorker && taskId) {
          taskWorker.releaseTask(taskId);
        }
      });
      this.taskCache.set(buffer, {
        key: taskKey,
        promise: task
      });
      return task;
    };
    return DRACODecoder2;
  }();
  miniprogram$5.DRACODecoder = DRACODecoder;
  Object.defineProperty(miniprogram$7, "__esModule", { value: true });
  var miniprogramAdapter = require$$0__default.default;
  var miniprogram = miniprogram$9;
  var miniprogram$1 = miniprogram$8;
  var miniprogram$2 = miniprogram$6;
  var miniprogram$3 = miniprogram$5;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _regeneratorRuntime() {
    _regeneratorRuntime = function() {
      return exports3;
    };
    var exports3 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
      obj[key] = desc.value;
    }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define2(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      }), obj[key];
    }
    try {
      define2({}, "");
    } catch (err) {
      define2 = function(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
      return defineProperty(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self2, context)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports3.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    define2(IteratorPrototype, iteratorSymbol, function() {
      return this;
    });
    var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define2(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg, value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
            invoke("next", value2, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function(error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", {
        value: function(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self2, context) {
      var state = "suspendedStart";
      return function(method, arg) {
        if ("executing" === state)
          throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method)
            throw arg;
          return doneResult();
        }
        for (context.method = method, context.arg = arg; ; ) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if ("next" === context.method)
            context.sent = context._sent = context.arg;
          else if ("throw" === context.method) {
            if ("suspendedStart" === state)
              throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else
            "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self2, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
              continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (void 0 === method) {
        if (context.delegate = null, "throw" === context.method) {
          if (delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method))
            return ContinueSentinel;
          context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type)
        return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod)
          return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next)
          return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1, next = function next2() {
            for (; ++i < iterable.length; )
              if (hasOwn.call(iterable, i))
                return next2.value = iterable[i], next2.done = false, next2;
            return next2.value = void 0, next2.done = true, next2;
          };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: void 0,
        done: true
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: true
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: true
    }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports3.isGeneratorFunction = function(genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports3.mark = function(genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports3.awrap = function(arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    }), exports3.AsyncIterator = AsyncIterator, exports3.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
      return exports3.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
      return this;
    }), define2(Gp, "toString", function() {
      return "[object Generator]";
    }), exports3.keys = function(val) {
      var object = Object(val), keys = [];
      for (var key in object)
        keys.push(key);
      return keys.reverse(), function next() {
        for (; keys.length; ) {
          var key2 = keys.pop();
          if (key2 in object)
            return next.value = key2, next.done = false, next;
        }
        return next.done = true, next;
      };
    }, exports3.values = values, Context.prototype = {
      constructor: Context,
      reset: function(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
          for (var name in this)
            "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
      },
      stop: function() {
        this.done = true;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type)
          throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function(exception) {
        if (this.done)
          throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i], record = entry.completion;
          if ("root" === entry.tryLoc)
            return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
            } else {
              if (!hasFinally)
                throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function(record, afterLoc) {
        if ("throw" === record.type)
          throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc)
            return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
      }
    }, exports3;
  }
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  function _defineProperties$2(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass$2(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties$2(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties$2(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inheritsLoose$2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$2(subClass, superClass);
  }
  function _setPrototypeOf$2(o, p) {
    _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf$2(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a = [null];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a);
        var instance = new Constructor();
        if (Class2)
          _setPrototypeOf$2(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it)
      return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      return function() {
        if (i >= o.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var _dec$r, _class$r;
  function isBase64(url) {
    return /^data:(.+?);base64,/.test(url);
  }
  _dec$r = miniprogram.resourceLoader(miniprogram.AssetType.Buffer, ["bin", "r3bin"], false), _dec$r(_class$r = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(BufferLoader, _Loader);
    function BufferLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = BufferLoader.prototype;
    _proto.load = function load(item) {
      var url = item.url;
      if (isBase64(url)) {
        return new miniprogram.AssetPromise(function(resolve) {
          var base64Str = url.slice(13 + RegExp.$1.length);
          var result = Uint8Array.from(miniprogramAdapter.atob(base64Str), function(c) {
            return c.charCodeAt(0);
          });
          resolve(result.buffer);
        });
      }
      return this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "arraybuffer"
      }));
    };
    return BufferLoader;
  }(miniprogram.Loader)) || _class$r;
  var AccessorComponentType;
  (function(AccessorComponentType2) {
    AccessorComponentType2[AccessorComponentType2["BYTE"] = 5120] = "BYTE";
    AccessorComponentType2[AccessorComponentType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    AccessorComponentType2[AccessorComponentType2["SHORT"] = 5122] = "SHORT";
    AccessorComponentType2[AccessorComponentType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    AccessorComponentType2[AccessorComponentType2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    AccessorComponentType2[AccessorComponentType2["FLOAT"] = 5126] = "FLOAT";
  })(AccessorComponentType || (AccessorComponentType = {}));
  var AccessorType;
  (function(AccessorType2) {
    AccessorType2["SCALAR"] = "SCALAR";
    AccessorType2["VEC2"] = "VEC2";
    AccessorType2["VEC3"] = "VEC3";
    AccessorType2["VEC4"] = "VEC4";
    AccessorType2["MAT2"] = "MAT2";
    AccessorType2["MAT3"] = "MAT3";
    AccessorType2["MAT4"] = "MAT4";
  })(AccessorType || (AccessorType = {}));
  var AnimationChannelTargetPath;
  (function(AnimationChannelTargetPath2) {
    AnimationChannelTargetPath2["TRANSLATION"] = "translation";
    AnimationChannelTargetPath2["ROTATION"] = "rotation";
    AnimationChannelTargetPath2["SCALE"] = "scale";
    AnimationChannelTargetPath2["WEIGHTS"] = "weights";
  })(AnimationChannelTargetPath || (AnimationChannelTargetPath = {}));
  var AnimationSamplerInterpolation;
  (function(AnimationSamplerInterpolation2) {
    AnimationSamplerInterpolation2["Linear"] = "LINEAR";
    AnimationSamplerInterpolation2["Step"] = "STEP";
    AnimationSamplerInterpolation2["CubicSpine"] = "CUBICSPLINE";
  })(AnimationSamplerInterpolation || (AnimationSamplerInterpolation = {}));
  var CameraType;
  (function(CameraType2) {
    CameraType2["PERSPECTIVE"] = "perspective";
    CameraType2["ORTHOGRAPHIC"] = "orthographic";
  })(CameraType || (CameraType = {}));
  var ImageMimeType;
  (function(ImageMimeType2) {
    ImageMimeType2["JPEG"] = "image/jpeg";
    ImageMimeType2["PNG"] = "image/png";
  })(ImageMimeType || (ImageMimeType = {}));
  var MaterialAlphaMode;
  (function(MaterialAlphaMode2) {
    MaterialAlphaMode2["OPAQUE"] = "OPAQUE";
    MaterialAlphaMode2["MASK"] = "MASK";
    MaterialAlphaMode2["BLEND"] = "BLEND";
  })(MaterialAlphaMode || (MaterialAlphaMode = {}));
  var TextureMagFilter;
  (function(TextureMagFilter2) {
    TextureMagFilter2[TextureMagFilter2["NEAREST"] = 9728] = "NEAREST";
    TextureMagFilter2[TextureMagFilter2["LINEAR"] = 9729] = "LINEAR";
  })(TextureMagFilter || (TextureMagFilter = {}));
  var TextureMinFilter;
  (function(TextureMinFilter2) {
    TextureMinFilter2[TextureMinFilter2["NEAREST"] = 9728] = "NEAREST";
    TextureMinFilter2[TextureMinFilter2["LINEAR"] = 9729] = "LINEAR";
    TextureMinFilter2[TextureMinFilter2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    TextureMinFilter2[TextureMinFilter2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    TextureMinFilter2[TextureMinFilter2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    TextureMinFilter2[TextureMinFilter2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
  })(TextureMinFilter || (TextureMinFilter = {}));
  var TextureWrapMode;
  (function(TextureWrapMode2) {
    TextureWrapMode2[TextureWrapMode2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    TextureWrapMode2[TextureWrapMode2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    TextureWrapMode2[TextureWrapMode2["REPEAT"] = 10497] = "REPEAT";
  })(TextureWrapMode || (TextureWrapMode = {}));
  var GLTFUtil = /* @__PURE__ */ function() {
    function GLTFUtil2() {
    }
    GLTFUtil2.floatBufferToVector2Array = function floatBufferToVector2Array(buffer) {
      var bufferLen = buffer.length;
      var array = new Array(bufferLen / 2);
      for (var i = 0; i < bufferLen; i += 2) {
        array[i / 2] = new miniprogram$1.Vector2(buffer[i], buffer[i + 1]);
      }
      return array;
    };
    GLTFUtil2.floatBufferToVector3Array = function floatBufferToVector3Array(buffer) {
      var bufferLen = buffer.length;
      var array = new Array(bufferLen / 3);
      for (var i = 0; i < bufferLen; i += 3) {
        array[i / 3] = new miniprogram$1.Vector3(buffer[i], buffer[i + 1], buffer[i + 2]);
      }
      return array;
    };
    GLTFUtil2.floatBufferToVector4Array = function floatBufferToVector4Array(buffer) {
      var bufferLen = buffer.length;
      var array = new Array(bufferLen / 4);
      for (var i = 0; i < bufferLen; i += 4) {
        array[i / 4] = new miniprogram$1.Vector4(buffer[i], buffer[i + 1], buffer[i + 2], buffer[i + 3]);
      }
      return array;
    };
    GLTFUtil2.floatBufferToColorArray = function floatBufferToColorArray(buffer, isColor3) {
      var bufferLen = buffer.length;
      var colors = new Array(bufferLen / (isColor3 ? 3 : 4));
      if (isColor3) {
        for (var i = 0; i < bufferLen; i += 3) {
          colors[i / 3] = new miniprogram$1.Color(buffer[i], buffer[i + 1], buffer[i + 2], 1);
        }
      } else {
        for (var _i = 0; _i < bufferLen; _i += 4) {
          colors[_i / 4] = new miniprogram$1.Color(buffer[_i], buffer[_i + 1], buffer[_i + 2], buffer[_i + 3]);
        }
      }
      return colors;
    };
    GLTFUtil2.decodeText = function decodeText(array) {
      if (typeof TextDecoder !== "undefined") {
        return new TextDecoder().decode(array);
      }
      var s = "";
      for (var i = 0, il = array.length; i < il; i++) {
        s += String.fromCharCode(array[i]);
      }
      return decodeURIComponent(encodeURIComponent(s));
    };
    GLTFUtil2.getAccessorTypeSize = function getAccessorTypeSize(accessorType) {
      switch (accessorType) {
        case AccessorType.SCALAR:
          return 1;
        case AccessorType.VEC2:
          return 2;
        case AccessorType.VEC3:
          return 3;
        case AccessorType.VEC4:
          return 4;
        case AccessorType.MAT2:
          return 4;
        case AccessorType.MAT3:
          return 9;
        case AccessorType.MAT4:
          return 16;
      }
    };
    GLTFUtil2.getComponentType = function getComponentType(componentType) {
      switch (componentType) {
        case AccessorComponentType.BYTE:
          return Int8Array;
        case AccessorComponentType.UNSIGNED_BYTE:
          return Uint8Array;
        case AccessorComponentType.SHORT:
          return Int16Array;
        case AccessorComponentType.UNSIGNED_SHORT:
          return Uint16Array;
        case AccessorComponentType.UNSIGNED_INT:
          return Uint32Array;
        case AccessorComponentType.FLOAT:
          return Float32Array;
      }
    };
    GLTFUtil2.getAccessorData = function getAccessorData(gltf, accessor, buffers) {
      var _bufferView$byteStrid;
      var bufferViews = gltf.bufferViews;
      var bufferView = bufferViews[accessor.bufferView];
      var arrayBuffer = buffers[bufferView.buffer];
      var accessorByteOffset = accessor.hasOwnProperty("byteOffset") ? accessor.byteOffset : 0;
      var bufferViewByteOffset = bufferView.hasOwnProperty("byteOffset") ? bufferView.byteOffset : 0;
      var byteOffset = accessorByteOffset + bufferViewByteOffset;
      var accessorTypeSize = GLTFUtil2.getAccessorTypeSize(accessor.type);
      var length2 = accessorTypeSize * accessor.count;
      var byteStride = (_bufferView$byteStrid = bufferView.byteStride) != null ? _bufferView$byteStrid : 0;
      var arrayType = GLTFUtil2.getComponentType(accessor.componentType);
      var uint8Array;
      if (byteStride) {
        var accessorByteSize = accessorTypeSize * arrayType.BYTES_PER_ELEMENT;
        uint8Array = new Uint8Array(accessor.count * accessorByteSize);
        var originalBufferView = new Uint8Array(arrayBuffer, bufferViewByteOffset, bufferView.byteLength);
        for (var i = 0; i < accessor.count; i++) {
          for (var j = 0; j < accessorByteSize; j++) {
            uint8Array[i * accessorByteSize + j] = originalBufferView[i * byteStride + accessorByteOffset + j];
          }
        }
      } else {
        uint8Array = new Uint8Array(arrayBuffer.slice(byteOffset, byteOffset + length2 * arrayType.BYTES_PER_ELEMENT));
      }
      var typedArray = new arrayType(uint8Array.buffer);
      if (accessor.sparse) {
        var _indices$byteOffset, _indicesBufferView$by, _values$byteOffset, _valuesBufferView$byt;
        var _accessor$sparse = accessor.sparse, count = _accessor$sparse.count, indices = _accessor$sparse.indices, values = _accessor$sparse.values;
        var indicesBufferView = bufferViews[indices.bufferView];
        var valuesBufferView = bufferViews[values.bufferView];
        var indicesArrayBuffer = buffers[indicesBufferView.buffer];
        var valuesArrayBuffer = buffers[valuesBufferView.buffer];
        var indicesByteOffset = ((_indices$byteOffset = indices.byteOffset) != null ? _indices$byteOffset : 0) + ((_indicesBufferView$by = indicesBufferView.byteOffset) != null ? _indicesBufferView$by : 0);
        var indicesByteLength = indicesBufferView.byteLength;
        var valuesByteOffset = ((_values$byteOffset = values.byteOffset) != null ? _values$byteOffset : 0) + ((_valuesBufferView$byt = valuesBufferView.byteOffset) != null ? _valuesBufferView$byt : 0);
        var valuesByteLength = valuesBufferView.byteLength;
        var indicesType = GLTFUtil2.getComponentType(indices.componentType);
        var indicesArray = new indicesType(indicesArrayBuffer, indicesByteOffset, indicesByteLength / indicesType.BYTES_PER_ELEMENT);
        var valuesArray = new arrayType(valuesArrayBuffer, valuesByteOffset, valuesByteLength / arrayType.BYTES_PER_ELEMENT);
        for (var _i2 = 0; _i2 < count; _i2++) {
          var replaceIndex = indicesArray[_i2];
          for (var _j = 0; _j < accessorTypeSize; _j++) {
            typedArray[replaceIndex * accessorTypeSize + _j] = valuesArray[_i2 * accessorTypeSize + _j];
          }
        }
      }
      return typedArray;
    };
    GLTFUtil2.getBufferViewData = function getBufferViewData(bufferView, buffers) {
      var buffer = bufferView.buffer, _bufferView$byteOffse = bufferView.byteOffset, byteOffset = _bufferView$byteOffse === void 0 ? 0 : _bufferView$byteOffse, byteLength = bufferView.byteLength;
      var arrayBuffer = buffers[buffer];
      return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
    };
    GLTFUtil2.getVertexStride = function getVertexStride(gltf, accessor) {
      var _accessor$bufferView;
      var stride = gltf.bufferViews[(_accessor$bufferView = accessor.bufferView) != null ? _accessor$bufferView : 0].byteStride;
      if (stride) {
        return stride;
      }
      var size = GLTFUtil2.getAccessorTypeSize(accessor.type);
      var componentType = GLTFUtil2.getComponentType(accessor.componentType);
      return size * componentType.BYTES_PER_ELEMENT;
    };
    GLTFUtil2.createVertexElement = function createVertexElement(semantic, accessor, index) {
      var size = GLTFUtil2.getAccessorTypeSize(accessor.type);
      return new miniprogram.VertexElement(semantic, 0, GLTFUtil2.getElementFormat(accessor.componentType, size, accessor.normalized), index);
    };
    GLTFUtil2.getIndexFormat = function getIndexFormat(type) {
      switch (type) {
        case AccessorComponentType.UNSIGNED_BYTE:
          return miniprogram.IndexFormat.UInt8;
        case AccessorComponentType.UNSIGNED_SHORT:
          return miniprogram.IndexFormat.UInt16;
        case AccessorComponentType.UNSIGNED_INT:
          return miniprogram.IndexFormat.UInt32;
      }
    };
    GLTFUtil2.getElementFormat = function getElementFormat(type, size, normalized) {
      if (normalized === void 0) {
        normalized = false;
      }
      if (type == AccessorComponentType.FLOAT) {
        switch (size) {
          case 1:
            return miniprogram.VertexElementFormat.Float;
          case 2:
            return miniprogram.VertexElementFormat.Vector2;
          case 3:
            return miniprogram.VertexElementFormat.Vector3;
          case 4:
            return miniprogram.VertexElementFormat.Vector4;
        }
      }
      if (type == AccessorComponentType.SHORT) {
        switch (size) {
          case 2:
            return normalized ? miniprogram.VertexElementFormat.NormalizedShort2 : miniprogram.VertexElementFormat.Short2;
          case 3:
          case 4:
            return normalized ? miniprogram.VertexElementFormat.NormalizedShort4 : miniprogram.VertexElementFormat.Short4;
        }
      }
      if (type == AccessorComponentType.UNSIGNED_SHORT) {
        switch (size) {
          case 2:
            return normalized ? miniprogram.VertexElementFormat.NormalizedUShort2 : miniprogram.VertexElementFormat.UShort2;
          case 3:
          case 4:
            return normalized ? miniprogram.VertexElementFormat.NormalizedUShort4 : miniprogram.VertexElementFormat.UShort4;
        }
      }
      if (type == AccessorComponentType.BYTE) {
        switch (size) {
          case 2:
          case 3:
          case 4:
            return normalized ? miniprogram.VertexElementFormat.NormalizedByte4 : miniprogram.VertexElementFormat.Byte4;
        }
      }
      if (type == AccessorComponentType.UNSIGNED_BYTE) {
        switch (size) {
          case 2:
          case 3:
          case 4:
            return normalized ? miniprogram.VertexElementFormat.NormalizedUByte4 : miniprogram.VertexElementFormat.UByte4;
        }
      }
    };
    GLTFUtil2.loadImageBuffer = function loadImageBuffer(imageBuffer, type) {
      return new Promise(function(resolve, reject) {
        var blob = new miniprogramAdapter.window.Blob([imageBuffer], {
          type
        });
        var img = new miniprogramAdapter.Image();
        img.onerror = function() {
          reject(new Error("Failed to load image buffer"));
        };
        img.onload = function() {
          miniprogramAdapter.requestAnimationFrame(function() {
            resolve(img);
            img.onload = null;
            img.onerror = null;
            img.onabort = null;
          });
        };
        img.crossOrigin = "anonymous";
        img.src = miniprogramAdapter.URL.createObjectURL(blob);
      });
    };
    GLTFUtil2.isAbsoluteUrl = function isAbsoluteUrl(url) {
      return /^(?:http|blob|data:|\/)/.test(url);
    };
    GLTFUtil2.parseRelativeUrl = function parseRelativeUrl(baseUrl, relativeUrl) {
      if (GLTFUtil2.isAbsoluteUrl(relativeUrl)) {
        return relativeUrl;
      }
      var char0 = relativeUrl.charAt(0);
      if (char0 === ".") {
        return GLTFUtil2._formatRelativePath(relativeUrl + relativeUrl);
      }
      return baseUrl.substring(0, baseUrl.lastIndexOf("/") + 1) + relativeUrl;
    };
    GLTFUtil2.parseGLB = function parseGLB(glb) {
      var UINT32_LENGTH = 4;
      var GLB_HEADER_MAGIC = 1179937895;
      var GLB_HEADER_LENGTH = 12;
      var GLB_CHUNK_TYPES = {
        JSON: 1313821514,
        BIN: 5130562
      };
      var dataView = new DataView(glb);
      var header = {
        magic: dataView.getUint32(0, true),
        version: dataView.getUint32(UINT32_LENGTH, true),
        length: dataView.getUint32(2 * UINT32_LENGTH, true)
      };
      if (header.magic !== GLB_HEADER_MAGIC) {
        console.error("Invalid glb magic number. Expected 0x46546C67, found 0x" + header.magic.toString(16));
        return null;
      }
      var chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);
      var chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true);
      if (chunkType !== GLB_CHUNK_TYPES.JSON) {
        console.error("Invalid glb chunk type. Expected 0x4E4F534A, found 0x" + chunkType.toString(16));
        return null;
      }
      var glTFData = new Uint8Array(glb, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);
      var gltf = JSON.parse(GLTFUtil2.decodeText(glTFData));
      var buffers = [];
      var byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;
      while (byteOffset < header.length) {
        chunkLength = dataView.getUint32(byteOffset, true);
        chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);
        if (chunkType !== GLB_CHUNK_TYPES.BIN) {
          console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
          return null;
        }
        var currentOffset = byteOffset + 2 * UINT32_LENGTH;
        var buffer = glb.slice(currentOffset, currentOffset + chunkLength);
        buffers.push(buffer);
        byteOffset += chunkLength + 2 * UINT32_LENGTH;
      }
      return {
        gltf,
        buffers
      };
    };
    GLTFUtil2._formatRelativePath = function _formatRelativePath(value) {
      var parts = value.split("/");
      for (var i = 0, n = parts.length; i < n; i++) {
        if (parts[i] == "..") {
          parts.splice(i - 1, 2);
          i -= 2;
        }
      }
      return parts.join("/");
    };
    return GLTFUtil2;
  }();
  var Parser = /* @__PURE__ */ function() {
    function Parser2() {
    }
    Parser2.parseEngineResource = function parseEngineResource(extensionName, extensionSchema, parseResource, context) {
      var parsers = Parser2._extensionParsers[extensionName];
      if (parsers !== null && parsers !== void 0 && parsers.length) {
        for (var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
          extra[_key - 4] = arguments[_key];
        }
        for (var i = 0; i < parsers.length; i++) {
          var _parsers$i;
          (_parsers$i = parsers[i]).parseEngineResource.apply(_parsers$i, [extensionSchema, parseResource, context].concat(extra));
        }
      }
    };
    Parser2.createEngineResource = function createEngineResource(extensionName, extensionSchema, context) {
      var parsers = Parser2._extensionParsers[extensionName];
      if (parsers !== null && parsers !== void 0 && parsers.length) {
        var _parsers$;
        for (var _len2 = arguments.length, extra = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
          extra[_key2 - 3] = arguments[_key2];
        }
        return (_parsers$ = parsers[0]).createEngineResource.apply(_parsers$, [extensionSchema, context].concat(extra));
      }
    };
    Parser2.hasExtensionParser = function hasExtensionParser(extensionName) {
      var parsers = Parser2._extensionParsers[extensionName];
      return !!(parsers !== null && parsers !== void 0 && parsers.length);
    };
    Parser2.initialize = function initialize(extensionName) {
      var parsers = Parser2._extensionParsers[extensionName];
      if (parsers !== null && parsers !== void 0 && parsers.length) {
        for (var i = 0; i < parsers.length; i++) {
          parsers[i].initialize();
        }
      }
    };
    Parser2._addExtensionParser = function _addExtensionParser(extensionName, extensionParser) {
      if (!Parser2._extensionParsers[extensionName]) {
        Parser2._extensionParsers[extensionName] = [];
      }
      Parser2._extensionParsers[extensionName].push(extensionParser);
    };
    return Parser2;
  }();
  Parser._extensionParsers = {};
  function registerExtension(extensionName) {
    return function(parser) {
      var extensionParser = new parser();
      Parser._addExtensionParser(extensionName, extensionParser);
    };
  }
  var AnimationParser = /* @__PURE__ */ function(_Parser) {
    _inheritsLoose$2(AnimationParser2, _Parser);
    function AnimationParser2() {
      return _Parser.apply(this, arguments) || this;
    }
    var _proto = AnimationParser2.prototype;
    _proto.parse = function parse(context) {
      var gltf = context.gltf, buffers = context.buffers, entities = context.entities;
      var animations = gltf.animations, accessors = gltf.accessors;
      if (!animations) {
        return;
      }
      var animationClipCount = animations.length;
      var animationClips = new Array(animationClipCount);
      var animationsIndices = new Array(animationClipCount);
      for (var i = 0; i < animationClipCount; i++) {
        var gltfAnimation = animations[i];
        var channels = gltfAnimation.channels, samplers = gltfAnimation.samplers, _gltfAnimation$name = gltfAnimation.name, name = _gltfAnimation$name === void 0 ? "AnimationClip" + i : _gltfAnimation$name;
        var animationClip = new miniprogram.AnimationClip(name);
        var sampleDataCollection = new Array();
        for (var _i = 0; _i < samplers.length; _i++) {
          var _gltfSampler$interpol;
          var gltfSampler = samplers[_i];
          var inputAccessor = accessors[gltfSampler.input];
          var outputAccessor = accessors[gltfSampler.output];
          var input = GLTFUtil.getAccessorData(gltf, inputAccessor, buffers);
          var output = GLTFUtil.getAccessorData(gltf, outputAccessor, buffers);
          var outputAccessorSize = output.length / input.length;
          var interpolation = (_gltfSampler$interpol = gltfSampler.interpolation) != null ? _gltfSampler$interpol : AnimationSamplerInterpolation.Linear;
          var samplerInterpolation = void 0;
          switch (interpolation) {
            case AnimationSamplerInterpolation.CubicSpine:
              samplerInterpolation = miniprogram.InterpolationType.CubicSpine;
              break;
            case AnimationSamplerInterpolation.Step:
              samplerInterpolation = miniprogram.InterpolationType.Step;
              break;
            case AnimationSamplerInterpolation.Linear:
              samplerInterpolation = miniprogram.InterpolationType.Linear;
              break;
          }
          input[input.length - 1];
          sampleDataCollection.push({
            type: outputAccessor.type,
            interpolation: samplerInterpolation,
            input,
            output,
            outputSize: outputAccessorSize
          });
        }
        for (var _i2 = 0; _i2 < channels.length; _i2++) {
          var gltfChannel = channels[_i2];
          var target = gltfChannel.target;
          var channelTargetEntity = entities[target.node];
          var relativePath = "";
          var entity = channelTargetEntity;
          while (entity.parent) {
            relativePath = relativePath === "" ? "" + entity.name : entity.name + "/" + relativePath;
            entity = entity.parent;
          }
          var compType = void 0;
          var propertyName = void 0;
          var interpolableValueType = void 0;
          switch (target.path) {
            case AnimationChannelTargetPath.TRANSLATION:
              compType = miniprogram.Transform;
              propertyName = "position";
              interpolableValueType = miniprogram.InterpolableValueType.Vector3;
              break;
            case AnimationChannelTargetPath.ROTATION:
              compType = miniprogram.Transform;
              propertyName = "rotation";
              interpolableValueType = miniprogram.InterpolableValueType.Quaternion;
              break;
            case AnimationChannelTargetPath.SCALE:
              compType = miniprogram.Transform;
              propertyName = "scale";
              interpolableValueType = miniprogram.InterpolableValueType.Vector3;
              break;
            case AnimationChannelTargetPath.WEIGHTS:
              compType = miniprogram.SkinnedMeshRenderer;
              propertyName = "blendShapeWeights";
              interpolableValueType = miniprogram.InterpolableValueType.FloatArray;
              break;
          }
          var curve = this._addCurve(interpolableValueType, gltfChannel, sampleDataCollection);
          animationClip.addCurveBinding(relativePath, compType, propertyName, curve);
        }
        animationClips[i] = animationClip;
        animationsIndices[i] = {
          name,
          index: i
        };
      }
      context.animations = animationClips;
      context._animationsIndices = animationsIndices;
    };
    _proto._addCurve = function _addCurve(interpolableValueType, gltfChannel, sampleDataCollection) {
      var curve = new miniprogram.AnimationCurve();
      var sampleData = sampleDataCollection[gltfChannel.sampler];
      var input = sampleData.input, output = sampleData.output, outputSize = sampleData.outputSize;
      curve.interpolation = sampleData.interpolation;
      for (var j = 0, n = input.length; j < n; j++) {
        var offset = j * outputSize;
        if (interpolableValueType === miniprogram.InterpolableValueType.Float) {
          var keyframe = new miniprogram.InterpolableKeyframe();
          keyframe.time = input[j];
          keyframe.inTangent = 0;
          keyframe.outTangent = 0;
          keyframe.value = output[offset];
          curve.addKey(keyframe);
        } else if (interpolableValueType === miniprogram.InterpolableValueType.FloatArray) {
          var _keyframe = new miniprogram.InterpolableKeyframe();
          _keyframe.time = input[j];
          _keyframe.inTangent = new Float32Array(outputSize);
          _keyframe.outTangent = new Float32Array(outputSize);
          _keyframe.value = output.subarray(offset, offset + outputSize);
          curve.addKey(_keyframe);
        } else if (interpolableValueType === miniprogram.InterpolableValueType.Vector2) {
          var _keyframe2 = new miniprogram.InterpolableKeyframe();
          _keyframe2.time = input[j];
          _keyframe2.value = new miniprogram$1.Vector2(output[offset], output[offset + 1]);
          _keyframe2.inTangent = new miniprogram$1.Vector2();
          _keyframe2.outTangent = new miniprogram$1.Vector2();
          curve.addKey(_keyframe2);
        } else if (interpolableValueType === miniprogram.InterpolableValueType.Vector3) {
          var _keyframe3 = new miniprogram.InterpolableKeyframe();
          _keyframe3.time = input[j];
          _keyframe3.value = new miniprogram$1.Vector3(output[offset], output[offset + 1], output[offset + 2]);
          _keyframe3.inTangent = new miniprogram$1.Vector3();
          _keyframe3.outTangent = new miniprogram$1.Vector3();
          curve.addKey(_keyframe3);
        } else if (interpolableValueType === miniprogram.InterpolableValueType.Vector4) {
          var _keyframe4 = new miniprogram.InterpolableKeyframe();
          _keyframe4.time = input[j];
          _keyframe4.value = new miniprogram$1.Vector4(output[offset], output[offset + 1], output[offset + 2], output[offset + 3]);
          _keyframe4.inTangent = new miniprogram$1.Vector4();
          _keyframe4.outTangent = new miniprogram$1.Vector4();
          curve.addKey(_keyframe4);
        } else if (interpolableValueType === miniprogram.InterpolableValueType.Quaternion) {
          var _keyframe5 = new miniprogram.InterpolableKeyframe();
          _keyframe5.time = input[j];
          _keyframe5.value = new miniprogram$1.Quaternion(output[offset], output[offset + 1], output[offset + 2], output[offset + 3]);
          _keyframe5.inTangent = new miniprogram$1.Vector4();
          _keyframe5.outTangent = new miniprogram$1.Vector4();
          curve.addKey(_keyframe5);
        }
      }
      return curve;
    };
    return AnimationParser2;
  }(Parser);
  var BufferParser = /* @__PURE__ */ function(_Parser) {
    _inheritsLoose$2(BufferParser2, _Parser);
    function BufferParser2() {
      return _Parser.apply(this, arguments) || this;
    }
    var _proto = BufferParser2.prototype;
    _proto.parse = function parse(context) {
      var url = context.url, engine = context.engine;
      if (this._isGLB(url)) {
        return engine.resourceManager.load({
          url,
          type: miniprogram.AssetType.Buffer
        }).then(GLTFUtil.parseGLB).then(function(_ref) {
          var gltf = _ref.gltf, buffers = _ref.buffers;
          context.gltf = gltf;
          context.buffers = buffers;
        });
      } else {
        return engine.resourceManager.load({
          url,
          type: miniprogram.AssetType.JSON
        }).then(function(gltf) {
          context.gltf = gltf;
          return Promise.all(gltf.buffers.map(function(buffer) {
            return engine.resourceManager.load({
              type: miniprogram.AssetType.Buffer,
              url: GLTFUtil.parseRelativeUrl(url, buffer.uri)
            });
          })).then(function(buffers) {
            context.buffers = buffers;
          });
        });
      }
    };
    _proto._isGLB = function _isGLB(url) {
      return url.substring(url.lastIndexOf(".") + 1) === "glb";
    };
    return BufferParser2;
  }(Parser);
  var EntityParser = /* @__PURE__ */ function(_Parser) {
    _inheritsLoose$2(EntityParser2, _Parser);
    function EntityParser2() {
      return _Parser.apply(this, arguments) || this;
    }
    var _proto = EntityParser2.prototype;
    _proto.parse = function parse(context) {
      var engine = context.engine, nodes = context.gltf.nodes;
      if (!nodes)
        return;
      var entities = [];
      for (var i = 0; i < nodes.length; i++) {
        var gltfNode = nodes[i];
        var matrix = gltfNode.matrix, translation = gltfNode.translation, rotation = gltfNode.rotation, scale = gltfNode.scale;
        var entity = new miniprogram.Entity(engine, gltfNode.name || "" + EntityParser2._defaultName + i);
        var _entity = entity, transform = _entity.transform;
        if (matrix) {
          var localMatrix = transform.localMatrix;
          localMatrix.copyFromArray(matrix);
          transform.localMatrix = localMatrix;
        } else {
          if (translation) {
            transform.setPosition(translation[0], translation[1], translation[2]);
          }
          if (rotation) {
            transform.setRotationQuaternion(rotation[0], rotation[1], rotation[2], rotation[3]);
          }
          if (scale) {
            transform.setScale(scale[0], scale[1], scale[2]);
          }
        }
        entities[i] = entity;
      }
      context.entities = entities;
      this._buildEntityTree(context);
      this._createSceneRoots(context);
    };
    _proto._buildEntityTree = function _buildEntityTree(context) {
      var nodes = context.gltf.nodes, entities = context.entities;
      for (var i = 0; i < nodes.length; i++) {
        var children = nodes[i].children;
        var entity = entities[i];
        if (children) {
          for (var j = 0; j < children.length; j++) {
            var childEntity = entities[children[j]];
            entity.addChild(childEntity);
          }
        }
      }
    };
    _proto._createSceneRoots = function _createSceneRoots(context) {
      var engine = context.engine, _context$gltf = context.gltf, _context$gltf$scene = _context$gltf.scene, sceneID = _context$gltf$scene === void 0 ? 0 : _context$gltf$scene, scenes = _context$gltf.scenes, entities = context.entities;
      if (!scenes)
        return;
      var sceneRoots = [];
      for (var i = 0; i < scenes.length; i++) {
        var nodes = scenes[i].nodes;
        if (!nodes)
          continue;
        if (nodes.length === 1) {
          sceneRoots[i] = entities[nodes[0]];
        } else {
          var rootEntity = new miniprogram.Entity(engine, "GLTF_ROOT");
          for (var j = 0; j < nodes.length; j++) {
            rootEntity.addChild(entities[nodes[j]]);
          }
          sceneRoots[i] = rootEntity;
        }
      }
      context.sceneRoots = sceneRoots;
      context.defaultSceneRoot = sceneRoots[sceneID];
    };
    return EntityParser2;
  }(Parser);
  EntityParser._defaultName = "_GLTF_ENTITY_";
  var MaterialParser = /* @__PURE__ */ function(_Parser) {
    _inheritsLoose$2(MaterialParser2, _Parser);
    function MaterialParser2() {
      return _Parser.apply(this, arguments) || this;
    }
    MaterialParser2._parseTextureTransform = function _parseTextureTransform(material, extensions, context) {
      if (extensions === void 0) {
        extensions = {};
      }
      var schema = extensions.KHR_texture_transform;
      if (schema) {
        Parser.parseEngineResource("KHR_texture_transform", schema, material, context);
      }
    };
    var _proto = MaterialParser2.prototype;
    _proto.parse = function parse(context) {
      var gltf = context.gltf, engine = context.engine, textures = context.textures;
      if (!gltf.materials)
        return;
      var materials = [];
      for (var i = 0; i < gltf.materials.length; i++) {
        var _gltf$materials$i = gltf.materials[i], _gltf$materials$i$ext = _gltf$materials$i.extensions, extensions = _gltf$materials$i$ext === void 0 ? {} : _gltf$materials$i$ext, pbrMetallicRoughness = _gltf$materials$i.pbrMetallicRoughness, normalTexture = _gltf$materials$i.normalTexture, occlusionTexture = _gltf$materials$i.occlusionTexture, emissiveTexture = _gltf$materials$i.emissiveTexture, emissiveFactor = _gltf$materials$i.emissiveFactor, alphaMode = _gltf$materials$i.alphaMode, alphaCutoff = _gltf$materials$i.alphaCutoff, doubleSided = _gltf$materials$i.doubleSided, _gltf$materials$i$nam = _gltf$materials$i.name, name = _gltf$materials$i$nam === void 0 ? "" : _gltf$materials$i$nam;
        var KHR_materials_unlit = extensions.KHR_materials_unlit, KHR_materials_pbrSpecularGlossiness = extensions.KHR_materials_pbrSpecularGlossiness, KHR_materials_clearcoat = extensions.KHR_materials_clearcoat, OASIS_materials_remap = extensions.OASIS_materials_remap;
        var material = null;
        if (KHR_materials_unlit) {
          material = Parser.createEngineResource("KHR_materials_unlit", KHR_materials_unlit, context);
        } else if (KHR_materials_pbrSpecularGlossiness) {
          material = Parser.createEngineResource("KHR_materials_pbrSpecularGlossiness", KHR_materials_pbrSpecularGlossiness, context);
        } else {
          material = new miniprogram.PBRMaterial(engine);
        }
        material.name = name;
        if (KHR_materials_clearcoat) {
          Parser.parseEngineResource("KHR_materials_clearcoat", KHR_materials_clearcoat, material, context);
        }
        if (pbrMetallicRoughness) {
          var baseColorFactor = pbrMetallicRoughness.baseColorFactor, baseColorTexture = pbrMetallicRoughness.baseColorTexture, metallicFactor = pbrMetallicRoughness.metallicFactor, roughnessFactor = pbrMetallicRoughness.roughnessFactor, metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;
          if (baseColorFactor) {
            material.baseColor = new miniprogram$1.Color(miniprogram$1.Color.linearToGammaSpace(baseColorFactor[0]), miniprogram$1.Color.linearToGammaSpace(baseColorFactor[1]), miniprogram$1.Color.linearToGammaSpace(baseColorFactor[2]), baseColorFactor[3]);
          }
          if (baseColorTexture) {
            material.baseTexture = textures[baseColorTexture.index];
            MaterialParser2._parseTextureTransform(material, baseColorTexture.extensions, context);
          }
          if (!KHR_materials_unlit && !KHR_materials_pbrSpecularGlossiness) {
            var m = material;
            m.metallic = metallicFactor != null ? metallicFactor : 1;
            m.roughness = roughnessFactor != null ? roughnessFactor : 1;
            if (metallicRoughnessTexture) {
              m.roughnessMetallicTexture = textures[metallicRoughnessTexture.index];
              MaterialParser2._parseTextureTransform(material, metallicRoughnessTexture.extensions, context);
            }
          }
        }
        if (!KHR_materials_unlit) {
          var _m = material;
          if (emissiveTexture) {
            _m.emissiveTexture = textures[emissiveTexture.index];
            MaterialParser2._parseTextureTransform(material, emissiveTexture.extensions, context);
          }
          if (emissiveFactor) {
            _m.emissiveColor = new miniprogram$1.Color(miniprogram$1.Color.linearToGammaSpace(emissiveFactor[0]), miniprogram$1.Color.linearToGammaSpace(emissiveFactor[1]), miniprogram$1.Color.linearToGammaSpace(emissiveFactor[2]));
          }
          if (normalTexture) {
            var index = normalTexture.index, scale = normalTexture.scale;
            _m.normalTexture = textures[index];
            MaterialParser2._parseTextureTransform(material, normalTexture.extensions, context);
            if (scale !== void 0) {
              _m.normalTextureIntensity = scale;
            }
          }
          if (occlusionTexture) {
            var _index = occlusionTexture.index, strength = occlusionTexture.strength, texCoord = occlusionTexture.texCoord;
            _m.occlusionTexture = textures[_index];
            MaterialParser2._parseTextureTransform(material, occlusionTexture.extensions, context);
            if (strength !== void 0) {
              _m.occlusionTextureIntensity = strength;
            }
            if (texCoord === miniprogram.TextureCoordinate.UV1) {
              _m.occlusionTextureCoord = miniprogram.TextureCoordinate.UV1;
            } else if (texCoord > miniprogram.TextureCoordinate.UV1) {
              miniprogram.Logger.warn("Occlusion texture uv coordinate must be UV0 or UV1.");
            }
          }
        }
        if (OASIS_materials_remap) {
          var _context$gltf$extensi, _context$gltf$extensi2;
          context.gltf.extensions = (_context$gltf$extensi = context.gltf.extensions) != null ? _context$gltf$extensi : {};
          context.gltf.extensions["OASIS_materials_remap"] = (_context$gltf$extensi2 = context.gltf.extensions["OASIS_materials_remap"]) != null ? _context$gltf$extensi2 : {};
          context.gltf.extensions["OASIS_materials_remap"][i] = Parser.createEngineResource("OASIS_materials_remap", OASIS_materials_remap, context);
        }
        if (doubleSided) {
          material.renderFace = miniprogram.RenderFace.Double;
        } else {
          material.renderFace = miniprogram.RenderFace.Front;
        }
        switch (alphaMode) {
          case MaterialAlphaMode.OPAQUE:
            material.isTransparent = false;
            break;
          case MaterialAlphaMode.BLEND:
            material.isTransparent = true;
            break;
          case MaterialAlphaMode.MASK:
            material.alphaCutoff = alphaCutoff != null ? alphaCutoff : 0.5;
            break;
        }
        materials[i] = material;
      }
      context.materials = materials;
    };
    return MaterialParser2;
  }(Parser);
  var MeshParser = /* @__PURE__ */ function(_Parser) {
    _inheritsLoose$2(MeshParser2, _Parser);
    function MeshParser2() {
      return _Parser.apply(this, arguments) || this;
    }
    var _proto = MeshParser2.prototype;
    _proto.parse = function parse(context) {
      var _this = this;
      var engine = context.engine, gltf = context.gltf, buffers = context.buffers;
      if (!gltf.meshes)
        return;
      var meshPromises = [];
      var _loop = function _loop2(i2) {
        var gltfMesh = gltf.meshes[i2];
        var primitivePromises = [];
        var _loop22 = function _loop23(j2) {
          var gltfPrimitive = gltfMesh.primitives[j2];
          var _gltfPrimitive$extens = gltfPrimitive.extensions, extensions = _gltfPrimitive$extens === void 0 ? {} : _gltfPrimitive$extens;
          var KHR_draco_mesh_compression = extensions.KHR_draco_mesh_compression;
          primitivePromises.push(new Promise(function(resolve) {
            var mesh = new miniprogram.ModelMesh(engine, gltfMesh.name || j2 + "");
            if (KHR_draco_mesh_compression) {
              Parser.createEngineResource("KHR_draco_mesh_compression", KHR_draco_mesh_compression, context, gltfPrimitive).then(function(decodedGeometry) {
                return _this._parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, function(attributeSemantic) {
                  for (var _j = 0; _j < decodedGeometry.attributes.length; _j++) {
                    if (decodedGeometry.attributes[_j].name === attributeSemantic) {
                      return decodedGeometry.attributes[_j].array;
                    }
                  }
                  return null;
                }, function(attributeSemantic, shapeIndex) {
                  throw "BlendShape animation is not supported when using draco.";
                }, function() {
                  return decodedGeometry.index.array;
                }, engine);
              }).then(resolve);
            } else {
              _this._parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, function(attributeSemantic) {
                var accessorIdx = gltfPrimitive.attributes[attributeSemantic];
                var accessor = gltf.accessors[accessorIdx];
                return GLTFUtil.getAccessorData(gltf, accessor, buffers);
              }, function(attributeName, shapeIndex) {
                var shapeAccessorIdx = gltfPrimitive.targets[shapeIndex];
                var attributeAccessorIdx = shapeAccessorIdx[attributeName];
                if (attributeAccessorIdx) {
                  var accessor = gltf.accessors[attributeAccessorIdx];
                  return GLTFUtil.getAccessorData(gltf, accessor, buffers);
                } else {
                  return null;
                }
              }, function() {
                var indexAccessor = gltf.accessors[gltfPrimitive.indices];
                return GLTFUtil.getAccessorData(gltf, indexAccessor, buffers);
              }, engine).then(resolve);
            }
          }));
        };
        for (var j = 0; j < gltfMesh.primitives.length; j++) {
          _loop22(j);
        }
        meshPromises.push(Promise.all(primitivePromises));
      };
      for (var i = 0; i < gltf.meshes.length; i++) {
        _loop(i);
      }
      return Promise.all(meshPromises).then(function(meshes) {
        context.meshes = meshes;
      });
    };
    _proto._parseMeshFromGLTFPrimitive = function _parseMeshFromGLTFPrimitive(mesh, gltfMesh, gltfPrimitive, gltf, getVertexBufferData, getBlendShapeData, getIndexBufferData, engine) {
      var attributes = gltfPrimitive.attributes, targets = gltfPrimitive.targets, indices = gltfPrimitive.indices, mode = gltfPrimitive.mode;
      var vertexCount;
      var accessors = gltf.accessors;
      var accessor = accessors[attributes["POSITION"]];
      var positionBuffer = getVertexBufferData("POSITION");
      var positions = GLTFUtil.floatBufferToVector3Array(positionBuffer);
      mesh.setPositions(positions);
      var bounds = mesh.bounds;
      vertexCount = accessor.count;
      if (accessor.min && accessor.max) {
        bounds.min.copyFromArray(accessor.min);
        bounds.max.copyFromArray(accessor.max);
      } else {
        var position = MeshParser2._tempVector3;
        var min = bounds.min, max = bounds.max;
        min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        var stride = positionBuffer.length / vertexCount;
        for (var j = 0; j < vertexCount; j++) {
          var offset = j * stride;
          position.copyFromArray(positionBuffer, offset);
          miniprogram$1.Vector3.min(min, position, min);
          miniprogram$1.Vector3.max(max, position, max);
        }
      }
      for (var attributeSemantic in attributes) {
        if (attributeSemantic === "POSITION") {
          continue;
        }
        var bufferData = getVertexBufferData(attributeSemantic);
        switch (attributeSemantic) {
          case "NORMAL":
            var normals = GLTFUtil.floatBufferToVector3Array(bufferData);
            mesh.setNormals(normals);
            break;
          case "TEXCOORD_0":
            var texturecoords = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords, 0);
            break;
          case "TEXCOORD_1":
            var texturecoords1 = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords1, 1);
            break;
          case "TEXCOORD_2":
            var texturecoords2 = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords2, 2);
            break;
          case "TEXCOORD_3":
            var texturecoords3 = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords3, 3);
            break;
          case "TEXCOORD_4":
            var texturecoords4 = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords4, 4);
            break;
          case "TEXCOORD_5":
            var texturecoords5 = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords5, 5);
            break;
          case "TEXCOORD_6":
            var texturecoords6 = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords6, 6);
            break;
          case "TEXCOORD_7":
            var texturecoords7 = GLTFUtil.floatBufferToVector2Array(bufferData);
            mesh.setUVs(texturecoords7, 7);
            break;
          case "COLOR_0":
            var colors = GLTFUtil.floatBufferToColorArray(bufferData, accessors[attributes["COLOR_0"]].type === AccessorType.VEC3);
            mesh.setColors(colors);
            break;
          case "TANGENT":
            var tangents = GLTFUtil.floatBufferToVector4Array(bufferData);
            mesh.setTangents(tangents);
            break;
          case "JOINTS_0":
            var joints = GLTFUtil.floatBufferToVector4Array(bufferData);
            mesh.setBoneIndices(joints);
            break;
          case "WEIGHTS_0":
            var weights = GLTFUtil.floatBufferToVector4Array(bufferData);
            mesh.setBoneWeights(weights);
            break;
        }
      }
      if (indices !== void 0) {
        var indexAccessor = gltf.accessors[indices];
        var indexData = getIndexBufferData();
        mesh.setIndices(indexData);
        mesh.addSubMesh(0, indexAccessor.count, mode);
      } else {
        mesh.addSubMesh(0, vertexCount, mode);
      }
      targets && this._createBlendShape(mesh, gltfMesh, targets, getBlendShapeData);
      mesh.uploadData(true);
      return Promise.resolve(mesh);
    };
    _proto._createBlendShape = function _createBlendShape(mesh, glTFMesh, glTFTargets, getBlendShapeData) {
      var blendShapeNames = glTFMesh.extras ? glTFMesh.extras.targetNames : null;
      for (var i = 0, n = glTFTargets.length; i < n; i++) {
        var _name = blendShapeNames ? blendShapeNames[i] : "blendShape" + i;
        var deltaPosBuffer = getBlendShapeData("POSITION", i);
        var deltaNorBuffer = getBlendShapeData("NORMAL", i);
        var deltaTanBuffer = getBlendShapeData("TANGENT", i);
        var deltaPositions = deltaPosBuffer ? GLTFUtil.floatBufferToVector3Array(deltaPosBuffer) : null;
        var deltaNormals = deltaNorBuffer ? GLTFUtil.floatBufferToVector3Array(deltaNorBuffer) : null;
        var deltaTangents = deltaTanBuffer ? GLTFUtil.floatBufferToVector3Array(deltaTanBuffer) : null;
        var blendShape = new miniprogram.BlendShape(_name);
        blendShape.addFrame(1, deltaPositions, deltaNormals, deltaTangents);
        mesh.addBlendShape(blendShape);
      }
    };
    return MeshParser2;
  }(Parser);
  MeshParser._tempVector3 = new miniprogram$1.Vector3();
  var SceneParser$1 = /* @__PURE__ */ function(_Parser) {
    _inheritsLoose$2(SceneParser2, _Parser);
    function SceneParser2() {
      return _Parser.apply(this, arguments) || this;
    }
    SceneParser2._getDefaultMaterial = function _getDefaultMaterial(engine) {
      if (!SceneParser2._defaultMaterial) {
        SceneParser2._defaultMaterial = new miniprogram.BlinnPhongMaterial(engine);
      }
      return SceneParser2._defaultMaterial;
    };
    var _proto = SceneParser2.prototype;
    _proto.parse = function parse(context) {
      var _context$gltf = context.gltf, nodes = _context$gltf.nodes, gltfCameras = _context$gltf.cameras, entities = context.entities;
      if (!nodes)
        return;
      var promises = [];
      for (var i = 0; i < nodes.length; i++) {
        var gltfNode = nodes[i];
        var cameraID = gltfNode.camera, meshID = gltfNode.mesh, _gltfNode$extensions = gltfNode.extensions, extensions = _gltfNode$extensions === void 0 ? {} : _gltfNode$extensions;
        var KHR_lights_punctual = extensions.KHR_lights_punctual;
        var entity = entities[i];
        if (cameraID !== void 0) {
          this._createCamera(context, gltfCameras[cameraID], entity);
        }
        if (meshID !== void 0) {
          promises.push(this._createRenderer(context, gltfNode, entity));
        }
        if (KHR_lights_punctual) {
          var lightIndex = KHR_lights_punctual.light;
          var lights = context.gltf.extensions.KHR_lights_punctual.lights;
          Parser.parseEngineResource("KHR_lights_punctual", lights[lightIndex], entity, context);
        }
      }
      if (context.defaultSceneRoot) {
        this._createAnimator(context);
      }
      context.gltf.extensions && delete context.gltf.extensions["OASIS_materials_remap"];
      return Promise.all(promises);
    };
    _proto._createCamera = function _createCamera(context, cameraSchema, entity) {
      var orthographic = cameraSchema.orthographic, perspective = cameraSchema.perspective, type = cameraSchema.type;
      var camera = entity.addComponent(miniprogram.Camera);
      if (type === CameraType.ORTHOGRAPHIC) {
        var xmag = orthographic.xmag, ymag = orthographic.ymag, zfar = orthographic.zfar, znear = orthographic.znear;
        camera.isOrthographic = true;
        if (znear !== void 0) {
          camera.nearClipPlane = znear;
        }
        if (zfar !== void 0) {
          camera.farClipPlane = zfar;
        }
        camera.orthographicSize = Math.max(ymag != null ? ymag : 0, xmag != null ? xmag : 0) / 2;
      } else if (type === CameraType.PERSPECTIVE) {
        var aspectRatio = perspective.aspectRatio, yfov = perspective.yfov, _zfar = perspective.zfar, _znear = perspective.znear;
        if (aspectRatio !== void 0) {
          camera.aspectRatio = aspectRatio;
        }
        if (yfov !== void 0) {
          camera.fieldOfView = yfov * 180 / Math.PI;
        }
        if (_zfar !== void 0) {
          camera.farClipPlane = _zfar;
        }
        if (_znear !== void 0) {
          camera.nearClipPlane = _znear;
        }
      }
      if (!context.cameras)
        context.cameras = [];
      context.cameras.push(camera);
      camera.enabled = false;
    };
    _proto._createRenderer = function _createRenderer(context, gltfNode, entity) {
      var engine = context.engine, gltfMeshes = context.gltf.meshes, meshes = context.meshes, materials = context.materials, skins = context.skins;
      var meshID = gltfNode.mesh, skinID = gltfNode.skin;
      var glTFMesh = gltfMeshes[meshID];
      var gltfMeshPrimitives = glTFMesh.primitives;
      var blendShapeWeights = gltfNode.weights || glTFMesh.weights;
      var promises = [];
      var _loop = function _loop2(i2) {
        var mesh = meshes[meshID][i2];
        var renderer = void 0;
        if (skinID !== void 0 || blendShapeWeights) {
          var skinRenderer = entity.addComponent(miniprogram.SkinnedMeshRenderer);
          skinRenderer.mesh = mesh;
          if (skinID !== void 0) {
            skinRenderer.skin = skins[skinID];
          }
          if (blendShapeWeights) {
            skinRenderer.blendShapeWeights = new Float32Array(blendShapeWeights);
          }
          renderer = skinRenderer;
        } else {
          renderer = entity.addComponent(miniprogram.MeshRenderer);
          renderer.mesh = mesh;
        }
        var materialIndex = gltfMeshPrimitives[i2].material;
        var remapMaterials = context.gltf.extensions && context.gltf.extensions["OASIS_materials_remap"];
        if (remapMaterials && remapMaterials[materialIndex]) {
          promises.push(remapMaterials[materialIndex].then(function(mtl) {
            renderer.setMaterial(mtl);
          }));
        } else {
          var material = (materials === null || materials === void 0 ? void 0 : materials[materialIndex]) || SceneParser2._getDefaultMaterial(engine);
          renderer.setMaterial(material);
        }
        var _gltfMeshPrimitives$i = gltfMeshPrimitives[i2].extensions, extensions = _gltfMeshPrimitives$i === void 0 ? {} : _gltfMeshPrimitives$i;
        var KHR_materials_variants = extensions.KHR_materials_variants;
        if (KHR_materials_variants) {
          Parser.parseEngineResource("KHR_materials_variants", KHR_materials_variants, renderer, context);
        }
      };
      for (var i = 0; i < gltfMeshPrimitives.length; i++) {
        _loop(i);
      }
      return Promise.all(promises);
    };
    _proto._createAnimator = function _createAnimator(context) {
      var defaultSceneRoot = context.defaultSceneRoot, animations = context.animations;
      if (!animations)
        return;
      var animator = defaultSceneRoot.addComponent(miniprogram.Animator);
      var animatorController = new miniprogram.AnimatorController();
      var layer = new miniprogram.AnimatorControllerLayer("layer");
      var animatorStateMachine = new miniprogram.AnimatorStateMachine();
      animatorController.addLayer(layer);
      animator.animatorController = animatorController;
      layer.stateMachine = animatorStateMachine;
      if (animations) {
        for (var i = 0; i < animations.length; i++) {
          var animationClip = animations[i];
          var name = animationClip.name;
          var uniqueName = animatorStateMachine.makeUniqueStateName(name);
          if (uniqueName !== name) {
            console.warn("AnimatorState name is existed, name: " + name + " reset to " + uniqueName);
          }
          var animatorState = animatorStateMachine.addState(uniqueName);
          animatorState.clip = animationClip;
        }
      }
    };
    return SceneParser2;
  }(Parser);
  SceneParser$1._defaultMaterial = void 0;
  var SkinParser = /* @__PURE__ */ function(_Parser) {
    _inheritsLoose$2(SkinParser2, _Parser);
    function SkinParser2() {
      return _Parser.apply(this, arguments) || this;
    }
    var _proto = SkinParser2.prototype;
    _proto.parse = function parse(context) {
      var gltf = context.gltf, buffers = context.buffers, entities = context.entities, defaultSceneRoot = context.defaultSceneRoot;
      var gltfSkins = gltf.skins;
      if (!gltfSkins)
        return;
      var skins = [];
      for (var i = 0; i < gltfSkins.length; i++) {
        var _gltfSkins$i = gltfSkins[i], inverseBindMatrices = _gltfSkins$i.inverseBindMatrices, skeleton = _gltfSkins$i.skeleton, joints = _gltfSkins$i.joints, _gltfSkins$i$name = _gltfSkins$i.name, name = _gltfSkins$i$name === void 0 ? "SKIN_" + i : _gltfSkins$i$name;
        var jointCount = joints.length;
        var skin = new miniprogram.Skin(name);
        skin.inverseBindMatrices.length = jointCount;
        var accessor = gltf.accessors[inverseBindMatrices];
        var buffer = GLTFUtil.getAccessorData(gltf, accessor, buffers);
        for (var _i = 0; _i < jointCount; _i++) {
          var inverseBindMatrix = new miniprogram$1.Matrix();
          inverseBindMatrix.copyFromArray(buffer, _i * 16);
          skin.inverseBindMatrices[_i] = inverseBindMatrix;
        }
        for (var _i2 = 0; _i2 < jointCount; _i2++) {
          skin.joints[_i2] = entities[joints[_i2]].name;
        }
        if (skeleton !== void 0) {
          skin.skeleton = entities[skeleton].name;
        } else {
          skin.skeleton = defaultSceneRoot.name;
        }
        skins[i] = skin;
      }
      context.skins = skins;
    };
    return SkinParser2;
  }(Parser);
  var TextureParser = /* @__PURE__ */ function(_Parser) {
    _inheritsLoose$2(TextureParser2, _Parser);
    function TextureParser2() {
      return _Parser.apply(this, arguments) || this;
    }
    var _proto = TextureParser2.prototype;
    _proto.parse = function parse(context) {
      var _this = this;
      var gltf = context.gltf, buffers = context.buffers, engine = context.engine, url = context.url;
      if (gltf.textures) {
        return Promise.all(gltf.textures.map(function(_ref, index) {
          var sampler = _ref.sampler, _ref$source = _ref.source, source = _ref$source === void 0 ? 0 : _ref$source, textureName = _ref.name;
          var _gltf$images$source = gltf.images[source], uri = _gltf$images$source.uri, bufferViewIndex = _gltf$images$source.bufferView, mimeType = _gltf$images$source.mimeType, imageName = _gltf$images$source.name;
          if (uri) {
            return engine.resourceManager.load({
              url: GLTFUtil.parseRelativeUrl(url, uri),
              type: miniprogram.AssetType.Texture2D
            }).then(function(texture) {
              if (!texture.name) {
                texture.name = textureName || imageName || "texture_" + index;
              }
              if (sampler !== void 0) {
                _this._parseSampler(texture, gltf.samplers[sampler]);
              }
              return texture;
            });
          } else {
            var bufferView = gltf.bufferViews[bufferViewIndex];
            var bufferViewData = GLTFUtil.getBufferViewData(bufferView, buffers);
            return GLTFUtil.loadImageBuffer(bufferViewData, mimeType).then(function(image) {
              var texture = new miniprogram.Texture2D(engine, image.width, image.height);
              texture.setImageSource(image);
              texture.generateMipmaps();
              texture.name = textureName || imageName || "texture_" + index;
              if (sampler !== void 0) {
                _this._parseSampler(texture, gltf.samplers[sampler]);
              }
              return texture;
            });
          }
        })).then(function(textures) {
          context.textures = textures;
        });
      }
    };
    _proto._parseSampler = function _parseSampler(texture, sampler) {
      var magFilter = sampler.magFilter, minFilter = sampler.minFilter, wrapS = sampler.wrapS, wrapT = sampler.wrapT;
      if (magFilter || minFilter) {
        miniprogram.Logger.warn("texture use filterMode in engine");
      }
      if (wrapS) {
        texture.wrapModeU = TextureParser2._wrapMap[wrapS];
      }
      if (wrapT) {
        texture.wrapModeV = TextureParser2._wrapMap[wrapT];
      }
    };
    return TextureParser2;
  }(Parser);
  TextureParser._wrapMap = {
    33071: miniprogram.TextureWrapMode.Clamp,
    33648: miniprogram.TextureWrapMode.Mirror,
    10497: miniprogram.TextureWrapMode.Repeat
  };
  var Validator = /* @__PURE__ */ function(_Parser) {
    _inheritsLoose$2(Validator2, _Parser);
    function Validator2() {
      return _Parser.apply(this, arguments) || this;
    }
    var _proto = Validator2.prototype;
    _proto.parse = function parse(context) {
      var _context$gltf = context.gltf, version = _context$gltf.asset.version, extensionsUsed = _context$gltf.extensionsUsed, extensionsRequired = _context$gltf.extensionsRequired;
      var gltfVersion = Number(version);
      if (!(gltfVersion >= 2 && gltfVersion < 3)) {
        throw "Only support gltf 2.x.";
      }
      if (extensionsUsed) {
        miniprogram.Logger.info("extensionsUsed: ", extensionsUsed);
        for (var i = 0; i < extensionsUsed.length; i++) {
          if (!Parser.hasExtensionParser(extensionsUsed[i])) {
            miniprogram.Logger.warn("Extension " + extensionsUsed[i] + " is not implemented, you can customize this extension in gltf.");
          }
        }
      }
      if (extensionsRequired) {
        miniprogram.Logger.info("extensionsRequired: " + extensionsRequired);
        for (var _i = 0; _i < extensionsRequired.length; _i++) {
          var extensionRequired = extensionsRequired[_i];
          if (!Parser.hasExtensionParser(extensionRequired)) {
            miniprogram.Logger.error("GLTF parser has not supported required extension " + extensionRequired + ".");
          } else {
            Parser.initialize(extensionRequired);
          }
        }
      }
    };
    return Validator2;
  }(Parser);
  var GLTFParser = /* @__PURE__ */ function() {
    function GLTFParser2(pipes) {
      var _this = this;
      this._pipes = [];
      pipes.forEach(function(pipe, index) {
        _this._pipes[index] = new pipe();
      });
    }
    var _proto = GLTFParser2.prototype;
    _proto.parse = function parse(context) {
      var _this2 = this;
      var lastPipe;
      return new Promise(function(resolve, reject) {
        _this2._pipes.forEach(function(parser) {
          if (lastPipe) {
            lastPipe = lastPipe.then(function() {
              return parser.parse(context);
            });
          } else {
            lastPipe = parser.parse(context);
          }
        });
        if (lastPipe) {
          lastPipe.then(function() {
            resolve(context);
          }).catch(reject);
        } else {
          resolve(context);
        }
      });
    };
    return GLTFParser2;
  }();
  GLTFParser.instance = new GLTFParser([BufferParser, Validator, TextureParser, MaterialParser, MeshParser, EntityParser, SkinParser, AnimationParser, SceneParser$1]);
  var GLTFResource = /* @__PURE__ */ function(_EngineObject) {
    _inheritsLoose$2(GLTFResource2, _EngineObject);
    function GLTFResource2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _EngineObject.call.apply(_EngineObject, [this].concat(args)) || this;
      _this.url = void 0;
      _this.gltf = void 0;
      _this.buffers = void 0;
      _this.textures = void 0;
      _this.materials = void 0;
      _this.meshes = void 0;
      _this.skins = void 0;
      _this.animations = void 0;
      _this.entities = void 0;
      _this.cameras = void 0;
      _this.lights = void 0;
      _this.sceneRoots = void 0;
      _this.defaultSceneRoot = void 0;
      _this.variants = void 0;
      return _this;
    }
    return GLTFResource2;
  }(miniprogram.EngineObject);
  var _dec$q, _class$q;
  _dec$q = miniprogram.resourceLoader(miniprogram.AssetType.Prefab, ["gltf", "glb"]), _dec$q(_class$q = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(GLTFLoader, _Loader);
    function GLTFLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = GLTFLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var url = item.url;
      return new miniprogram.AssetPromise(function(resolve, reject) {
        var resource = new GLTFResource(resourceManager.engine);
        resource.url = url;
        GLTFParser.instance.parse(resource).then(resolve).catch(function(e) {
          console.error(e);
          reject("Error loading glTF model from " + url + " .");
        });
      });
    };
    return GLTFLoader;
  }(miniprogram.Loader)) || _class$q;
  var _dec$p, _class$p;
  _dec$p = miniprogram.resourceLoader(miniprogram.AssetType.JSON, ["json"], false), _dec$p(_class$p = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(JSONLoader, _Loader);
    function JSONLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = JSONLoader.prototype;
    _proto.load = function load(item) {
      return this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
        type: "json"
      }));
    };
    return JSONLoader;
  }(miniprogram.Loader)) || _class$p;
  var HEADER_LEN = 12 + 13 * 4;
  var COMPRESSED_2D = 0;
  function getMipmaps(ktxContainer, loadMipmaps) {
    var mipmaps = [];
    var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;
    var width = ktxContainer.pixelWidth;
    var height = ktxContainer.pixelHeight;
    var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;
    for (var level = 0; level < mipmapCount; level++) {
      var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0];
      dataOffset += 4;
      for (var face = 0; face < ktxContainer.numberOfFaces; face++) {
        var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);
        mipmaps.push({
          data: byteArray,
          width,
          height
        });
        dataOffset += imageSize;
        dataOffset += 3 - (imageSize + 3) % 4;
      }
      width = Math.max(1, width * 0.5);
      height = Math.max(1, height * 0.5);
    }
    return mipmaps;
  }
  function isValid(data) {
    if (data.byteLength >= 12) {
      var identifier = new Uint8Array(data, 0, 12);
      if (identifier[0] === 171 && identifier[1] === 75 && identifier[2] === 84 && identifier[3] === 88 && identifier[4] === 32 && identifier[5] === 49 && identifier[6] === 49 && identifier[7] === 187 && identifier[8] === 13 && identifier[9] === 10 && identifier[10] === 26 && identifier[11] === 10) {
        return true;
      }
    }
    return false;
  }
  function getEngineFormat(internalFormat) {
    switch (internalFormat) {
      case miniprogram$2.GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:
        return miniprogram.TextureFormat.DXT1;
      case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
        return miniprogram.TextureFormat.DXT5;
      case miniprogram$2.GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:
        return miniprogram.TextureFormat.ETC1_RGB;
      case miniprogram$2.GLCompressedTextureInternalFormat.RGB8_ETC2:
        return miniprogram.TextureFormat.ETC2_RGB;
      case miniprogram$2.GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
        return miniprogram.TextureFormat.ETC2_RGBA5;
      case miniprogram$2.GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:
        return miniprogram.TextureFormat.ETC2_RGBA8;
      case miniprogram$2.GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:
        return miniprogram.TextureFormat.PVRTC_RGB2;
      case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:
        return miniprogram.TextureFormat.PVRTC_RGBA2;
      case miniprogram$2.GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:
        return miniprogram.TextureFormat.PVRTC_RGB4;
      case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:
        return miniprogram.TextureFormat.PVRTC_RGBA4;
      case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:
        return miniprogram.TextureFormat.ASTC_4x4;
      case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:
        return miniprogram.TextureFormat.ASTC_5x5;
      case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:
        return miniprogram.TextureFormat.ASTC_6x6;
      case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:
        return miniprogram.TextureFormat.ASTC_8x8;
      case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:
        return miniprogram.TextureFormat.ASTC_10x10;
      case miniprogram$2.GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:
        return miniprogram.TextureFormat.ASTC_12x12;
      default:
        var formatName = miniprogram$2.GLCompressedTextureInternalFormat[internalFormat];
        throw new Error("this format is not supported in Oasis Engine: " + formatName);
    }
  }
  var khronosTextureContainerParser = {
    parse: function parse(buffer, facesExpected, withMipmaps, mapEngineFormat) {
      if (mapEngineFormat === void 0) {
        mapEngineFormat = false;
      }
      if (!isValid(buffer)) {
        throw new Error("khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier");
      }
      var dataSize = Uint32Array.BYTES_PER_ELEMENT;
      var headerDataView = new DataView(buffer, 12, 13 * dataSize);
      var endianness = headerDataView.getUint32(0, true);
      var littleEndian = endianness === 67305985;
      var parsedResult = {
        buffer,
        glType: headerDataView.getUint32(1 * dataSize, littleEndian),
        glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),
        glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),
        glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),
        glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),
        pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),
        pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),
        pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),
        numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),
        numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),
        numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),
        bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),
        loadType: COMPRESSED_2D
      };
      if (parsedResult.glType !== 0) {
        throw new Error("only compressed formats currently supported");
      } else {
        parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);
      }
      if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {
        throw new Error("only 2D textures currently supported");
      }
      if (parsedResult.numberOfArrayElements !== 0) {
        throw new Error("texture arrays not currently supported");
      }
      if (parsedResult.numberOfFaces !== facesExpected) {
        throw new Error("number of faces expected" + facesExpected + ", but found " + parsedResult.numberOfFaces);
      }
      if (withMipmaps) {
        parsedResult.mipmaps = getMipmaps(parsedResult, true);
      }
      if (mapEngineFormat) {
        parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);
      }
      return parsedResult;
    }
  };
  function parseSingleKTX(data) {
    var ktx = khronosTextureContainerParser.parse(data, 1, true, true);
    return {
      mipmaps: ktx.mipmaps,
      engineFormat: ktx.engineFormat,
      internalFormat: ktx.glInternalFormat,
      width: ktx.pixelWidth,
      height: ktx.pixelHeight
    };
  }
  function parseCubeKTX(dataArray) {
    var mipmapsFaces = [];
    var internalFormat;
    var engineFormat;
    var width;
    var height;
    for (var i = 0; i < dataArray.length; i++) {
      var ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);
      mipmapsFaces.push(ktx.mipmaps);
      if (i === 0) {
        width = ktx.pixelWidth;
        height = ktx.pixelHeight;
        internalFormat = ktx.glInternalFormat;
        engineFormat = ktx.engineFormat;
      }
    }
    return {
      mipmapsFaces,
      engineFormat,
      internalFormat,
      width,
      height
    };
  }
  var _dec$o, _class$o;
  _dec$o = miniprogram.resourceLoader(miniprogram.AssetType.KTXCube, []), _dec$o(_class$o = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(KTXCubeLoader, _Loader);
    function KTXCubeLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = KTXCubeLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new miniprogram.AssetPromise(function(resolve, reject) {
        Promise.all(item.urls.map(function(url) {
          return _this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
            type: "arraybuffer"
          }));
        })).then(function(data) {
          var parsedData = parseCubeKTX(data);
          var width = parsedData.width, mipmapsFaces = parsedData.mipmapsFaces, engineFormat = parsedData.engineFormat;
          var mipmap = mipmapsFaces[0].length > 1;
          var texture = new miniprogram.TextureCube(resourceManager.engine, width, engineFormat, mipmap);
          for (var face = 0; face < 6; face++) {
            var length2 = mipmapsFaces[face].length;
            for (var miplevel = 0; miplevel < length2; miplevel++) {
              var _mipmapsFaces$face$mi = mipmapsFaces[face][miplevel], _data = _mipmapsFaces$face$mi.data, _width = _mipmapsFaces$face$mi.width, height = _mipmapsFaces$face$mi.height;
              texture.setPixelBuffer(miniprogram.TextureCubeFace.PositiveX + face, _data, miplevel, 0, 0, _width, height);
            }
          }
          resolve(texture);
        }).catch(function(e) {
          reject(e);
        });
      });
    };
    return KTXCubeLoader;
  }(miniprogram.Loader)) || _class$o;
  var _dec$n, _class$n;
  _dec$n = miniprogram.resourceLoader(miniprogram.AssetType.KTX, ["ktx"]), _dec$n(_class$n = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(KTXLoader, _Loader);
    function KTXLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = KTXLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new miniprogram.AssetPromise(function(resolve, reject) {
        _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "arraybuffer"
        })).then(function(bin) {
          var parsedData = parseSingleKTX(bin);
          var width = parsedData.width, height = parsedData.height, mipmaps = parsedData.mipmaps, engineFormat = parsedData.engineFormat;
          var mipmap = mipmaps.length > 1;
          var texture = new miniprogram.Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);
          for (var miplevel = 0; miplevel < mipmaps.length; miplevel++) {
            var _mipmaps$miplevel = mipmaps[miplevel], _width = _mipmaps$miplevel.width, _height = _mipmaps$miplevel.height, data = _mipmaps$miplevel.data;
            texture.setPixelBuffer(data, miplevel, 0, 0, _width, _height);
          }
          resolve(texture);
        }).catch(function(e) {
          reject(e);
        });
      });
    };
    return KTXLoader;
  }(miniprogram.Loader)) || _class$n;
  var _dec$m, _class$m;
  _dec$m = miniprogram.resourceLoader(miniprogram.AssetType.Texture2D, ["png", "jpg", "webp", "jpeg"]), _dec$m(_class$m = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(Texture2DLoader, _Loader);
    function Texture2DLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = Texture2DLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new miniprogram.AssetPromise(function(resolve, reject) {
        _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "image"
        })).then(function(image) {
          var texture = new miniprogram.Texture2D(resourceManager.engine, image.width, image.height);
          if (!texture._platformTexture)
            return;
          texture.setImageSource(image);
          texture.generateMipmaps();
          if (item.url.indexOf("data:") !== 0) {
            var splitPath = item.url.split("/");
            texture.name = splitPath[splitPath.length - 1];
          }
          resolve(texture);
        }).catch(function(e) {
          reject(e);
        });
      });
    };
    return Texture2DLoader;
  }(miniprogram.Loader)) || _class$m;
  var _dec$l, _class$l;
  _dec$l = miniprogram.resourceLoader(miniprogram.AssetType.TextureCube, [""]), _dec$l(_class$l = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(TextureCubeLoader, _Loader);
    function TextureCubeLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = TextureCubeLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new miniprogram.AssetPromise(function(resolve, reject) {
        Promise.all(item.urls.map(function(url) {
          return _this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
            type: "image"
          }));
        })).then(function(images) {
          var _images$ = images[0], width = _images$.width, height = _images$.height;
          if (width !== height) {
            console.error("The cube texture must have the same width and height");
            return;
          }
          var tex = new miniprogram.TextureCube(resourceManager.engine, width);
          if (!tex._platformTexture)
            return;
          for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
            tex.setImageSource(miniprogram.TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
          }
          tex.generateMipmaps();
          resolve(tex);
        }).catch(function(e) {
          reject(e);
        });
      });
    };
    return TextureCubeLoader;
  }(miniprogram.Loader)) || _class$l;
  var _dec$k, _class$k;
  _dec$k = miniprogram.resourceLoader(miniprogram.AssetType.Sprite, ["sprite"], false), _dec$k(_class$k = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(SpriteLoader, _Loader);
    function SpriteLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = SpriteLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new miniprogram.AssetPromise(function(resolve, reject) {
        _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "json"
        })).then(function(data) {
          resourceManager.getResourceByRef(data.texture).then(function(texture) {
            var sprite = new miniprogram.Sprite(resourceManager.engine, texture);
            sprite.region = data.region;
            sprite.pivot = data.pivot;
            resolve(sprite);
          });
        });
      });
    };
    return SpriteLoader;
  }(miniprogram.Loader)) || _class$k;
  var _dec$j, _class$j;
  _dec$j = miniprogram.resourceLoader(miniprogram.AssetType.SpriteAtlas, ["atlas"], false), _dec$j(_class$j = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(SpriteAtlasLoader, _Loader);
    function SpriteAtlasLoader() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _Loader.call.apply(_Loader, [this].concat(args)) || this;
      _this._tempRect = new miniprogram$1.Rect();
      _this._tempVec2 = new miniprogram$1.Vector2();
      return _this;
    }
    var _proto = SpriteAtlasLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this2 = this;
      return new miniprogram.AssetPromise(function(resolve, reject) {
        _this2.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "json"
        })).then(function(atlasData) {
          var atlasItems = atlasData.atlasItems, format = atlasData.format;
          var atlasItemsLen = atlasItems.length;
          Promise.all(atlasItems.map(function(_ref) {
            var img = _ref.img;
            return _this2.request(GLTFUtil.parseRelativeUrl(item.url, img), _objectSpread2(_objectSpread2({}, item), {}, {
              type: "image"
            }));
          })).then(function(imgs) {
            var engine = resourceManager.engine;
            var tempRect = _this2._tempRect, tempVec2 = _this2._tempVec2;
            var spriteAtlas = new miniprogram.SpriteAtlas(engine);
            for (var i = 0; i < atlasItemsLen; i++) {
              var originalImg = imgs[i];
              var width = originalImg.width, height = originalImg.height;
              var texture = new miniprogram.Texture2D(engine, width, height, format);
              texture.setImageSource(originalImg);
              texture.generateMipmaps();
              var atlasItem = atlasItems[i];
              var sprites = atlasItem.sprites;
              var sourceWidthReciprocal = 1 / width;
              var sourceHeightReciprocal = 1 / height;
              for (var j = sprites.length - 1; j >= 0; j--) {
                var atlasSprite = sprites[j];
                var region = atlasSprite.region, atlasRegionOffset = atlasSprite.atlasRegionOffset, atlasRegion = atlasSprite.atlasRegion, id = atlasSprite.id, pivot = atlasSprite.pivot;
                var sprite = new miniprogram.Sprite(engine, texture, region ? tempRect.set(region.x, region.y, region.w, region.h) : void 0, pivot ? tempVec2.set(pivot.x, pivot.y) : void 0, void 0, atlasSprite.name);
                sprite.atlasRegion.set(atlasRegion.x * sourceWidthReciprocal, atlasRegion.y * sourceHeightReciprocal, atlasRegion.w * sourceWidthReciprocal, atlasRegion.h * sourceHeightReciprocal);
                atlasSprite.atlasRotated && (sprite.atlasRotated = true);
                if (atlasRegionOffset) {
                  var offsetLeft = atlasRegionOffset.x, offsetTop = atlasRegionOffset.y, offsetRight = atlasRegionOffset.z, offsetBottom = atlasRegionOffset.w;
                  sprite.atlasRegionOffset.set(offsetLeft * sourceWidthReciprocal, offsetTop * sourceHeightReciprocal, offsetRight * sourceWidthReciprocal, offsetBottom * sourceHeightReciprocal);
                }
                if (id !== void 0) {
                  sprite._assetID = id;
                }
                spriteAtlas._addSprite(sprite);
              }
            }
            resolve(spriteAtlas);
          });
        }).catch(function(e) {
          reject(e);
        });
      });
    };
    return SpriteAtlasLoader;
  }(miniprogram.Loader)) || _class$j;
  var _dec$i, _class$i;
  _dec$i = miniprogram.resourceLoader(miniprogram.AssetType.Env, ["env"]), _dec$i(_class$i = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(EnvLoader, _Loader);
    function EnvLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = EnvLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new miniprogram.AssetPromise(function(resolve, reject) {
        _this.request(item.url, {
          type: "arraybuffer"
        }).then(function(arraybuffer) {
          var _Uint16Array;
          var shArray = new Float32Array(arraybuffer, 0, 27);
          var shByteLength = 27 * 4;
          var size = (_Uint16Array = new Uint16Array(arraybuffer, shByteLength, 1)) === null || _Uint16Array === void 0 ? void 0 : _Uint16Array[0];
          var texture = new miniprogram.TextureCube(resourceManager.engine, size);
          texture.filterMode = miniprogram.TextureFilterMode.Trilinear;
          var mipmapCount = texture.mipmapCount;
          var offset = shByteLength + 2;
          for (var mipLevel = 0; mipLevel < mipmapCount; mipLevel++) {
            var mipSize = size >> mipLevel;
            for (var face = 0; face < 6; face++) {
              var dataSize = mipSize * mipSize * 4;
              var data = new Uint8Array(arraybuffer, offset, dataSize);
              offset += dataSize;
              texture.setPixelBuffer(miniprogram.TextureCubeFace.PositiveX + face, data, mipLevel);
            }
          }
          var ambientLight = new miniprogram.AmbientLight();
          var sh = new miniprogram$1.SphericalHarmonics3();
          ambientLight.diffuseMode = miniprogram.DiffuseMode.SphericalHarmonics;
          sh.copyFromArray(shArray);
          ambientLight.diffuseSphericalHarmonics = sh;
          ambientLight.specularTexture = texture;
          ambientLight.specularTextureDecodeRGBM = true;
          resolve(ambientLight);
        }).catch(function(e) {
          reject(e);
        });
      });
    };
    return EnvLoader;
  }(miniprogram.Loader)) || _class$i;
  var _dec$h, _class$h, _class2$1;
  var PI = Math.PI;
  _dec$h = miniprogram.resourceLoader(miniprogram.AssetType.HDR, ["hdr"]), _dec$h(_class$h = (_class2$1 = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(HDRLoader, _Loader);
    function HDRLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    HDRLoader._convertToCubemap = function _convertToCubemap(pixels, inputWidth, inputHeight, size) {
      if (!pixels) {
        throw "ConvertPanoramaToCubemap: input cannot be null";
      }
      if (pixels.length != inputWidth * inputHeight * 4) {
        throw "ConvertPanoramaToCubemap: input size is wrong";
      }
      var textureRight = this._createCubemapData(size, this._faceRight, pixels, inputWidth, inputHeight);
      var textureLeft = this._createCubemapData(size, this._faceLeft, pixels, inputWidth, inputHeight);
      var textureUp = this._createCubemapData(size, this._faceUp, pixels, inputWidth, inputHeight);
      var textureDown = this._createCubemapData(size, this._faceBottom, pixels, inputWidth, inputHeight);
      var textureFront = this._createCubemapData(size, this._faceFront, pixels, inputWidth, inputHeight);
      var textureBack = this._createCubemapData(size, this._faceBack, pixels, inputWidth, inputHeight);
      return [textureRight, textureLeft, textureUp, textureDown, textureFront, textureBack];
    };
    HDRLoader._createCubemapData = function _createCubemapData(texSize, faceData, pixels, inputWidth, inputHeight) {
      var textureArray = new Uint8ClampedArray(texSize * texSize * 4);
      var rotDX1 = this._tempVector3.set(0, 0, 0).add(faceData[1]).subtract(faceData[0]).scale(1 / texSize);
      var rotDX2 = this._temp2Vector3.set(0, 0, 0).add(faceData[3]).subtract(faceData[2]).scale(1 / texSize);
      var dy = 1 / texSize;
      var fy = 0;
      for (var y = 0; y < texSize; y++) {
        var xv1 = this._temp3Vector3.set(0, 0, 0).add(faceData[0]);
        var xv2 = this._temp4Vector3.set(0, 0, 0).add(faceData[2]);
        for (var x = 0; x < texSize; x++) {
          var v = this._temp5Vector3.set(0, 0, 0).add(xv2).subtract(xv1).scale(fy).add(xv1);
          v.normalize();
          var color = this._calcProjectionSpherical(v, pixels, inputWidth, inputHeight);
          this._RGBEToLinear(color);
          this._linearToRGBM(color, 5);
          var index = y * texSize * 4 + x * 4;
          textureArray[index] = color.r;
          textureArray[index + 1] = color.g;
          textureArray[index + 2] = color.b;
          textureArray[index + 3] = color.a;
          xv1.add(rotDX1);
          xv2.add(rotDX2);
        }
        fy += dy;
      }
      return textureArray;
    };
    HDRLoader._calcProjectionSpherical = function _calcProjectionSpherical(vDir, pixels, inputWidth, inputHeight) {
      var theta = Math.atan2(vDir.z, -vDir.x);
      var phi = Math.acos(vDir.y);
      while (theta < -PI) {
        theta += 2 * PI;
      }
      while (theta > PI) {
        theta -= 2 * PI;
      }
      var dx = theta / PI;
      var dy = phi / PI;
      dx = dx * 0.5 + 0.5;
      var px = Math.round(dx * inputWidth);
      if (px < 0) {
        px = 0;
      } else if (px >= inputWidth) {
        px = inputWidth - 1;
      }
      var py = Math.round(dy * inputHeight);
      if (py < 0) {
        py = 0;
      } else if (py >= inputHeight) {
        py = inputHeight - 1;
      }
      var inputY = inputHeight - py - 1;
      var index = inputY * inputWidth * 4 + px * 4;
      var r = pixels[index];
      var g = pixels[index + 1];
      var b = pixels[index + 2];
      var a = pixels[index + 3];
      return new miniprogram$1.Color(r, g, b, a);
    };
    HDRLoader._readStringLine = function _readStringLine(uint8array, startIndex) {
      var line = "";
      var character = "";
      for (var i = startIndex; i < uint8array.length - startIndex; i++) {
        character = String.fromCharCode(uint8array[i]);
        if (character == "\n") {
          break;
        }
        line += character;
      }
      return line;
    };
    HDRLoader._parseHeader = function _parseHeader(uint8array) {
      var height = 0;
      var width = 0;
      var line = this._readStringLine(uint8array, 0);
      if (line[0] != "#" || line[1] != "?") {
        throw "Bad HDR Format.";
      }
      var endOfHeader = false;
      var findFormat = false;
      var lineIndex = 0;
      do {
        lineIndex += line.length + 1;
        line = this._readStringLine(uint8array, lineIndex);
        if (line == "FORMAT=32-bit_rle_rgbe") {
          findFormat = true;
        } else if (line.length == 0) {
          endOfHeader = true;
        }
      } while (!endOfHeader);
      if (!findFormat) {
        throw "HDR Bad header format, unsupported FORMAT";
      }
      lineIndex += line.length + 1;
      line = this._readStringLine(uint8array, lineIndex);
      var sizeRegexp = /^\-Y (.*) \+X (.*)$/g;
      var match = sizeRegexp.exec(line);
      if (!match || match.length < 3) {
        throw "HDR Bad header format, no size";
      }
      width = parseInt(match[2]);
      height = parseInt(match[1]);
      if (width < 8 || width > 32767) {
        throw "HDR Bad header format, unsupported size";
      }
      lineIndex += line.length + 1;
      return {
        height,
        width,
        dataPosition: lineIndex
      };
    };
    HDRLoader._readPixels = function _readPixels(buffer, width, height) {
      var scanLineWidth = width;
      var byteLength = buffer.byteLength;
      var dataRGBA = new Uint8Array(4 * width * height);
      var offset = 0, pos = 0;
      var ptrEnd = 4 * scanLineWidth;
      var rgbeStart = new Uint8Array(4);
      var scanLineBuffer = new Uint8Array(ptrEnd);
      var numScanLines = height;
      while (numScanLines > 0 && pos < byteLength) {
        rgbeStart[0] = buffer[pos++];
        rgbeStart[1] = buffer[pos++];
        rgbeStart[2] = buffer[pos++];
        rgbeStart[3] = buffer[pos++];
        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanLineWidth) {
          throw "HDR Bad header format, wrong scan line width";
        }
        var ptr = 0, count = void 0;
        while (ptr < ptrEnd && pos < byteLength) {
          count = buffer[pos++];
          var isEncodedRun = count > 128;
          if (isEncodedRun)
            count -= 128;
          if (0 === count || ptr + count > ptrEnd) {
            throw "HDR Bad Format, bad scanline data (run)";
          }
          if (isEncodedRun) {
            var byteValue = buffer[pos++];
            for (var i = 0; i < count; i++) {
              scanLineBuffer[ptr++] = byteValue;
            }
          } else {
            scanLineBuffer.set(buffer.subarray(pos, pos + count), ptr);
            ptr += count;
            pos += count;
          }
        }
        var l = scanLineWidth;
        for (var _i = 0; _i < l; _i++) {
          var off = 0;
          dataRGBA[offset] = scanLineBuffer[_i + off];
          off += scanLineWidth;
          dataRGBA[offset + 1] = scanLineBuffer[_i + off];
          off += scanLineWidth;
          dataRGBA[offset + 2] = scanLineBuffer[_i + off];
          off += scanLineWidth;
          dataRGBA[offset + 3] = scanLineBuffer[_i + off];
          offset += 4;
        }
        numScanLines--;
      }
      return dataRGBA;
    };
    HDRLoader._RGBEToLinear = function _RGBEToLinear(color) {
      var scaleFactor = Math.pow(2, color.a - 128) / 255;
      color.r *= scaleFactor;
      color.g *= scaleFactor;
      color.b *= scaleFactor;
      color.a = 1;
    };
    HDRLoader._linearToRGBM = function _linearToRGBM(color, maxRange) {
      var maxRGB = Math.max(color.r, Math.max(color.g, color.b));
      var M = Math.min(maxRGB / maxRange, 1);
      M = Math.ceil(M * 255);
      var scaleFactor = 65025 / (M * maxRange);
      color.r *= scaleFactor;
      color.g *= scaleFactor;
      color.b *= scaleFactor;
      color.a *= M;
    };
    var _proto = HDRLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new miniprogram.AssetPromise(function(resolve, reject) {
        var engine = resourceManager.engine;
        _this.request(item.url, {
          type: "arraybuffer"
        }).then(function(buffer) {
          var uint8Array = new Uint8Array(buffer);
          var _HDRLoader$_parseHead = HDRLoader._parseHeader(uint8Array), width = _HDRLoader$_parseHead.width, height = _HDRLoader$_parseHead.height, dataPosition = _HDRLoader$_parseHead.dataPosition;
          var pixels = HDRLoader._readPixels(uint8Array.subarray(dataPosition), width, height);
          var cubeSize = height >> 1;
          var cubeMapData = HDRLoader._convertToCubemap(pixels, width, height, cubeSize);
          var texture = new miniprogram.TextureCube(engine, cubeSize);
          for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
            texture.setPixelBuffer(miniprogram.TextureCubeFace.PositiveX + faceIndex, cubeMapData[faceIndex], 0);
          }
          texture.generateMipmaps();
          resolve(texture);
        }).catch(reject);
      });
    };
    return HDRLoader;
  }(miniprogram.Loader), _class2$1._rightBottomBack = new miniprogram$1.Vector3(1, -1, -1), _class2$1._rightBottomFront = new miniprogram$1.Vector3(1, -1, 1), _class2$1._rightUpBack = new miniprogram$1.Vector3(1, 1, -1), _class2$1._rightUpFront = new miniprogram$1.Vector3(1, 1, 1), _class2$1._leftBottomBack = new miniprogram$1.Vector3(-1, -1, -1), _class2$1._leftBottomFront = new miniprogram$1.Vector3(-1, -1, 1), _class2$1._leftUpBack = new miniprogram$1.Vector3(-1, 1, -1), _class2$1._leftUpFront = new miniprogram$1.Vector3(-1, 1, 1), _class2$1._faceRight = [_class2$1._rightBottomBack, _class2$1._rightBottomFront, _class2$1._rightUpBack, _class2$1._rightUpFront], _class2$1._faceLeft = [_class2$1._leftBottomFront, _class2$1._leftBottomBack, _class2$1._leftUpFront, _class2$1._leftUpBack], _class2$1._faceUp = [_class2$1._leftBottomFront, _class2$1._rightBottomFront, _class2$1._leftBottomBack, _class2$1._rightBottomBack], _class2$1._faceBottom = [_class2$1._leftUpBack, _class2$1._rightUpBack, _class2$1._leftUpFront, _class2$1._rightUpFront], _class2$1._faceFront = [_class2$1._leftBottomBack, _class2$1._rightBottomBack, _class2$1._leftUpBack, _class2$1._rightUpBack], _class2$1._faceBack = [_class2$1._rightBottomFront, _class2$1._leftBottomFront, _class2$1._rightUpFront, _class2$1._leftUpFront], _class2$1._tempVector3 = new miniprogram$1.Vector3(), _class2$1._temp2Vector3 = new miniprogram$1.Vector3(), _class2$1._temp3Vector3 = new miniprogram$1.Vector3(), _class2$1._temp4Vector3 = new miniprogram$1.Vector3(), _class2$1._temp5Vector3 = new miniprogram$1.Vector3(), _class2$1)) || _class$h;
  var ExtensionParser = /* @__PURE__ */ function() {
    function ExtensionParser2() {
    }
    var _proto = ExtensionParser2.prototype;
    _proto.initialize = function initialize() {
    };
    _proto.parseEngineResource = function parseEngineResource(schema, parseResource, context) {
    };
    _proto.createEngineResource = function createEngineResource(schema, context) {
      return null;
    };
    return ExtensionParser2;
  }();
  var _dec$g, _class$g, _class2$2;
  _dec$g = registerExtension("KHR_draco_mesh_compression"), _dec$g(_class$g = (_class2$2 = /* @__PURE__ */ function(_ExtensionParser) {
    _inheritsLoose$2(KHR_draco_mesh_compression, _ExtensionParser);
    function KHR_draco_mesh_compression() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_draco_mesh_compression.prototype;
    _proto.initialize = function initialize() {
      if (!KHR_draco_mesh_compression._decoder) {
        KHR_draco_mesh_compression._decoder = new miniprogram$3.DRACODecoder();
      }
    };
    _proto.createEngineResource = function createEngineResource(schema, context, gltfPrimitive) {
      var gltf = context.gltf, buffers = context.buffers;
      var bufferViews = gltf.bufferViews, accessors = gltf.accessors;
      var bufferViewIndex = schema.bufferView, gltfAttributeMap = schema.attributes;
      var attributeMap = {};
      var attributeTypeMap = {};
      for (var attributeName in gltfAttributeMap) {
        attributeMap[attributeName] = gltfAttributeMap[attributeName];
      }
      for (var _attributeName in gltfPrimitive.attributes) {
        if (gltfAttributeMap[_attributeName] !== void 0) {
          var accessorDef = accessors[gltfPrimitive.attributes[_attributeName]];
          attributeTypeMap[_attributeName] = GLTFUtil.getComponentType(accessorDef.componentType).name;
        }
      }
      var indexAccessor = accessors[gltfPrimitive.indices];
      var indexType = GLTFUtil.getComponentType(indexAccessor.componentType).name;
      var taskConfig = {
        attributeIDs: attributeMap,
        attributeTypes: attributeTypeMap,
        useUniqueIDs: true,
        indexType
      };
      var buffer = GLTFUtil.getBufferViewData(bufferViews[bufferViewIndex], buffers);
      return KHR_draco_mesh_compression._decoder.decode(buffer, taskConfig).then(function(parsedGeometry) {
        return parsedGeometry;
      });
    };
    return KHR_draco_mesh_compression;
  }(ExtensionParser), _class2$2._decoder = void 0, _class2$2)) || _class$g;
  var _dec$f, _class$f;
  _dec$f = registerExtension("KHR_lights_punctual"), _dec$f(_class$f = /* @__PURE__ */ function(_ExtensionParser) {
    _inheritsLoose$2(KHR_lights_punctual, _ExtensionParser);
    function KHR_lights_punctual() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_lights_punctual.prototype;
    _proto.parseEngineResource = function parseEngineResource(schema, entity, context) {
      var color = schema.color, _schema$intensity = schema.intensity, intensity = _schema$intensity === void 0 ? 1 : _schema$intensity, type = schema.type, range = schema.range, spot = schema.spot;
      var light;
      if (type === "directional") {
        light = entity.addComponent(miniprogram.DirectLight);
      } else if (type === "point") {
        light = entity.addComponent(miniprogram.PointLight);
      } else if (type === "spot") {
        light = entity.addComponent(miniprogram.SpotLight);
      }
      if (color) {
        light.color.set(color[0], color[1], color[2], 1);
      }
      light.intensity = intensity;
      if (range && !(light instanceof miniprogram.DirectLight)) {
        light.distance = range;
      }
      if (spot && light instanceof miniprogram.SpotLight) {
        var _spot$innerConeAngle = spot.innerConeAngle, innerConeAngle = _spot$innerConeAngle === void 0 ? 0 : _spot$innerConeAngle, _spot$outerConeAngle = spot.outerConeAngle, outerConeAngle = _spot$outerConeAngle === void 0 ? Math.PI / 4 : _spot$outerConeAngle;
        light.angle = innerConeAngle;
        light.penumbra = outerConeAngle - innerConeAngle;
      }
      if (!context.lights)
        context.lights = [];
      context.lights.push(light);
    };
    return KHR_lights_punctual;
  }(ExtensionParser)) || _class$f;
  var _dec$e, _class$e;
  _dec$e = registerExtension("KHR_materials_clearcoat"), _dec$e(_class$e = /* @__PURE__ */ function(_ExtensionParser) {
    _inheritsLoose$2(KHR_materials_clearcoat, _ExtensionParser);
    function KHR_materials_clearcoat() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_clearcoat.prototype;
    _proto.parseEngineResource = function parseEngineResource(schema, material, context) {
      var textures = context.textures;
      var _schema$clearcoatFact = schema.clearcoatFactor, clearcoatFactor = _schema$clearcoatFact === void 0 ? 0 : _schema$clearcoatFact, clearcoatTexture = schema.clearcoatTexture, _schema$clearcoatRoug = schema.clearcoatRoughnessFactor, clearcoatRoughnessFactor = _schema$clearcoatRoug === void 0 ? 0 : _schema$clearcoatRoug, clearcoatRoughnessTexture = schema.clearcoatRoughnessTexture, clearcoatNormalTexture = schema.clearcoatNormalTexture;
      material.clearCoat = clearcoatFactor;
      material.clearCoatRoughness = clearcoatRoughnessFactor;
      if (clearcoatTexture) {
        material.clearCoatTexture = textures[clearcoatTexture.index];
        MaterialParser._parseTextureTransform(material, clearcoatTexture.extensions, context);
      }
      if (clearcoatRoughnessTexture) {
        material.clearCoatRoughnessTexture = textures[clearcoatRoughnessTexture.index];
        MaterialParser._parseTextureTransform(material, clearcoatRoughnessTexture.extensions, context);
      }
      if (clearcoatNormalTexture) {
        material.clearCoatNormalTexture = textures[clearcoatNormalTexture.index];
        MaterialParser._parseTextureTransform(material, clearcoatNormalTexture.extensions, context);
      }
    };
    return KHR_materials_clearcoat;
  }(ExtensionParser)) || _class$e;
  var _dec$d, _class$d;
  _dec$d = registerExtension("KHR_materials_pbrSpecularGlossiness"), _dec$d(_class$d = /* @__PURE__ */ function(_ExtensionParser) {
    _inheritsLoose$2(KHR_materials_pbrSpecularGlossiness, _ExtensionParser);
    function KHR_materials_pbrSpecularGlossiness() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_pbrSpecularGlossiness.prototype;
    _proto.createEngineResource = function createEngineResource(schema, context) {
      var engine = context.engine, textures = context.textures;
      var material = new miniprogram.PBRSpecularMaterial(engine);
      var diffuseFactor = schema.diffuseFactor, diffuseTexture = schema.diffuseTexture, specularFactor = schema.specularFactor, glossinessFactor = schema.glossinessFactor, specularGlossinessTexture = schema.specularGlossinessTexture;
      if (diffuseFactor) {
        material.baseColor = new miniprogram$1.Color(miniprogram$1.Color.linearToGammaSpace(diffuseFactor[0]), miniprogram$1.Color.linearToGammaSpace(diffuseFactor[1]), miniprogram$1.Color.linearToGammaSpace(diffuseFactor[2]), diffuseFactor[3]);
      }
      if (diffuseTexture) {
        material.baseTexture = textures[diffuseTexture.index];
        MaterialParser._parseTextureTransform(material, diffuseTexture.extensions, context);
      }
      if (specularFactor) {
        material.specularColor = new miniprogram$1.Color(miniprogram$1.Color.linearToGammaSpace(specularFactor[0]), miniprogram$1.Color.linearToGammaSpace(specularFactor[1]), miniprogram$1.Color.linearToGammaSpace(specularFactor[2]));
      }
      if (glossinessFactor !== void 0) {
        material.glossiness = glossinessFactor;
      }
      if (specularGlossinessTexture) {
        material.specularGlossinessTexture = textures[specularGlossinessTexture.index];
        MaterialParser._parseTextureTransform(material, specularGlossinessTexture.extensions, context);
      }
      return material;
    };
    return KHR_materials_pbrSpecularGlossiness;
  }(ExtensionParser)) || _class$d;
  var _dec$c, _class$c;
  _dec$c = registerExtension("KHR_materials_unlit"), _dec$c(_class$c = /* @__PURE__ */ function(_ExtensionParser) {
    _inheritsLoose$2(KHR_materials_unlit, _ExtensionParser);
    function KHR_materials_unlit() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_unlit.prototype;
    _proto.createEngineResource = function createEngineResource(schema, context) {
      var engine = context.engine;
      var material = new miniprogram.UnlitMaterial(engine);
      return material;
    };
    return KHR_materials_unlit;
  }(ExtensionParser)) || _class$c;
  var _dec$b, _class$b;
  _dec$b = registerExtension("KHR_materials_variants"), _dec$b(_class$b = /* @__PURE__ */ function(_ExtensionParser) {
    _inheritsLoose$2(KHR_materials_variants, _ExtensionParser);
    function KHR_materials_variants() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_variants.prototype;
    _proto.parseEngineResource = function parseEngineResource(schema, renderer, context) {
      var variantNames = context.gltf.extensions.KHR_materials_variants.variants, materials = context.materials;
      var mappings = schema.mappings;
      for (var i = 0; i < mappings.length; i++) {
        var _mappings$i = mappings[i], material = _mappings$i.material, variants = _mappings$i.variants;
        if (!context.variants)
          context.variants = [];
        context.variants.push({
          renderer,
          material: materials[material],
          variants: variants.map(function(index) {
            return variantNames[index].name;
          })
        });
      }
    };
    return KHR_materials_variants;
  }(ExtensionParser)) || _class$b;
  var _dec$a, _class$a;
  _dec$a = registerExtension("KHR_mesh_quantization"), _dec$a(_class$a = /* @__PURE__ */ function(_ExtensionParser) {
    _inheritsLoose$2(KHR_mesh_quantization, _ExtensionParser);
    function KHR_mesh_quantization() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    return KHR_mesh_quantization;
  }(ExtensionParser)) || _class$a;
  var _dec$9, _class$9;
  _dec$9 = registerExtension("KHR_texture_transform"), _dec$9(_class$9 = /* @__PURE__ */ function(_ExtensionParser) {
    _inheritsLoose$2(KHR_texture_transform, _ExtensionParser);
    function KHR_texture_transform() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_texture_transform.prototype;
    _proto.parseEngineResource = function parseEngineResource(schema, material, context) {
      var offset = schema.offset, rotation = schema.rotation, scale = schema.scale, texCoord = schema.texCoord;
      if (offset) {
        material.tilingOffset.z = offset[0];
        material.tilingOffset.w = offset[1];
      }
      if (scale) {
        material.tilingOffset.x = scale[0];
        material.tilingOffset.y = scale[1];
      }
      if (rotation) {
        miniprogram.Logger.warn("rotation in KHR_texture_transform is not supported now");
      }
      if (texCoord) {
        miniprogram.Logger.warn("texCoord in KHR_texture_transform is not supported now");
      }
    };
    return KHR_texture_transform;
  }(ExtensionParser)) || _class$9;
  var _dec$8, _class$8;
  _dec$8 = registerExtension("OASIS_materials_remap"), _dec$8(_class$8 = /* @__PURE__ */ function(_ExtensionParser) {
    _inheritsLoose$2(OasisMaterialsRemap, _ExtensionParser);
    function OasisMaterialsRemap() {
      return _ExtensionParser.apply(this, arguments) || this;
    }
    var _proto = OasisMaterialsRemap.prototype;
    _proto.createEngineResource = function createEngineResource(schema, context) {
      var engine = context.engine;
      return engine.resourceManager.getResourceByRef(schema);
    };
    return OasisMaterialsRemap;
  }(ExtensionParser)) || _class$8;
  var _dec$7, _class$7;
  _dec$7 = miniprogram.resourceLoader(miniprogram.AssetType.Material, ["json"]), _dec$7(_class$7 = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(MaterialLoader, _Loader);
    function MaterialLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = MaterialLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new miniprogram.AssetPromise(function(resolve, reject) {
        _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "json"
        })).then(function(json) {
          var engine = resourceManager.engine;
          var shader = json.shader, shaderData = json.shaderData, macros = json.macros, renderState = json.renderState;
          var material;
          switch (shader) {
            case "pbr":
              material = new miniprogram.PBRMaterial(engine);
              break;
            case "pbr-specular":
              material = new miniprogram.PBRSpecularMaterial(engine);
              break;
            case "unlit":
              material = new miniprogram.UnlitMaterial(engine);
              break;
            case "blinn-phong":
              material = new miniprogram.BlinnPhongMaterial(engine);
              break;
          }
          var texturePromises = new Array();
          var materialShaderData = material.shaderData;
          var _loop = function _loop2(_key3) {
            var _shaderData$_key = shaderData[_key3], type = _shaderData$_key.type, value2 = _shaderData$_key.value;
            switch (type) {
              case "Vector2":
                materialShaderData.setVector2(_key3, new miniprogram$1.Vector2(value2.x, value2.y));
                break;
              case "Vector3":
                materialShaderData.setVector3(_key3, new miniprogram$1.Vector3(value2.x, value2.y, value2.z));
                break;
              case "Vector4":
                materialShaderData.setVector4(_key3, new miniprogram$1.Vector4(value2.x, value2.y, value2.z, value2.w));
                break;
              case "Color":
                materialShaderData.setColor(_key3, new miniprogram$1.Color(value2.r, value2.g, value2.b, value2.a));
                break;
              case "Float":
                materialShaderData.setFloat(_key3, value2);
                break;
              case "Texture":
                texturePromises.push(resourceManager.getResourceByRef(value2).then(function(texture) {
                  materialShaderData.setTexture(_key3, texture);
                }));
                break;
            }
          };
          for (var _key in shaderData) {
            _loop(_key);
          }
          for (var i = 0, length2 = macros.length; i < length2; i++) {
            var _macros$i = macros[i], name = _macros$i.name, value = _macros$i.value;
            if (value == void 0) {
              materialShaderData.enableMacro(name);
            } else {
              materialShaderData.enableMacro(name, value);
            }
          }
          for (var _key2 in renderState) {
            material[_key2] = renderState[_key2];
          }
          Promise.all(texturePromises).then(function() {
            resolve(material);
          });
        });
      });
    };
    return MaterialLoader;
  }(miniprogram.Loader)) || _class$7;
  var BufferReader = /* @__PURE__ */ function() {
    function BufferReader2(buffer, byteOffset, byteLength, littleEndian) {
      if (byteOffset === void 0) {
        byteOffset = 0;
      }
      if (littleEndian === void 0) {
        littleEndian = true;
      }
      this.buffer = buffer;
      this._dataView = void 0;
      this._littleEndian = void 0;
      this._offset = void 0;
      this._dataView = new DataView(buffer);
      this._littleEndian = littleEndian;
      this._offset = byteOffset;
    }
    var _proto = BufferReader2.prototype;
    _proto.nextUint8 = function nextUint8() {
      var value = this._dataView.getUint8(this._offset);
      this._offset += 1;
      return value;
    };
    _proto.nextUint16 = function nextUint16() {
      var value = this._dataView.getUint16(this._offset, this._littleEndian);
      this._offset += 2;
      return value;
    };
    _proto.nextUint32 = function nextUint32() {
      var value = this._dataView.getUint32(this._offset, this._littleEndian);
      this._offset += 4;
      return value;
    };
    _proto.nextInt32 = function nextInt32() {
      var value = this._dataView.getInt32(this._offset, this._littleEndian);
      this._offset += 4;
      return value;
    };
    _proto.nextInt32Array = function nextInt32Array(len) {
      var value = new Int32Array(this.buffer, this._offset, len);
      this._offset += 4 * len;
      return value;
    };
    _proto.nextFloat32 = function nextFloat32() {
      var value = this._dataView.getFloat32(this._offset, this._littleEndian);
      this._offset += 4;
      return value;
    };
    _proto.nextFloat32Array = function nextFloat32Array(len) {
      var value = new Float32Array(this.buffer, this._offset, len);
      this._offset += 4 * len;
      return value;
    };
    _proto.nextUint32Array = function nextUint32Array(len) {
      var value = new Uint32Array(this.buffer, this._offset, len);
      this._offset += 4 * len;
      return value;
    };
    _proto.nextUint8Array = function nextUint8Array(len) {
      var value = new Uint8Array(this.buffer, this._offset, len);
      this._offset += len;
      return value;
    };
    _proto.nextUint64 = function nextUint64() {
      var left = this._dataView.getUint32(this._offset, this._littleEndian);
      var right = this._dataView.getUint32(this._offset + 4, this._littleEndian);
      var value = left + Math.pow(2, 32) * right;
      this._offset += 8;
      return value;
    };
    _proto.nextStr = function nextStr() {
      var strByteLength = this.nextUint16();
      var uint8Array = new Uint8Array(this.buffer, this._offset, strByteLength);
      this._offset += strByteLength;
      return GLTFUtil.decodeText(uint8Array);
    };
    _proto.nextImageData = function nextImageData(count) {
      return this.buffer.slice(this._offset);
    };
    _proto.nextImagesData = function nextImagesData(count) {
      var imagesLen = new Array(count);
      for (var i = 0; i < count; i++) {
        var len = this._dataView.getUint32(this._offset, this._littleEndian);
        imagesLen[i] = len;
        this._offset += 4;
      }
      var imagesData = [];
      for (var _i = 0; _i < count; _i++) {
        var _len = imagesLen[_i];
        var _buffer = this.buffer.slice(this._offset, this._offset + _len);
        this._offset += _len;
        imagesData.push(_buffer);
      }
      return imagesData;
    };
    _proto.skip = function skip(bytes) {
      this._offset += bytes;
      return this;
    };
    _proto.scan = function scan(maxByteLength, term) {
      if (term === void 0) {
        term = 0;
      }
      var byteOffset = this._offset;
      var byteLength = 0;
      while (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {
        byteLength++;
        this._offset++;
      }
      if (byteLength < maxByteLength)
        this._offset++;
      return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);
    };
    _createClass$2(BufferReader2, [{
      key: "offset",
      get: function get() {
        return this._offset;
      }
    }]);
    return BufferReader2;
  }();
  BufferReader.imageMapping = {
    0: "image/png",
    1: "image/jpg",
    2: "image/webp",
    3: "ktx"
  };
  var decoderMap = {};
  function decoder(type) {
    return function(target) {
      decoderMap[type] = target;
    };
  }
  var FileHeader = /* @__PURE__ */ function() {
    function FileHeader2() {
      this.totalLength = 0;
      this.version = 0;
      this.type = "";
      this.name = "";
      this.headerLength = 0;
    }
    FileHeader2.decode = function decode2(arrayBuffer) {
      var dataView = new DataView(arrayBuffer);
      var totalLen = dataView.getUint32(0, true);
      var fileVersion = dataView.getUint8(4);
      var typeLen = dataView.getUint16(5, true);
      var typeUint8Array = new Uint8Array(arrayBuffer, 7, typeLen);
      var nameLen = dataView.getUint16(7 + typeLen, true);
      var nameUint8Array = new Uint8Array(arrayBuffer, 9 + typeLen, nameLen);
      var name = GLTFUtil.decodeText(nameUint8Array);
      var type = GLTFUtil.decodeText(typeUint8Array);
      var header = new FileHeader2();
      header.totalLength = totalLen;
      header.name = name;
      header.type = type;
      header.version = fileVersion;
      header.headerLength = nameUint8Array.byteLength + typeUint8Array.byteLength + 9;
      return header;
    };
    _createClass$2(FileHeader2, [{
      key: "dataLength",
      get: function get() {
        return this.totalLength - this.headerLength;
      }
    }]);
    return FileHeader2;
  }();
  var _dec$6, _class$6;
  var MeshDecoder = (_dec$6 = decoder("Mesh"), _dec$6(_class$6 = /* @__PURE__ */ function() {
    function MeshDecoder2() {
    }
    MeshDecoder2.decode = function decode2(engine, bufferReader) {
      return new Promise(function(resolve) {
        var modelMesh = new miniprogram.ModelMesh(engine);
        var jsonDataString = bufferReader.nextStr();
        var encodedMeshData = JSON.parse(jsonDataString);
        var offset = Math.ceil(bufferReader.offset / 4) * 4;
        var float32Array = new Float32Array(bufferReader.buffer, encodedMeshData.positions.start + offset, (encodedMeshData.positions.end - encodedMeshData.positions.start) / 4);
        var vertexCount = float32Array.length / 3;
        var positions = float32ArrayToVector3(float32Array, vertexCount);
        modelMesh.setPositions(positions);
        if (encodedMeshData.normals) {
          var _float32Array = new Float32Array(bufferReader.buffer, encodedMeshData.normals.start + offset, (encodedMeshData.normals.end - encodedMeshData.normals.start) / 4);
          var normals = float32ArrayToVector3(_float32Array, vertexCount);
          modelMesh.setNormals(normals);
        }
        if (encodedMeshData.uvs) {
          var _float32Array2 = new Float32Array(bufferReader.buffer, encodedMeshData.uvs.start + offset, (encodedMeshData.uvs.end - encodedMeshData.uvs.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array2, vertexCount));
        }
        if (encodedMeshData.uv1) {
          var _float32Array3 = new Float32Array(bufferReader.buffer, encodedMeshData.uv1.start + offset, (encodedMeshData.uv1.end - encodedMeshData.uv1.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array3, vertexCount), 1);
        }
        if (encodedMeshData.uv2) {
          var _float32Array4 = new Float32Array(bufferReader.buffer, encodedMeshData.uv2.start + offset, (encodedMeshData.uv2.end - encodedMeshData.uv2.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array4, vertexCount), 2);
        }
        if (encodedMeshData.uv3) {
          var _float32Array5 = new Float32Array(bufferReader.buffer, encodedMeshData.uv3.start + offset, (encodedMeshData.uv3.end - encodedMeshData.uv3.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array5, vertexCount), 3);
        }
        if (encodedMeshData.uv4) {
          var _float32Array6 = new Float32Array(bufferReader.buffer, encodedMeshData.uv4.start + offset, (encodedMeshData.uv4.end - encodedMeshData.uv4.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array6, vertexCount), 4);
        }
        if (encodedMeshData.uv5) {
          var _float32Array7 = new Float32Array(bufferReader.buffer, encodedMeshData.uv5.start + offset, (encodedMeshData.uv5.end - encodedMeshData.uv5.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array7, vertexCount), 5);
        }
        if (encodedMeshData.uv6) {
          var _float32Array8 = new Float32Array(bufferReader.buffer, encodedMeshData.uv6.start + offset, (encodedMeshData.uv6.end - encodedMeshData.uv6.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array8, vertexCount), 6);
        }
        if (encodedMeshData.uv7) {
          var _float32Array9 = new Float32Array(bufferReader.buffer, encodedMeshData.uv7.start + offset, (encodedMeshData.uv7.end - encodedMeshData.uv7.start) / 4);
          modelMesh.setUVs(float32ArrayToVector2(_float32Array9, vertexCount), 7);
        }
        if (encodedMeshData.colors) {
          var _float32Array10 = new Float32Array(bufferReader.buffer, encodedMeshData.colors.start + offset, (encodedMeshData.colors.end - encodedMeshData.colors.start) / 4);
          modelMesh.setColors(float32ArrayToVColor(_float32Array10, vertexCount));
        }
        if (encodedMeshData.boneWeights) {
          var _float32Array11 = new Float32Array(bufferReader.buffer, encodedMeshData.boneWeights.start + offset, (encodedMeshData.boneWeights.end - encodedMeshData.boneWeights.start) / 4);
          modelMesh.setBoneWeights(float32ArrayToVector4(_float32Array11, vertexCount));
        }
        if (encodedMeshData.boneIndices) {
          var _float32Array12 = new Float32Array(bufferReader.buffer, encodedMeshData.boneIndices.start + offset, (encodedMeshData.boneIndices.end - encodedMeshData.boneIndices.start) / 4);
          modelMesh.setBoneIndices(float32ArrayToVector4(_float32Array12, vertexCount));
        }
        if (encodedMeshData.blendShapes) {
          encodedMeshData.blendShapes.forEach(function(blendShapeData) {
            var blendShape = new miniprogram.BlendShape(blendShapeData.name);
            blendShapeData.frames.forEach(function(frameData) {
              var positionArray = new Float32Array(bufferReader.buffer, frameData.deltaPosition.start + offset, (frameData.deltaPosition.end - frameData.deltaPosition.start) / 4);
              var count = positionArray.length / 3;
              var deltaPosition = float32ArrayToVector3(positionArray, count);
              if (frameData.deltaNormals) {
                var normalsArray = new Float32Array(bufferReader.buffer, frameData.deltaNormals.start + offset, (frameData.deltaNormals.end - frameData.deltaNormals.start) / 4);
                float32ArrayToVector3(normalsArray, count);
              }
              if (frameData.deltaTangents) {
                var tangentsArray = new Float32Array(bufferReader.buffer, frameData.deltaTangents.start + offset, (frameData.deltaTangents.end - frameData.deltaTangents.start) / 4);
                float32ArrayToVector4(tangentsArray, count);
              }
              blendShape.addFrame(frameData.weight, deltaPosition);
            });
            modelMesh.addBlendShape(blendShape);
          });
        }
        if (encodedMeshData.indices) {
          var indices = null;
          if (encodedMeshData.indices.type === 0) {
            indices = new Uint16Array(bufferReader.buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 2);
          } else {
            indices = new Uint32Array(bufferReader.buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 4);
          }
          modelMesh.setIndices(indices);
        }
        encodedMeshData.subMeshes.forEach(function(subMesh) {
          modelMesh.addSubMesh(subMesh);
        });
        modelMesh.uploadData(false);
        resolve(modelMesh);
      });
    };
    return MeshDecoder2;
  }()) || _class$6);
  function float32ArrayToVColor(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for (var i = 0; i < vertexCount; i++) {
      array[i] = new miniprogram$1.Color(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
    }
    return array;
  }
  function float32ArrayToVector4(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for (var i = 0; i < vertexCount; i++) {
      array[i] = new miniprogram$1.Vector4(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
    }
    return array;
  }
  function float32ArrayToVector3(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for (var i = 0; i < vertexCount; i++) {
      array[i] = new miniprogram$1.Vector3(float32Array[i * 3], float32Array[i * 3 + 1], float32Array[i * 3 + 2]);
    }
    return array;
  }
  function float32ArrayToVector2(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for (var i = 0; i < vertexCount; i++) {
      array[i] = new miniprogram$1.Vector2(float32Array[i * 2], float32Array[i * 2 + 1]);
    }
    return array;
  }
  var _dec$5, _class$5;
  var Texture2DDecoder = (_dec$5 = decoder("Texture2D"), _dec$5(_class$5 = /* @__PURE__ */ function() {
    function Texture2DDecoder2() {
    }
    Texture2DDecoder2.decode = function decode2(engine, bufferReader) {
      return new Promise(function(resolve, reject) {
        var objectId = bufferReader.nextStr();
        var mipmap = !!bufferReader.nextUint8();
        var filterMode = bufferReader.nextUint8();
        var anisoLevel = bufferReader.nextUint8();
        var wrapModeU = bufferReader.nextUint8();
        var wrapModeV = bufferReader.nextUint8();
        var format = bufferReader.nextUint8();
        var width = bufferReader.nextUint16();
        var height = bufferReader.nextUint16();
        var isPixelBuffer = bufferReader.nextUint8();
        var mipCount = bufferReader.nextUint8();
        var imagesData = bufferReader.nextImagesData(mipCount);
        var texture2D = new miniprogram.Texture2D(engine, width, height, format, mipmap);
        texture2D.filterMode = filterMode;
        texture2D.anisoLevel = anisoLevel;
        texture2D.wrapModeU = wrapModeU;
        texture2D.wrapModeV = wrapModeV;
        if (isPixelBuffer) {
          var pixelBuffer = new Uint8Array(imagesData[0]);
          texture2D.setPixelBuffer(pixelBuffer);
          if (mipmap) {
            texture2D.generateMipmaps();
            for (var i = 1; i < mipCount; i++) {
              var _pixelBuffer = new Uint8Array(imagesData[i]);
              texture2D.setPixelBuffer(_pixelBuffer, i);
            }
          }
          engine.resourceManager._objectPool[objectId] = texture2D;
          resolve(texture2D);
        } else {
          var blob = new miniprogramAdapter.window.Blob([imagesData[0]]);
          var img = new miniprogramAdapter.Image();
          img.onload = function() {
            texture2D.setImageSource(img);
            var completedCount = 0;
            var onComplete = function onComplete2() {
              completedCount++;
              if (completedCount >= mipCount) {
                resolve(texture2D);
              }
            };
            onComplete();
            if (mipmap) {
              texture2D.generateMipmaps();
              var _loop = function _loop2(_i2) {
                var blob2 = new miniprogramAdapter.window.Blob([imagesData[_i2]]);
                var img2 = new miniprogramAdapter.Image();
                img2.onload = function() {
                  texture2D.setImageSource(img2, _i2);
                  onComplete();
                };
                img2.src = miniprogramAdapter.URL.createObjectURL(blob2);
              };
              for (var _i = 1; _i < mipCount; _i++) {
                _loop(_i);
              }
            }
          };
          img.src = miniprogramAdapter.URL.createObjectURL(blob);
        }
      });
    };
    return Texture2DDecoder2;
  }()) || _class$5);
  var ReflectionParser = /* @__PURE__ */ function() {
    function ReflectionParser2() {
    }
    ReflectionParser2.parseEntity = function parseEntity(entityConfig, engine) {
      var _this = this;
      return ReflectionParser2.getEntityByConfig(entityConfig, engine).then(function(entity) {
        var _entityConfig$isActiv;
        entity.isActive = (_entityConfig$isActiv = entityConfig.isActive) != null ? _entityConfig$isActiv : true;
        var position = entityConfig.position, rotation = entityConfig.rotation, scale = entityConfig.scale;
        if (position) {
          entity.transform.setPosition(position.x, position.y, position.z);
        }
        if (rotation) {
          entity.transform.setRotation(rotation.x, rotation.y, rotation.z);
        }
        if (scale) {
          entity.transform.setScale(scale.x, scale.y, scale.z);
        }
        var promises = [];
        for (var i = 0; i < entityConfig.components.length; i++) {
          var componentConfig = entityConfig.components[i];
          var key = !componentConfig.refId ? componentConfig.class : componentConfig.refId;
          var component = void 0;
          if (key === "Animator") {
            component = entity.getComponent(miniprogram.Loader.getClass(key));
          }
          component = component || entity.addComponent(miniprogram.Loader.getClass(key));
          var promise = _this.parsePropsAndMethods(component, componentConfig, engine);
          promises.push(promise);
        }
        return Promise.all(promises).then(function() {
          return entity;
        });
      });
    };
    ReflectionParser2.getEntityByConfig = function getEntityByConfig(entityConfig, engine) {
      var assetRefId = entityConfig.assetRefId;
      if (assetRefId) {
        return engine.resourceManager.getResourceByRef({
          refId: assetRefId,
          key: entityConfig.key
        });
      } else {
        var entity = new miniprogram.Entity(engine, entityConfig.name);
        return Promise.resolve(entity);
      }
    };
    ReflectionParser2.parseClassObject = function parseClassObject(item, engine, resourceManager) {
      var _item$constructParams;
      if (resourceManager === void 0) {
        resourceManager = engine.resourceManager;
      }
      var Class = miniprogram.Loader.getClass(item.class);
      var params = (_item$constructParams = item.constructParams) != null ? _item$constructParams : [];
      var instance = _construct(Class, params);
      return this.parsePropsAndMethods(instance, item, engine, resourceManager);
    };
    ReflectionParser2.parseBasicType = function parseBasicType(value, engine, resourceManager) {
      var _this2 = this;
      if (resourceManager === void 0) {
        resourceManager = engine.resourceManager;
      }
      if (Array.isArray(value)) {
        return Promise.all(value.map(function(item) {
          return _this2.parseBasicType(item, engine, resourceManager);
        }));
      } else if (typeof value === "object" && value != null) {
        if (this._isClass(value)) {
          return this.parseClassObject(value, engine, resourceManager);
        } else if (this._isRef(value)) {
          return resourceManager.getResourceByRef(value);
        } else {
          return Promise.resolve(value);
        }
      } else {
        return Promise.resolve(value);
      }
    };
    ReflectionParser2.parsePropsAndMethods = function parsePropsAndMethods(instance, item, engine, resourceManager) {
      var _this3 = this;
      if (resourceManager === void 0) {
        resourceManager = engine.resourceManager;
      }
      var promises = [];
      if (item.methods) {
        for (var methodName in item.methods) {
          var methodParams = item.methods[methodName];
          for (var i = 0, count = methodParams.length; i < count; i++) {
            var params = methodParams[i];
            var promise = this.parseMethod(instance, methodName, params, engine, resourceManager);
            promises.push(promise);
          }
        }
      }
      if (item.props) {
        var _loop = function _loop2(key2) {
          var value = item.props[key2];
          var promise2 = _this3.parseBasicType(value, engine).then(function(v) {
            return instance[key2] = v;
          });
          promises.push(promise2);
        };
        for (var key in item.props) {
          _loop(key);
        }
      }
      return Promise.all(promises).then(function() {
        return instance;
      });
    };
    ReflectionParser2.parseMethod = function parseMethod(instance, methodName, methodParams, engine, resourceManager) {
      var _this4 = this;
      if (resourceManager === void 0) {
        resourceManager = engine.resourceManager;
      }
      return Promise.all(methodParams.map(function(param) {
        return _this4.parseBasicType(param, engine, resourceManager);
      })).then(function(result) {
        return instance[methodName].apply(instance, result);
      });
    };
    ReflectionParser2._isClass = function _isClass(value) {
      return value["class"] != void 0;
    };
    ReflectionParser2._isRef = function _isRef(value) {
      return value["refId"] != void 0;
    };
    return ReflectionParser2;
  }();
  var PrefabParser = /* @__PURE__ */ function() {
    function PrefabParser2(_engine) {
      this._engine = _engine;
    }
    var _proto = PrefabParser2.prototype;
    _proto.parse = function parse(data) {
      var entitiesMap = {};
      var entitiesConfigMap = {};
      var promises = [];
      var entitiesConfig = data.entities;
      for (var _iterator = _createForOfIteratorHelperLoose(entitiesConfig), _step; !(_step = _iterator()).done; ) {
        var entity = _step.value;
        entitiesConfigMap[entity.id] = entity;
        promises.push(ReflectionParser.parseEntity(entity, this._engine));
      }
      return Promise.all(promises).then(function(entities) {
        var rootId = entitiesConfig[0].id;
        entities.forEach(function(entity2, index) {
          entitiesMap[entitiesConfig[index].id] = entity2;
        });
        PrefabParser2.parseChildren(entitiesConfigMap, entitiesMap, rootId);
        return entitiesMap[rootId];
      });
    };
    PrefabParser2.parseChildren = function parseChildren(entitiesConfig, entities, parentId) {
      var children = entitiesConfig[parentId].children;
      if (children && children.length > 0) {
        var parent = entities[parentId];
        for (var i = 0; i < children.length; i++) {
          var childId = children[i];
          var entity = entities[childId];
          parent.addChild(entity);
          this.parseChildren(entitiesConfig, entities, childId);
        }
      }
    };
    return PrefabParser2;
  }();
  var SceneParser = /* @__PURE__ */ function() {
    function SceneParser2() {
    }
    SceneParser2.parse = function parse(engine, sceneData) {
      var scene = new miniprogram.Scene(engine);
      var entitiesMap = {};
      var entitiesConfigMap = {};
      var promises = [];
      var entitiesConfig = sceneData.entities;
      for (var _iterator = _createForOfIteratorHelperLoose(entitiesConfig), _step; !(_step = _iterator()).done; ) {
        var entity = _step.value;
        entitiesConfigMap[entity.id] = entity;
        promises.push(ReflectionParser.parseEntity(entity, engine));
      }
      return Promise.all(promises).then(function(entities) {
        var rootIds = [];
        entities.forEach(function(entity2, index) {
          entitiesMap[entitiesConfig[index].id] = entity2;
          if (!entitiesConfig[index].parent) {
            rootIds.push(entitiesConfig[index].id);
          }
        });
        for (var _i = 0, _rootIds = rootIds; _i < _rootIds.length; _i++) {
          var rootId = _rootIds[_i];
          PrefabParser.parseChildren(entitiesConfigMap, entitiesMap, rootId);
        }
        var rootEntities = rootIds.map(function(id) {
          return entitiesMap[id];
        });
        for (var i = 0; i < rootEntities.length; i++) {
          scene.addRootEntity(rootEntities[i]);
        }
        return scene;
      });
    };
    return SceneParser2;
  }();
  var _dec$4, _class$4;
  var MeshLoader = (_dec$4 = miniprogram.resourceLoader("Mesh", ["prefab"], true), _dec$4(_class$4 = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(MeshLoader2, _Loader);
    function MeshLoader2() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = MeshLoader2.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new miniprogram.AssetPromise(function(resolve, reject) {
        _this.request(item.url, {
          type: "arraybuffer"
        }).then(function(data) {
          decode(data, resourceManager.engine).then(function(mesh) {
            resolve(mesh);
          });
        });
      });
    };
    return MeshLoader2;
  }(miniprogram.Loader)) || _class$4);
  var _dec$3$1, _class$3$1;
  var EditorTextureLoader = (_dec$3$1 = miniprogram.resourceLoader("EditorTexture2D", ["prefab"], true), _dec$3$1(_class$3$1 = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(EditorTextureLoader2, _Loader);
    function EditorTextureLoader2() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = EditorTextureLoader2.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new miniprogram.AssetPromise(function(resolve) {
        _this.request(item.url, {
          type: "arraybuffer"
        }).then(function(data) {
          decode(data, resourceManager.engine).then(function(texture) {
            resolve(texture);
          });
        });
      });
    };
    return EditorTextureLoader2;
  }(miniprogram.Loader)) || _class$3$1);
  function decode(arrayBuffer, engine) {
    var header = FileHeader.decode(arrayBuffer);
    var bufferReader = new BufferReader(arrayBuffer, header.headerLength, header.dataLength);
    return decoderMap[header.type].decode(engine, bufferReader).then(function(object) {
      object.name = header.name;
      return object;
    });
  }
  var _dec$2$1, _class$2$1;
  _dec$2$1 = miniprogram.resourceLoader(miniprogram.AssetType.Mesh, ["mesh"]), _dec$2$1(_class$2$1 = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(MeshLoader2, _Loader);
    function MeshLoader2() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = MeshLoader2.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new miniprogram.AssetPromise(function(resolve) {
        _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "arraybuffer"
        })).then(function(data) {
          return decode(data, resourceManager.engine);
        }).then(function(mesh) {
          resolve(mesh);
        });
      });
    };
    return MeshLoader2;
  }(miniprogram.Loader)) || _class$2$1;
  var _dec$1$1, _class$1$1;
  _dec$1$1 = miniprogram.resourceLoader(miniprogram.AssetType.AnimatorController, ["json"], false), _dec$1$1(_class$1$1 = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(AnimatorControllerLoader, _Loader);
    function AnimatorControllerLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = AnimatorControllerLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      return new miniprogram.AssetPromise(function(resolve, reject) {
        _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "json"
        })).then(/* @__PURE__ */ function() {
          var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(data) {
            var animatorController, layers, promises;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    animatorController = new miniprogram.AnimatorController();
                    layers = data.layers;
                    promises = [];
                    layers.forEach(function(layerData, layerIndex) {
                      var name = layerData.name, blendingMode = layerData.blendingMode, weight = layerData.weight, stateMachineData = layerData.stateMachine;
                      var layer = new miniprogram.AnimatorControllerLayer(name);
                      layer.blendingMode = blendingMode;
                      layer.weight = weight;
                      if (stateMachineData) {
                        var states = stateMachineData.states;
                        var stateMachine = layer.stateMachine = new miniprogram.AnimatorStateMachine();
                        states.forEach(function(stateData, stateIndex) {
                          var name2 = stateData.name, speed = stateData.speed, wrapMode = stateData.wrapMode, clipStartNormalizedTime = stateData.clipStartNormalizedTime, clipEndNormalizedTime = stateData.clipEndNormalizedTime;
                          stateData.isDefaultState;
                          var clipData = stateData.clip;
                          var state = stateMachine.addState(name2);
                          state.speed = speed;
                          state.wrapMode = wrapMode;
                          state.clipStartTime = clipStartNormalizedTime;
                          state.clipEndTime = clipEndNormalizedTime;
                          if (clipData) {
                            promises.push(new Promise(/* @__PURE__ */ function() {
                              var _ref2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(resolve2) {
                                return _regeneratorRuntime().wrap(function _callee$(_context) {
                                  while (1) {
                                    switch (_context.prev = _context.next) {
                                      case 0:
                                        _context.t0 = resolve2;
                                        _context.t1 = layerIndex;
                                        _context.t2 = stateIndex;
                                        _context.next = 5;
                                        return resourceManager.getResourceByRef(clipData);
                                      case 5:
                                        _context.t3 = _context.sent;
                                        _context.t4 = {
                                          layerIndex: _context.t1,
                                          stateIndex: _context.t2,
                                          clip: _context.t3
                                        };
                                        (0, _context.t0)(_context.t4);
                                      case 8:
                                      case "end":
                                        return _context.stop();
                                    }
                                  }
                                }, _callee);
                              }));
                              return function(_x2) {
                                return _ref2.apply(this, arguments);
                              };
                            }()));
                          }
                        });
                        states.forEach(function(stateData) {
                          var name2 = stateData.name, transitions = stateData.transitions;
                          transitions.forEach(function(transitionData) {
                            var targetStateName = transitionData.targetStateName, duration = transitionData.duration, offset = transitionData.offset, exitTime = transitionData.exitTime;
                            var sourceState = stateMachine.findStateByName(name2);
                            var destState = stateMachine.findStateByName(targetStateName);
                            var transition = new miniprogram.AnimatorStateTransition();
                            transition.destinationState = destState;
                            transition.duration = duration;
                            transition.exitTime = exitTime;
                            transition.offset = offset;
                            sourceState.addTransition(transition);
                          });
                        });
                      }
                      animatorController.addLayer(layer);
                    });
                    Promise.all(promises).then(function(clipData) {
                      clipData.forEach(function(data2) {
                        var layerIndex = data2.layerIndex, stateIndex = data2.stateIndex, clip = data2.clip;
                        animatorController.layers[layerIndex].stateMachine.states[stateIndex].clip = clip;
                      });
                      resolve(animatorController);
                    });
                  case 5:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));
          return function(_x) {
            return _ref.apply(this, arguments);
          };
        }());
      });
    };
    return AnimatorControllerLoader;
  }(miniprogram.Loader)) || _class$1$1;
  var _dec$s, _class$s;
  _dec$s = miniprogram.resourceLoader(miniprogram.AssetType.Scene, ["prefab"], true), _dec$s(_class$s = /* @__PURE__ */ function(_Loader) {
    _inheritsLoose$2(SceneLoader, _Loader);
    function SceneLoader() {
      return _Loader.apply(this, arguments) || this;
    }
    var _proto = SceneLoader.prototype;
    _proto.load = function load(item, resourceManager) {
      var _this = this;
      var engine = resourceManager.engine;
      return new miniprogram.AssetPromise(function(resolve, reject) {
        return _this.request(item.url, {
          type: "json"
        }).then(function(data) {
          engine.resourceManager.initVirtualResources(data.files);
          return SceneParser.parse(engine, data).then(function(scene) {
            var ambient = data.scene.ambient;
            var ambientLightPromise = Promise.resolve();
            if (ambient.ambientLight) {
              ambientLightPromise = resourceManager.getResourceByRef(data.scene.ambient.ambientLight).then(function(light) {
                scene.ambientLight = light;
                scene.ambientLight.diffuseIntensity = ambient.diffuseIntensity;
                scene.ambientLight.specularIntensity = ambient.specularIntensity;
              });
            }
            var background = data.scene.background;
            scene.background.mode = background.mode;
            var backgroundPromise = Promise.resolve();
            switch (scene.background.mode) {
              case miniprogram.BackgroundMode.SolidColor:
                scene.background.solidColor.copyFrom(background.color);
                break;
              case miniprogram.BackgroundMode.Sky:
                if (background.sky) {
                  backgroundPromise = resourceManager.getResourceByRef(background.sky).then(function(light) {
                    var sky = scene.background.sky;
                    var skyMaterial = new miniprogram.SkyBoxMaterial(engine);
                    skyMaterial.textureCubeMap = light.specularTexture;
                    skyMaterial.textureDecodeRGBM = true;
                    sky.material = skyMaterial;
                    sky.mesh = miniprogram.PrimitiveMesh.createCuboid(engine, 1, 1, 1);
                  });
                }
                break;
              case miniprogram.BackgroundMode.Texture:
                if (background.texture) {
                  backgroundPromise = resourceManager.getResourceByRef(background.texture).then(function(texture) {
                    scene.background.texture = texture;
                  });
                }
                break;
            }
            return Promise.all([ambientLightPromise, backgroundPromise]).then(function() {
              resolve(scene);
            });
          });
        }).catch(reject);
      });
    };
    return SceneLoader;
  }(miniprogram.Loader)) || _class$s;
  miniprogram$7.EditorTextureLoader = EditorTextureLoader;
  miniprogram$7.GLTFResource = GLTFResource;
  miniprogram$7.MeshDecoder = MeshDecoder;
  miniprogram$7.MeshLoader = MeshLoader;
  miniprogram$7.PrefabParser = PrefabParser;
  miniprogram$7.ReflectionParser = ReflectionParser;
  miniprogram$7.SceneParser = SceneParser;
  miniprogram$7.Texture2DDecoder = Texture2DDecoder;
  miniprogram$7.decode = decode;
  miniprogram$7.parseSingleKTX = parseSingleKTX;
  (function(exports3) {
    Object.defineProperty(exports3, "__esModule", { value: true });
    var CoreObjects = miniprogram$9;
    var miniprogram2 = miniprogram$7;
    var miniprogram$12 = miniprogram$8;
    var miniprogram$22 = miniprogram$6;
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var CoreObjects__namespace = /* @__PURE__ */ _interopNamespace(CoreObjects);
    var version = "0.8.3";
    console.log("oasis engine version: " + version);
    for (var key in CoreObjects__namespace) {
      CoreObjects.Loader.registerClass(key, CoreObjects__namespace[key]);
    }
    exports3.version = version;
    Object.keys(CoreObjects).forEach(function(k) {
      if (k !== "default" && !exports3.hasOwnProperty(k))
        Object.defineProperty(exports3, k, {
          enumerable: true,
          get: function() {
            return CoreObjects[k];
          }
        });
    });
    Object.keys(miniprogram2).forEach(function(k) {
      if (k !== "default" && !exports3.hasOwnProperty(k))
        Object.defineProperty(exports3, k, {
          enumerable: true,
          get: function() {
            return miniprogram2[k];
          }
        });
    });
    Object.keys(miniprogram$12).forEach(function(k) {
      if (k !== "default" && !exports3.hasOwnProperty(k))
        Object.defineProperty(exports3, k, {
          enumerable: true,
          get: function() {
            return miniprogram$12[k];
          }
        });
    });
    Object.keys(miniprogram$22).forEach(function(k) {
      if (k !== "default" && !exports3.hasOwnProperty(k))
        Object.defineProperty(exports3, k, {
          enumerable: true,
          get: function() {
            return miniprogram$22[k];
          }
        });
    });
  })(miniprogram$a);
  class MiniAdapter {
    static init(canvas) {
      this.canvas = canvas;
      const info = this.getSystemInfoSync();
      this.isIOS = info.platform === "iOS";
      this.phoneModel = info.model;
      my.setKeepScreenOn({ keepScreenOn: true });
    }
    static getStorage(key, succFun, failFun) {
      my.getStorage({
        key,
        success: function(res) {
          console.log("\u8BF7\u6C42\u7F13\u5B58\u6570\u636Esuccess:", res);
          succFun && succFun(res.data);
        },
        fail: function(res) {
          console.log("\u8BF7\u6C42\u7F13\u5B58\u6570\u636Efail:", res);
          failFun && failFun(res);
        }
      });
    }
    static setStorage(key, data, success, fail) {
      my.setStorage({
        key,
        data,
        success,
        fail
      });
    }
    static toast(content, succ) {
      my.alert({
        content,
        success: succ
      });
    }
    static getSystemInfoSync() {
      return my.getSystemInfoSync();
    }
  }
  __publicField(MiniAdapter, "canvas");
  __publicField(MiniAdapter, "isIOS", false);
  __publicField(MiniAdapter, "phoneModel");
  function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties$1(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _inheritsLoose$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$1(subClass, superClass);
  }
  function _setPrototypeOf$1(o, p) {
    _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf$1(o, p);
  }
  var ESP$1 = miniprogram$a.MathUtil.zeroTolerance;
  var Spherical = /* @__PURE__ */ function() {
    function Spherical2(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      this.radius = radius !== void 0 ? radius : 1;
      this.phi = phi !== void 0 ? phi : 0;
      this.theta = theta !== void 0 ? theta : 0;
    }
    var _proto = Spherical2.prototype;
    _proto.set = function set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    };
    _proto.makeSafe = function makeSafe() {
      this.phi = miniprogram$a.MathUtil.clamp(this.phi, ESP$1, Math.PI - ESP$1);
      return this;
    };
    _proto.setFromVec3 = function setFromVec3(value) {
      this.radius = value.length();
      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(value.x, value.z);
        this.phi = Math.acos(miniprogram$a.MathUtil.clamp(value.y / this.radius, -1, 1));
      }
      return this;
    };
    _proto.setToVec3 = function setToVec3(value) {
      var radius = this.radius, phi = this.phi, theta = this.theta;
      var sinPhiRadius = Math.sin(phi) * radius;
      value.set(sinPhiRadius * Math.sin(theta), radius * Math.cos(phi), sinPhiRadius * Math.cos(theta));
      return this;
    };
    return Spherical2;
  }();
  miniprogram$a.MathUtil.zeroTolerance;
  var ControlHandlerType;
  (function(ControlHandlerType2) {
    ControlHandlerType2[ControlHandlerType2["None"] = 0] = "None";
    ControlHandlerType2[ControlHandlerType2["ROTATE"] = 1] = "ROTATE";
    ControlHandlerType2[ControlHandlerType2["ZOOM"] = 2] = "ZOOM";
    ControlHandlerType2[ControlHandlerType2["PAN"] = 4] = "PAN";
    ControlHandlerType2[ControlHandlerType2["All"] = 7] = "All";
  })(ControlHandlerType || (ControlHandlerType = {}));
  function StaticInterfaceImplement$1() {
    return function(constructor) {
    };
  }
  var _dec$2, _class$2;
  var ControlKeyboard = (_dec$2 = StaticInterfaceImplement$1(), _dec$2(_class$2 = /* @__PURE__ */ function() {
    function ControlKeyboard2() {
    }
    ControlKeyboard2.onUpdateHandler = function onUpdateHandler(input) {
      if (input.isKeyHeldDown(miniprogram$a.Keys.ArrowLeft) || input.isKeyHeldDown(miniprogram$a.Keys.ArrowRight) || input.isKeyHeldDown(miniprogram$a.Keys.ArrowUp) || input.isKeyHeldDown(miniprogram$a.Keys.ArrowDown)) {
        return ControlHandlerType.PAN;
      } else {
        return ControlHandlerType.None;
      }
    };
    ControlKeyboard2.onUpdateDelta = function onUpdateDelta(control, outDelta) {
      var keyPanSpeed = control.keyPanSpeed, input = control.input;
      outDelta.x = outDelta.y = 0;
      if (input.isKeyHeldDown(miniprogram$a.Keys.ArrowLeft)) {
        outDelta.x += keyPanSpeed;
      }
      if (input.isKeyHeldDown(miniprogram$a.Keys.ArrowRight)) {
        outDelta.x -= keyPanSpeed;
      }
      if (input.isKeyHeldDown(miniprogram$a.Keys.ArrowUp)) {
        outDelta.y += keyPanSpeed;
      }
      if (input.isKeyHeldDown(miniprogram$a.Keys.ArrowDown)) {
        outDelta.y -= keyPanSpeed;
      }
    };
    return ControlKeyboard2;
  }()) || _class$2);
  var _dec$1, _class$1, _class2;
  var DeltaType;
  (function(DeltaType2) {
    DeltaType2[DeltaType2["Moving"] = 0] = "Moving";
    DeltaType2[DeltaType2["Distance"] = 1] = "Distance";
  })(DeltaType || (DeltaType = {}));
  var ControlPointer = (_dec$1 = StaticInterfaceImplement$1(), _dec$1(_class$1 = (_class2 = /* @__PURE__ */ function() {
    function ControlPointer2() {
    }
    ControlPointer2.onUpdateHandler = function onUpdateHandler(input) {
      ++this._frameIndex;
      var pointers = input.pointers;
      switch (pointers.length) {
        case 1:
          if (input.isPointerHeldDown(miniprogram$a.PointerButton.Secondary)) {
            this._updateType(ControlHandlerType.PAN, DeltaType.Moving);
          } else if (input.isPointerHeldDown(miniprogram$a.PointerButton.Auxiliary)) {
            this._updateType(ControlHandlerType.ZOOM, DeltaType.Moving);
          } else if (input.isPointerHeldDown(miniprogram$a.PointerButton.Primary)) {
            this._updateType(ControlHandlerType.ROTATE, DeltaType.Moving);
          } else {
            if (input.pointerMovingDelta.x !== 0 && input.pointerMovingDelta.y !== 0) {
              if (input.isPointerUp(miniprogram$a.PointerButton.Secondary)) {
                this._updateType(ControlHandlerType.PAN, DeltaType.Moving);
              } else if (input.isPointerUp(miniprogram$a.PointerButton.Auxiliary)) {
                this._updateType(ControlHandlerType.ZOOM, DeltaType.Moving);
              } else if (input.isPointerUp(miniprogram$a.PointerButton.Primary)) {
                this._updateType(ControlHandlerType.ROTATE, DeltaType.Moving);
              } else {
                this._updateType(ControlHandlerType.None, DeltaType.Moving);
              }
            } else {
              this._updateType(ControlHandlerType.None, DeltaType.Moving);
            }
          }
          break;
        case 2:
          this._updateType(ControlHandlerType.ZOOM, DeltaType.Distance);
          break;
        case 3:
          this._updateType(ControlHandlerType.PAN, DeltaType.Moving);
          break;
        default:
          this._updateType(ControlHandlerType.None, DeltaType.Moving);
          break;
      }
      return this._handlerType;
    };
    ControlPointer2.onUpdateDelta = function onUpdateDelta(control, outDelta) {
      var frameIndex = this._frameIndex;
      switch (this._deltaType) {
        case DeltaType.Moving:
          if (this._lastUsefulFrameIndex === frameIndex - 1) {
            var pointerMovingDelta = control.input.pointerMovingDelta;
            outDelta.x = pointerMovingDelta.x;
            outDelta.y = pointerMovingDelta.y;
          } else {
            outDelta.x = 0;
            outDelta.y = 0;
          }
          break;
        case DeltaType.Distance:
          var pointers = control.input.pointers;
          var pointer1 = pointers[0];
          var pointer2 = pointers[1];
          var curDistance = miniprogram$a.Vector2.distance(pointer1.position, pointer2.position);
          if (this._lastUsefulFrameIndex === frameIndex - 1) {
            outDelta.set(0, this._distanceOfPointers - curDistance, 0);
          } else {
            outDelta.set(0, 0, 0);
          }
          this._distanceOfPointers = curDistance;
          break;
      }
      this._lastUsefulFrameIndex = frameIndex;
    };
    ControlPointer2._updateType = function _updateType(handlerType, deltaType) {
      if (this._handlerType !== handlerType || this._deltaType !== deltaType) {
        this._handlerType = handlerType;
        this._deltaType = deltaType;
        this._lastUsefulFrameIndex = -1;
      }
    };
    return ControlPointer2;
  }(), _class2._deltaType = DeltaType.Moving, _class2._handlerType = ControlHandlerType.None, _class2._frameIndex = 0, _class2._lastUsefulFrameIndex = -1, _class2._distanceOfPointers = 0, _class2)) || _class$1);
  var _dec$3, _class$3;
  var ControlWheel = (_dec$3 = StaticInterfaceImplement$1(), _dec$3(_class$3 = /* @__PURE__ */ function() {
    function ControlWheel2() {
    }
    ControlWheel2.onUpdateHandler = function onUpdateHandler(input) {
      var wheelDelta = input.wheelDelta;
      if (wheelDelta.x === 0 && wheelDelta.y === 0 && wheelDelta.z === 0) {
        return ControlHandlerType.None;
      } else {
        return ControlHandlerType.ZOOM;
      }
    };
    ControlWheel2.onUpdateDelta = function onUpdateDelta(control, outDelta) {
      outDelta.copyFrom(control.input.wheelDelta);
    };
    return ControlWheel2;
  }()) || _class$3);
  var OrbitControl = /* @__PURE__ */ function(_Script) {
    _inheritsLoose$1(OrbitControl2, _Script);
    function OrbitControl2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _Script.call.apply(_Script, [this].concat(args)) || this;
      _this.canvas = void 0;
      _this.input = void 0;
      _this.inputDevices = [ControlKeyboard, ControlPointer, ControlWheel];
      _this.camera = void 0;
      _this.cameraTransform = void 0;
      _this.target = new miniprogram$a.Vector3();
      _this.up = new miniprogram$a.Vector3(0, 1, 0);
      _this.autoRotate = false;
      _this.autoRotateSpeed = Math.PI;
      _this.enableDamping = true;
      _this.rotateSpeed = 1;
      _this.zoomSpeed = 1;
      _this.keyPanSpeed = 7;
      _this.dampingFactor = 0.1;
      _this.zoomFactor = 0.2;
      _this.minDistance = 0.1;
      _this.maxDistance = Infinity;
      _this.minZoom = 0;
      _this.maxZoom = Infinity;
      _this.minPolarAngle = 0;
      _this.maxPolarAngle = Math.PI;
      _this.minAzimuthAngle = -Infinity;
      _this.maxAzimuthAngle = Infinity;
      _this._enableKeys = true;
      _this._spherical = new Spherical();
      _this._sphericalDelta = new Spherical();
      _this._sphericalDump = new Spherical();
      _this._zoomFrag = 0;
      _this._scale = 1;
      _this._panOffset = new miniprogram$a.Vector3();
      _this._tempVec3 = new miniprogram$a.Vector3();
      _this._enableHandler = ControlHandlerType.All;
      return _this;
    }
    var _proto = OrbitControl2.prototype;
    _proto.onAwake = function onAwake() {
      var engine = this.engine, entity = this.entity;
      this.canvas = engine.canvas;
      this.input = engine.inputManager;
      this.camera = entity.getComponent(miniprogram$a.Camera);
      this.cameraTransform = entity.transform;
    };
    _proto.onUpdate = function onUpdate(deltaTime) {
      this._updateInputDelta(deltaTime);
      this._updateTransform();
    };
    _proto._updateInputDelta = function _updateInputDelta(deltaTime) {
      var curHandlerType = ControlHandlerType.None;
      var delta = this._tempVec3, enableHandler = this._enableHandler;
      var inputDevices = this.inputDevices, input = this.input;
      for (var i = inputDevices.length - 1; i >= 0; i--) {
        var handler = inputDevices[i];
        var handlerType = handler.onUpdateHandler(input);
        if (handlerType & enableHandler) {
          curHandlerType |= handlerType;
          handler.onUpdateDelta(this, delta);
          switch (handlerType) {
            case ControlHandlerType.ROTATE:
              this._rotate(delta);
              break;
            case ControlHandlerType.ZOOM:
              this._zoom(delta);
              break;
            case ControlHandlerType.PAN:
              this._pan(delta);
              break;
          }
        }
      }
      var _sphericalDump = this._sphericalDump, _sphericalDelta = this._sphericalDelta;
      if (this.enableDamping) {
        if (enableHandler & ControlHandlerType.ZOOM && curHandlerType ^ ControlHandlerType.ZOOM) {
          this._zoomFrag *= 1 - this.zoomFactor;
        }
        if (enableHandler & ControlHandlerType.ROTATE && curHandlerType ^ ControlHandlerType.ROTATE) {
          _sphericalDelta.theta = _sphericalDump.theta *= 1 - this.dampingFactor;
          _sphericalDelta.phi = _sphericalDump.phi *= 1 - this.dampingFactor;
        }
      }
      if (curHandlerType === ControlHandlerType.None && this.autoRotate) {
        var rotateAngle = this.autoRotateSpeed / 1e3 * deltaTime;
        _sphericalDelta.theta -= rotateAngle;
      }
    };
    _proto._rotate = function _rotate(delta) {
      var radianLeft = 2 * Math.PI * delta.x / this.canvas.width * this.rotateSpeed;
      this._sphericalDelta.theta -= radianLeft;
      var radianUp = 2 * Math.PI * delta.y / this.canvas.height * this.rotateSpeed;
      this._sphericalDelta.phi -= radianUp;
      if (this.enableDamping) {
        this._sphericalDump.theta = -radianLeft;
        this._sphericalDump.phi = -radianUp;
      }
    };
    _proto._zoom = function _zoom(delta) {
      if (delta.y > 0) {
        this._scale /= Math.pow(0.95, this.zoomSpeed);
      } else if (delta.y < 0) {
        this._scale *= Math.pow(0.95, this.zoomSpeed);
      }
    };
    _proto._pan = function _pan(delta) {
      var cameraTransform = this.cameraTransform;
      var elements = cameraTransform.worldMatrix.elements;
      var height = this.canvas.height;
      var targetDistance = miniprogram$a.Vector3.distance(cameraTransform.position, this.target) * (this.camera.fieldOfView / 2) * (Math.PI / 180);
      var distanceLeft = -2 * delta.x * (targetDistance / height);
      var distanceUp = 2 * delta.y * (targetDistance / height);
      this._panOffset.x += elements[0] * distanceLeft + elements[4] * distanceUp;
      this._panOffset.y += elements[1] * distanceLeft + elements[5] * distanceUp;
      this._panOffset.z += elements[2] * distanceLeft + elements[6] * distanceUp;
    };
    _proto._updateTransform = function _updateTransform() {
      var cameraTransform = this.cameraTransform, target = this.target, _tempVec3 = this._tempVec3, _spherical = this._spherical, _sphericalDelta = this._sphericalDelta, _panOffset = this._panOffset;
      miniprogram$a.Vector3.subtract(cameraTransform.position, target, _tempVec3);
      _spherical.setFromVec3(_tempVec3);
      _spherical.theta += _sphericalDelta.theta;
      _spherical.phi += _sphericalDelta.phi;
      _spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, _spherical.theta));
      _spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, _spherical.phi));
      _spherical.makeSafe();
      if (this._scale !== 1) {
        this._zoomFrag = _spherical.radius * (this._scale - 1);
      }
      _spherical.radius += this._zoomFrag;
      _spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, _spherical.radius));
      _spherical.setToVec3(_tempVec3);
      miniprogram$a.Vector3.add(target.add(_panOffset), _tempVec3, cameraTransform.position);
      cameraTransform.lookAt(target, this.up);
      this._zoomFrag = 0;
      this._scale = 1;
      _sphericalDelta.set(0, 0, 0);
      _panOffset.set(0, 0, 0);
    };
    _createClass$1(OrbitControl2, [{
      key: "enableKeys",
      get: function get() {
        return this._enableKeys;
      },
      set: function set(value) {
        if (this._enableKeys !== value) {
          this._enableKeys = value;
          var inputDevices = this.inputDevices;
          if (value) {
            inputDevices.push(ControlKeyboard);
          } else {
            for (var i = inputDevices.length - 1; i >= 0; i--) {
              if (inputDevices[i] === ControlKeyboard) {
                inputDevices.splice(i, 1);
                break;
              }
            }
          }
        }
      }
    }, {
      key: "enableRotate",
      get: function get() {
        return (this._enableHandler & ControlHandlerType.ROTATE) !== 0;
      },
      set: function set(value) {
        if (value) {
          this._enableHandler |= ControlHandlerType.ROTATE;
        } else {
          this._enableHandler &= ~ControlHandlerType.ROTATE;
        }
      }
    }, {
      key: "enableZoom",
      get: function get() {
        return (this._enableHandler & ControlHandlerType.ZOOM) !== 0;
      },
      set: function set(value) {
        if (value) {
          this._enableHandler |= ControlHandlerType.ZOOM;
        } else {
          this._enableHandler &= ~ControlHandlerType.ZOOM;
        }
      }
    }, {
      key: "enablePan",
      get: function get() {
        return (this._enableHandler & ControlHandlerType.PAN) !== 0;
      },
      set: function set(value) {
        if (value) {
          this._enableHandler |= ControlHandlerType.PAN;
        } else {
          this._enableHandler &= ~ControlHandlerType.PAN;
        }
      }
    }]);
    return OrbitControl2;
  }(miniprogram$a.Script);
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  function removeFromArray(array, item) {
    var index = array.indexOf(item);
    if (index < 0) {
      return false;
    }
    var last = array.length - 1;
    if (index !== last) {
      array[index] = array[last];
    }
    array.length--;
    return true;
  }
  var LiteUpdateFlag = /* @__PURE__ */ function() {
    function LiteUpdateFlag2(_flags) {
      if (_flags === void 0) {
        _flags = [];
      }
      this._flags = _flags;
      this.flag = true;
      this._flags.push(this);
    }
    var _proto = LiteUpdateFlag2.prototype;
    _proto.destroy = function destroy() {
      removeFromArray(this._flags, this);
      this._flags = null;
    };
    return LiteUpdateFlag2;
  }();
  var LiteUpdateFlagManager = /* @__PURE__ */ function() {
    function LiteUpdateFlagManager2() {
      this._updateFlags = [];
    }
    var _proto = LiteUpdateFlagManager2.prototype;
    _proto.register = function register() {
      return new LiteUpdateFlag(this._updateFlags);
    };
    _proto.distribute = function distribute() {
      var updateFlags = this._updateFlags;
      for (var i = updateFlags.length - 1; i >= 0; i--) {
        updateFlags[i].flag = true;
      }
    };
    return LiteUpdateFlagManager2;
  }();
  var LiteColliderShape = /* @__PURE__ */ function() {
    function LiteColliderShape2() {
      this._id = void 0;
      this._collider = void 0;
      this._transform = new LiteTransform();
      this._invModelMatrix = new miniprogram$a.Matrix();
      this._inverseWorldMatFlag = void 0;
      this._transform.owner = this;
      this._inverseWorldMatFlag = this._transform.registerWorldChangeFlag();
    }
    var _proto = LiteColliderShape2.prototype;
    _proto.setPosition = function setPosition(position) {
      this._transform.setPosition(position.x, position.y, position.z);
    };
    _proto.setContactOffset = function setContactOffset(offset) {
      console.log("Physics-lite don't support setContactOffset. Use Physics-PhysX instead!");
    };
    _proto.setMaterial = function setMaterial(material) {
      console.log("Physics-lite don't support setMaterial. Use Physics-PhysX instead!");
    };
    _proto.setUniqueID = function setUniqueID(id) {
      this._id = id;
    };
    _proto.setIsTrigger = function setIsTrigger(value) {
      console.log("Physics-lite don't support setIsTrigger. Use Physics-PhysX instead!");
    };
    _proto.setIsSceneQuery = function setIsSceneQuery(value) {
      console.log("Physics-lite don't support setIsSceneQuery. Use Physics-PhysX instead!");
    };
    _proto.destroy = function destroy() {
    };
    _proto._updateHitResult = function _updateHitResult(ray, rayDistance, outHit, origin, isWorldRay) {
      if (isWorldRay === void 0) {
        isWorldRay = false;
      }
      var hitPoint = LiteColliderShape2._tempPoint;
      ray.getPoint(rayDistance, hitPoint);
      if (!isWorldRay) {
        miniprogram$a.Vector3.transformCoordinate(hitPoint, this._transform.worldMatrix, hitPoint);
      }
      var distance = miniprogram$a.Vector3.distance(origin, hitPoint);
      if (distance < outHit.distance) {
        outHit.point.copyFrom(hitPoint);
        outHit.distance = distance;
        outHit.shapeID = this._id;
      }
    };
    _proto._getLocalRay = function _getLocalRay(ray) {
      var worldToLocal = this._getInvModelMatrix();
      var outRay = LiteColliderShape2._ray;
      miniprogram$a.Vector3.transformCoordinate(ray.origin, worldToLocal, outRay.origin);
      miniprogram$a.Vector3.transformNormal(ray.direction, worldToLocal, outRay.direction);
      outRay.direction.normalize();
      return outRay;
    };
    _proto._getInvModelMatrix = function _getInvModelMatrix() {
      if (this._inverseWorldMatFlag.flag) {
        miniprogram$a.Matrix.invert(this._transform.worldMatrix, this._invModelMatrix);
        this._inverseWorldMatFlag.flag = false;
      }
      return this._invModelMatrix;
    };
    return LiteColliderShape2;
  }();
  LiteColliderShape._ray = new miniprogram$a.Ray();
  LiteColliderShape._tempPoint = new miniprogram$a.Vector3();
  var LiteTransform = /* @__PURE__ */ function() {
    function LiteTransform2() {
      this._position = new miniprogram$a.Vector3();
      this._rotation = new miniprogram$a.Vector3();
      this._rotationQuaternion = new miniprogram$a.Quaternion();
      this._scale = new miniprogram$a.Vector3(1, 1, 1);
      this._worldRotationQuaternion = new miniprogram$a.Quaternion();
      this._localMatrix = new miniprogram$a.Matrix();
      this._worldMatrix = new miniprogram$a.Matrix();
      this._updateFlagManager = new LiteUpdateFlagManager();
      this._isParentDirty = true;
      this._parentTransformCache = null;
      this._dirtyFlag = TransformFlag.WmWpWeWqWs;
      this._owner = void 0;
    }
    var _proto = LiteTransform2.prototype;
    _proto.setPosition = function setPosition(x, y, z) {
      this._position.set(x, y, z);
      this.position = this._position;
    };
    _proto.setRotationQuaternion = function setRotationQuaternion(x, y, z, w) {
      this._rotationQuaternion.set(x, y, z, w);
      this.rotationQuaternion = this._rotationQuaternion;
    };
    _proto.setScale = function setScale(x, y, z) {
      this._scale.set(x, y, z);
      this.scale = this._scale;
    };
    _proto.registerWorldChangeFlag = function registerWorldChangeFlag() {
      return this._updateFlagManager.register();
    };
    _proto._updateWorldPositionFlag = function _updateWorldPositionFlag() {
      if (!this._isContainDirtyFlags(TransformFlag.WmWp)) {
        this._worldAssociatedChange(TransformFlag.WmWp);
        if (this._owner instanceof LiteCollider) {
          var shapes = this._owner._shapes;
          for (var i = 0, n = shapes.length; i < n; i++) {
            shapes[i]._transform._updateWorldPositionFlag();
          }
        }
      }
    };
    _proto._updateWorldRotationFlag = function _updateWorldRotationFlag() {
      if (!this._isContainDirtyFlags(TransformFlag.WmWeWq)) {
        this._worldAssociatedChange(TransformFlag.WmWeWq);
        if (this._owner instanceof LiteCollider) {
          var shapes = this._owner._shapes;
          for (var i = 0, n = shapes.length; i < n; i++) {
            shapes[i]._transform._updateWorldRotationFlag();
          }
        }
      }
    };
    _proto._updateWorldScaleFlag = function _updateWorldScaleFlag() {
      if (!this._isContainDirtyFlags(TransformFlag.WmWs)) {
        this._worldAssociatedChange(TransformFlag.WmWs);
        if (this._owner instanceof LiteCollider) {
          var shapes = this._owner._shapes;
          for (var i = 0, n = shapes.length; i < n; i++) {
            shapes[i]._transform._updateWorldScaleFlag();
          }
        }
      }
    };
    _proto._updateAllWorldFlag = function _updateAllWorldFlag() {
      if (!this._isContainDirtyFlags(TransformFlag.WmWpWeWqWs)) {
        this._worldAssociatedChange(TransformFlag.WmWpWeWqWs);
        if (this._owner instanceof LiteCollider) {
          var shapes = this._owner._shapes;
          for (var i = 0, n = shapes.length; i < n; i++) {
            shapes[i]._transform._updateAllWorldFlag();
          }
        }
      }
    };
    _proto._getParentTransform = function _getParentTransform() {
      if (!this._isParentDirty) {
        return this._parentTransformCache;
      }
      var parentCache = null;
      if (this._owner instanceof LiteColliderShape) {
        var parent = this._owner._collider;
        parentCache = parent._transform;
      }
      this._parentTransformCache = parentCache;
      this._isParentDirty = false;
      return parentCache;
    };
    _proto._isContainDirtyFlags = function _isContainDirtyFlags(targetDirtyFlags) {
      return (this._dirtyFlag & targetDirtyFlags) === targetDirtyFlags;
    };
    _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
      return (this._dirtyFlag & type) != 0;
    };
    _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
      this._dirtyFlag |= type;
    };
    _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
      this._dirtyFlag &= ~type;
    };
    _proto._worldAssociatedChange = function _worldAssociatedChange(type) {
      this._dirtyFlag |= type;
      this._updateFlagManager.distribute();
    };
    _createClass(LiteTransform2, [{
      key: "owner",
      set: function set(value) {
        this._owner = value;
      }
    }, {
      key: "position",
      get: function get() {
        return this._position;
      },
      set: function set(value) {
        if (this._position !== value) {
          this._position.copyFrom(value);
        }
        this._setDirtyFlagTrue(TransformFlag.LocalMatrix);
        this._updateWorldPositionFlag();
      }
    }, {
      key: "rotationQuaternion",
      get: function get() {
        if (this._isContainDirtyFlag(TransformFlag.LocalQuat)) {
          miniprogram$a.Quaternion.rotationEuler(miniprogram$a.MathUtil.degreeToRadian(this._rotation.x), miniprogram$a.MathUtil.degreeToRadian(this._rotation.y), miniprogram$a.MathUtil.degreeToRadian(this._rotation.z), this._rotationQuaternion);
          this._setDirtyFlagFalse(TransformFlag.LocalQuat);
        }
        return this._rotationQuaternion;
      },
      set: function set(value) {
        if (this._rotationQuaternion !== value) {
          this._rotationQuaternion.copyFrom(value);
        }
        this._setDirtyFlagTrue(TransformFlag.LocalMatrix | TransformFlag.LocalEuler);
        this._setDirtyFlagFalse(TransformFlag.LocalQuat);
        this._updateWorldRotationFlag();
      }
    }, {
      key: "worldRotationQuaternion",
      get: function get() {
        if (this._isContainDirtyFlag(TransformFlag.WorldQuat)) {
          var parent = this._getParentTransform();
          if (parent != null) {
            miniprogram$a.Quaternion.multiply(parent.worldRotationQuaternion, this.rotationQuaternion, this._worldRotationQuaternion);
          } else {
            this._worldRotationQuaternion.copyFrom(this.rotationQuaternion);
          }
          this._setDirtyFlagFalse(TransformFlag.WorldQuat);
        }
        return this._worldRotationQuaternion;
      },
      set: function set(value) {
        if (this._worldRotationQuaternion !== value) {
          this._worldRotationQuaternion.copyFrom(value);
        }
        var parent = this._getParentTransform();
        if (parent) {
          miniprogram$a.Quaternion.invert(parent.worldRotationQuaternion, LiteTransform2._tempQuat0);
          miniprogram$a.Quaternion.multiply(value, LiteTransform2._tempQuat0, this._rotationQuaternion);
        } else {
          this._rotationQuaternion.copyFrom(value);
        }
        this.rotationQuaternion = this._rotationQuaternion;
        this._setDirtyFlagFalse(TransformFlag.WorldQuat);
      }
    }, {
      key: "scale",
      get: function get() {
        return this._scale;
      },
      set: function set(value) {
        if (this._scale !== value) {
          this._scale.copyFrom(value);
        }
        this._setDirtyFlagTrue(TransformFlag.LocalMatrix);
        this._updateWorldScaleFlag();
      }
    }, {
      key: "localMatrix",
      get: function get() {
        if (this._isContainDirtyFlag(TransformFlag.LocalMatrix)) {
          miniprogram$a.Matrix.affineTransformation(this._scale, this.rotationQuaternion, this._position, this._localMatrix);
          this._setDirtyFlagFalse(TransformFlag.LocalMatrix);
        }
        return this._localMatrix;
      },
      set: function set(value) {
        if (this._localMatrix !== value) {
          this._localMatrix.copyFrom(value);
        }
        this._localMatrix.decompose(this._position, this._rotationQuaternion, this._scale);
        this._setDirtyFlagTrue(TransformFlag.LocalEuler);
        this._setDirtyFlagFalse(TransformFlag.LocalMatrix);
        this._updateAllWorldFlag();
      }
    }, {
      key: "worldMatrix",
      get: function get() {
        if (this._isContainDirtyFlag(TransformFlag.WorldMatrix)) {
          var parent = this._getParentTransform();
          if (parent) {
            miniprogram$a.Matrix.multiply(parent.worldMatrix, this.localMatrix, this._worldMatrix);
          } else {
            this._worldMatrix.copyFrom(this.localMatrix);
          }
          this._setDirtyFlagFalse(TransformFlag.WorldMatrix);
        }
        return this._worldMatrix;
      },
      set: function set(value) {
        if (this._worldMatrix !== value) {
          this._worldMatrix.copyFrom(value);
        }
        var parent = this._getParentTransform();
        if (parent) {
          miniprogram$a.Matrix.invert(parent.worldMatrix, LiteTransform2._tempMat42);
          miniprogram$a.Matrix.multiply(LiteTransform2._tempMat42, value, this._localMatrix);
        } else {
          this._localMatrix.copyFrom(value);
        }
        this.localMatrix = this._localMatrix;
        this._setDirtyFlagFalse(TransformFlag.WorldMatrix);
      }
    }]);
    return LiteTransform2;
  }();
  LiteTransform._tempQuat0 = new miniprogram$a.Quaternion();
  LiteTransform._tempMat42 = new miniprogram$a.Matrix();
  var TransformFlag;
  (function(TransformFlag2) {
    TransformFlag2[TransformFlag2["LocalEuler"] = 1] = "LocalEuler";
    TransformFlag2[TransformFlag2["LocalQuat"] = 2] = "LocalQuat";
    TransformFlag2[TransformFlag2["WorldPosition"] = 4] = "WorldPosition";
    TransformFlag2[TransformFlag2["WorldEuler"] = 8] = "WorldEuler";
    TransformFlag2[TransformFlag2["WorldQuat"] = 16] = "WorldQuat";
    TransformFlag2[TransformFlag2["WorldScale"] = 32] = "WorldScale";
    TransformFlag2[TransformFlag2["LocalMatrix"] = 64] = "LocalMatrix";
    TransformFlag2[TransformFlag2["WorldMatrix"] = 128] = "WorldMatrix";
    TransformFlag2[TransformFlag2["WmWp"] = 132] = "WmWp";
    TransformFlag2[TransformFlag2["WmWeWq"] = 152] = "WmWeWq";
    TransformFlag2[TransformFlag2["WmWpWeWq"] = 156] = "WmWpWeWq";
    TransformFlag2[TransformFlag2["WmWs"] = 160] = "WmWs";
    TransformFlag2[TransformFlag2["WmWpWs"] = 164] = "WmWpWs";
    TransformFlag2[TransformFlag2["WmWpWeWqWs"] = 188] = "WmWpWeWqWs";
  })(TransformFlag || (TransformFlag = {}));
  var LiteCollider = /* @__PURE__ */ function() {
    function LiteCollider2() {
      this._shapes = [];
      this._transform = new LiteTransform();
      this._transform.owner = this;
    }
    var _proto = LiteCollider2.prototype;
    _proto.addShape = function addShape(shape) {
      var oldCollider = shape._collider;
      if (oldCollider !== this) {
        if (oldCollider) {
          oldCollider.removeShape(shape);
        }
        this._shapes.push(shape);
        shape._collider = this;
      }
    };
    _proto.removeShape = function removeShape(shape) {
      var index = this._shapes.indexOf(shape);
      if (index !== -1) {
        this._shapes.splice(index, 1);
        shape._collider = null;
      }
    };
    _proto.setWorldTransform = function setWorldTransform(position, rotation) {
      this._transform.setPosition(position.x, position.y, position.z);
      this._transform.setRotationQuaternion(rotation.x, rotation.y, rotation.z, rotation.w);
    };
    _proto.getWorldTransform = function getWorldTransform(outPosition, outRotation) {
      var _this$_transform = this._transform, position = _this$_transform.position, rotationQuaternion = _this$_transform.rotationQuaternion;
      outPosition.set(position.x, position.y, position.z);
      outRotation.set(rotationQuaternion.x, rotationQuaternion.y, rotationQuaternion.z, rotationQuaternion.w);
    };
    _proto.destroy = function destroy() {
    };
    _proto._raycast = function _raycast(ray, hit) {
      hit.distance = Number.MAX_VALUE;
      var shapes = this._shapes;
      for (var i = 0, n = shapes.length; i < n; i++) {
        shapes[i]._raycast(ray, hit);
      }
      return hit.distance != Number.MAX_VALUE;
    };
    return LiteCollider2;
  }();
  var LiteDynamicCollider = /* @__PURE__ */ function(_LiteCollider) {
    _inheritsLoose(LiteDynamicCollider2, _LiteCollider);
    function LiteDynamicCollider2(position, rotation) {
      var _this;
      _this = _LiteCollider.call(this) || this;
      _this._transform.setPosition(position.x, position.y, position.z);
      _this._transform.setRotationQuaternion(rotation.x, rotation.y, rotation.z, rotation.w);
      return _this;
    }
    var _proto = LiteDynamicCollider2.prototype;
    _proto.addForce = function addForce(force) {
      throw "Physics-lite don't support addForce. Use Physics-PhysX instead!";
    };
    _proto.addTorque = function addTorque(torque) {
      throw "Physics-lite don't support addTorque. Use Physics-PhysX instead!";
    };
    _proto.move = function move(positionOrRotation, rotation) {
      throw "Physics-lite don't support move. Use Physics-PhysX instead!";
    };
    _proto.sleep = function sleep() {
      throw "Physics-lite don't support putToSleep. Use Physics-PhysX instead!";
    };
    _proto.setAngularDamping = function setAngularDamping(value) {
      throw "Physics-lite don't support setAngularDamping. Use Physics-PhysX instead!";
    };
    _proto.setAngularVelocity = function setAngularVelocity(value) {
      throw "Physics-lite don't support setAngularVelocity. Use Physics-PhysX instead!";
    };
    _proto.setCenterOfMass = function setCenterOfMass(value) {
      throw "Physics-lite don't support setCenterOfMass. Use Physics-PhysX instead!";
    };
    _proto.setCollisionDetectionMode = function setCollisionDetectionMode(value) {
      throw "Physics-lite don't support setCollisionDetectionMode. Use Physics-PhysX instead!";
    };
    _proto.setConstraints = function setConstraints(flags) {
      throw "Physics-lite don't support setConstraints. Use Physics-PhysX instead!";
    };
    _proto.setInertiaTensor = function setInertiaTensor(value) {
      throw "Physics-lite don't support setInertiaTensor. Use Physics-PhysX instead!";
    };
    _proto.setIsKinematic = function setIsKinematic(value) {
      throw "Physics-lite don't support setIsKinematic. Use Physics-PhysX instead!";
    };
    _proto.setLinearDamping = function setLinearDamping(value) {
      throw "Physics-lite don't support setLinearDamping. Use Physics-PhysX instead!";
    };
    _proto.setLinearVelocity = function setLinearVelocity(value) {
      throw "Physics-lite don't support setLinearVelocity. Use Physics-PhysX instead!";
    };
    _proto.setMass = function setMass(value) {
      throw "Physics-lite don't support setMass. Use Physics-PhysX instead!";
    };
    _proto.setMaxAngularVelocity = function setMaxAngularVelocity(value) {
      throw "Physics-lite don't support setMaxAngularVelocity. Use Physics-PhysX instead!";
    };
    _proto.setMaxDepenetrationVelocity = function setMaxDepenetrationVelocity(value) {
      throw "Physics-lite don't support setMaxDepenetrationVelocity. Use Physics-PhysX instead!";
    };
    _proto.setSleepThreshold = function setSleepThreshold(value) {
      throw "Physics-lite don't support setSleepThreshold. Use Physics-PhysX instead!";
    };
    _proto.setSolverIterations = function setSolverIterations(value) {
      throw "Physics-lite don't support setSolverIterations. Use Physics-PhysX instead!";
    };
    _proto.wakeUp = function wakeUp() {
      throw "Physics-lite don't support wakeUp. Use Physics-PhysX instead!";
    };
    return LiteDynamicCollider2;
  }(LiteCollider);
  var DisorderedArray = /* @__PURE__ */ function() {
    function DisorderedArray2(count) {
      if (count === void 0) {
        count = 0;
      }
      this._elements = void 0;
      this.length = 0;
      this._elements = new Array(count);
    }
    var _proto = DisorderedArray2.prototype;
    _proto.add = function add(element) {
      if (this.length === this._elements.length)
        this._elements.push(element);
      else
        this._elements[this.length] = element;
      this.length++;
    };
    _proto.delete = function _delete(element) {
      var index = this._elements.indexOf(element);
      this.deleteByIndex(index);
    };
    _proto.get = function get(index) {
      if (index >= this.length) {
        throw "Index is out of range.";
      }
      return this._elements[index];
    };
    _proto.deleteByIndex = function deleteByIndex(index) {
      var elements = this._elements;
      var end = null;
      var lastIndex = this.length - 1;
      if (index !== lastIndex) {
        end = elements[lastIndex];
        elements[index] = end;
      }
      this.length--;
      return end;
    };
    _proto.garbageCollection = function garbageCollection() {
      this._elements.length = this.length;
    };
    return DisorderedArray2;
  }();
  var LiteHitResult = function LiteHitResult2() {
    this.shapeID = -1;
    this.distance = 0;
    this.point = new miniprogram$a.Vector3();
    this.normal = new miniprogram$a.Vector3();
  };
  var LiteBoxColliderShape = /* @__PURE__ */ function(_LiteColliderShape) {
    _inheritsLoose(LiteBoxColliderShape2, _LiteColliderShape);
    function LiteBoxColliderShape2(uniqueID, size, material) {
      var _this;
      _this = _LiteColliderShape.call(this) || this;
      _this._halfSize = new miniprogram$a.Vector3();
      _this._scale = new miniprogram$a.Vector3(1, 1, 1);
      _this._boxMin = new miniprogram$a.Vector3(-0.5, -0.5, -0.5);
      _this._boxMax = new miniprogram$a.Vector3(0.5, 0.5, 0.5);
      _this._id = uniqueID;
      _this._halfSize.set(size.x * 0.5, size.y * 0.5, size.z * 0.5);
      _this._setBondingBox();
      return _this;
    }
    var _proto = LiteBoxColliderShape2.prototype;
    _proto.setPosition = function setPosition(position) {
      _LiteColliderShape.prototype.setPosition.call(this, position);
      this._setBondingBox();
    };
    _proto.setWorldScale = function setWorldScale(scale) {
      this._transform.position = this._transform.position.multiply(scale);
      this._scale.copyFrom(scale);
    };
    _proto.setSize = function setSize(value) {
      this._halfSize.set(value.x * 0.5, value.y * 0.5, value.z * 0.5);
      this._setBondingBox();
    };
    _proto._raycast = function _raycast(ray, hit) {
      var localRay = this._getLocalRay(ray);
      var boundingBox = LiteBoxColliderShape2._tempBox;
      boundingBox.min.set(-this._halfSize.x * this._scale.x, -this._halfSize.y * this._scale.y, -this._halfSize.z * this._scale.z);
      boundingBox.max.set(this._halfSize.x * this._scale.x, this._halfSize.y * this._scale.y, this._halfSize.z * this._scale.z);
      var rayDistance = localRay.intersectBox(boundingBox);
      if (rayDistance !== -1) {
        this._updateHitResult(localRay, rayDistance, hit, ray.origin);
        return true;
      } else {
        return false;
      }
    };
    _proto._setBondingBox = function _setBondingBox() {
      var center = this._transform.position;
      var halfSize = this._halfSize;
      miniprogram$a.Vector3.add(center, halfSize, this._boxMax);
      miniprogram$a.Vector3.subtract(center, halfSize, this._boxMin);
    };
    return LiteBoxColliderShape2;
  }(LiteColliderShape);
  LiteBoxColliderShape._tempBox = new miniprogram$a.BoundingBox();
  var LiteSphereColliderShape = /* @__PURE__ */ function(_LiteColliderShape) {
    _inheritsLoose(LiteSphereColliderShape2, _LiteColliderShape);
    function LiteSphereColliderShape2(uniqueID, radius, material) {
      var _this;
      _this = _LiteColliderShape.call(this) || this;
      _this._radius = 1;
      _this._maxScale = 1;
      _this._radius = radius;
      _this._id = uniqueID;
      return _this;
    }
    var _proto = LiteSphereColliderShape2.prototype;
    _proto.setRadius = function setRadius(value) {
      this._radius = value;
    };
    _proto.setWorldScale = function setWorldScale(scale) {
      this._maxScale = Math.max(scale.x, Math.max(scale.x, scale.y));
    };
    _proto._raycast = function _raycast(ray, hit) {
      var boundingSphere = LiteSphereColliderShape2._tempSphere;
      miniprogram$a.Vector3.transformCoordinate(this._transform.position, this._collider._transform.worldMatrix, boundingSphere.center);
      boundingSphere.radius = this.worldRadius;
      var rayDistance = ray.intersectSphere(boundingSphere);
      if (rayDistance !== -1) {
        this._updateHitResult(ray, rayDistance, hit, ray.origin, true);
        return true;
      } else {
        return false;
      }
    };
    _createClass(LiteSphereColliderShape2, [{
      key: "worldRadius",
      get: function get() {
        return this._radius * this._maxScale;
      }
    }]);
    return LiteSphereColliderShape2;
  }(LiteColliderShape);
  LiteSphereColliderShape._tempSphere = new miniprogram$a.BoundingSphere();
  var LitePhysicsManager = /* @__PURE__ */ function() {
    function LitePhysicsManager2(onContactEnter, onContactExit, onContactStay, onTriggerEnter, onTriggerExit, onTriggerStay) {
      this._onContactEnter = void 0;
      this._onContactExit = void 0;
      this._onContactStay = void 0;
      this._onTriggerEnter = void 0;
      this._onTriggerExit = void 0;
      this._onTriggerStay = void 0;
      this._colliders = [];
      this._sphere = new miniprogram$a.BoundingSphere();
      this._box = new miniprogram$a.BoundingBox();
      this._currentEvents = new DisorderedArray();
      this._eventMap = {};
      this._eventPool = [];
      this._onContactEnter = onContactEnter;
      this._onContactExit = onContactExit;
      this._onContactStay = onContactStay;
      this._onTriggerEnter = onTriggerEnter;
      this._onTriggerExit = onTriggerExit;
      this._onTriggerStay = onTriggerStay;
    }
    var _proto = LitePhysicsManager2.prototype;
    _proto.setGravity = function setGravity(value) {
      console.log("Physics-lite don't support gravity. Use Physics-PhysX instead!");
    };
    _proto.addColliderShape = function addColliderShape(colliderShape) {
      this._eventMap[colliderShape._id] = {};
    };
    _proto.removeColliderShape = function removeColliderShape(colliderShape) {
      var eventPool = this._eventPool, currentEvents = this._currentEvents;
      var shapeID = colliderShape._id;
      for (var i = currentEvents.length - 1; i >= 0; i--) {
        var event = currentEvents.get(i);
        if (event.index1 == shapeID || event.index2 == shapeID) {
          currentEvents.deleteByIndex(i);
          eventPool.push(event);
        }
      }
      delete this._eventMap[shapeID];
    };
    _proto.addCollider = function addCollider(actor) {
      this._colliders.push(actor);
    };
    _proto.removeCollider = function removeCollider(collider) {
      var index = this._colliders.indexOf(collider);
      if (index !== -1) {
        this._colliders.splice(index, 1);
      }
    };
    _proto.update = function update(deltaTime) {
      var colliders = this._colliders;
      for (var i = 0, len = colliders.length; i < len; i++) {
        this._collisionDetection(deltaTime, colliders[i]);
      }
      this._fireEvent();
    };
    _proto.raycast = function raycast(ray, distance, hit) {
      var colliders = this._colliders;
      var hitResult;
      if (hit) {
        hitResult = LitePhysicsManager2._hitResult;
      }
      var isHit = false;
      var curHit = LitePhysicsManager2._currentHit;
      for (var i = 0, len = colliders.length; i < len; i++) {
        var collider = colliders[i];
        if (collider._raycast(ray, curHit)) {
          isHit = true;
          if (curHit.distance < distance) {
            if (hitResult) {
              hitResult.normal.copyFrom(curHit.normal);
              hitResult.point.copyFrom(curHit.point);
              hitResult.distance = curHit.distance;
              hitResult.shapeID = curHit.shapeID;
            } else {
              return true;
            }
            distance = curHit.distance;
          }
        }
      }
      if (!isHit && hitResult) {
        hitResult.shapeID = -1;
        hitResult.distance = 0;
        hitResult.point.set(0, 0, 0);
        hitResult.normal.set(0, 0, 0);
      } else if (isHit && hitResult) {
        hit(hitResult.shapeID, hitResult.distance, hitResult.point, hitResult.normal);
      }
      return isHit;
    };
    _proto.addCharacterController = function addCharacterController(characterController) {
      throw "Physics-lite don't support addCharacterController. Use Physics-PhysX instead!";
    };
    _proto.removeCharacterController = function removeCharacterController(characterController) {
      throw "Physics-lite don't support removeCharacterController. Use Physics-PhysX instead!";
    };
    LitePhysicsManager2._updateWorldBox = function _updateWorldBox(boxCollider, out) {
      var mat = boxCollider._transform.worldMatrix;
      out.min.copyFrom(boxCollider._boxMin);
      out.max.copyFrom(boxCollider._boxMax);
      miniprogram$a.BoundingBox.transform(out, mat, out);
    };
    LitePhysicsManager2._upWorldSphere = function _upWorldSphere(sphereCollider, out) {
      miniprogram$a.Vector3.transformCoordinate(sphereCollider._transform.position, sphereCollider._transform.worldMatrix, out.center);
      out.radius = sphereCollider.worldRadius;
    };
    _proto._getTrigger = function _getTrigger(index1, index2) {
      var event;
      if (this._eventPool.length) {
        event = this._eventPool.pop();
        event.index1 = index1;
        event.index2 = index2;
      } else {
        event = new TriggerEvent(index1, index2);
      }
      this._eventMap[index1][index2] = event;
      return event;
    };
    _proto._collisionDetection = function _collisionDetection(deltaTime, myCollider) {
      var colliders = this._colliders;
      var myColliderShapes = myCollider._shapes;
      for (var i = 0, len = myColliderShapes.length; i < len; i++) {
        var myShape = myColliderShapes[i];
        if (myShape instanceof LiteBoxColliderShape) {
          LitePhysicsManager2._updateWorldBox(myShape, this._box);
          for (var j = 0, _len = colliders.length; j < _len; j++) {
            var colliderShape = colliders[j]._shapes;
            for (var k = 0, _len2 = colliderShape.length; k < _len2; k++) {
              var shape = colliderShape[k];
              var index1 = shape._id;
              var index2 = myShape._id;
              var event = index1 < index2 ? this._eventMap[index1][index2] : this._eventMap[index2][index1];
              if (event !== void 0 && !event.alreadyInvoked) {
                continue;
              }
              if (shape != myShape && this._boxCollision(shape)) {
                if (event === void 0) {
                  var _event = index1 < index2 ? this._getTrigger(index1, index2) : this._getTrigger(index2, index1);
                  _event.state = TriggerEventState.Enter;
                  _event.alreadyInvoked = false;
                  this._currentEvents.add(_event);
                } else if (event.state === TriggerEventState.Enter) {
                  event.state = TriggerEventState.Stay;
                  event.alreadyInvoked = false;
                } else if (event.state === TriggerEventState.Stay) {
                  event.alreadyInvoked = false;
                }
              }
            }
          }
        } else if (myShape instanceof LiteSphereColliderShape) {
          LitePhysicsManager2._upWorldSphere(myShape, this._sphere);
          for (var _j = 0, _len3 = colliders.length; _j < _len3; _j++) {
            var _colliderShape = colliders[_j]._shapes;
            for (var _k = 0, _len4 = _colliderShape.length; _k < _len4; _k++) {
              var _shape = _colliderShape[_k];
              var _index = _shape._id;
              var _index2 = myShape._id;
              var _event2 = _index < _index2 ? this._eventMap[_index][_index2] : this._eventMap[_index2][_index];
              if (_event2 !== void 0 && !_event2.alreadyInvoked) {
                continue;
              }
              if (_shape != myShape && this._sphereCollision(_shape)) {
                if (_event2 === void 0) {
                  var _event3 = _index < _index2 ? this._getTrigger(_index, _index2) : this._getTrigger(_index2, _index);
                  _event3.state = TriggerEventState.Enter;
                  _event3.alreadyInvoked = false;
                  this._currentEvents.add(_event3);
                } else if (_event2.state === TriggerEventState.Enter) {
                  _event2.state = TriggerEventState.Stay;
                  _event2.alreadyInvoked = false;
                } else if (_event2.state === TriggerEventState.Stay) {
                  _event2.alreadyInvoked = false;
                }
              }
            }
          }
        }
      }
    };
    _proto._fireEvent = function _fireEvent() {
      var eventPool = this._eventPool, currentEvents = this._currentEvents;
      for (var i = currentEvents.length - 1; i >= 0; i--) {
        var event = currentEvents.get(i);
        if (!event.alreadyInvoked) {
          if (event.state == TriggerEventState.Enter) {
            this._onTriggerEnter(event.index1, event.index2);
            event.alreadyInvoked = true;
          } else if (event.state == TriggerEventState.Stay) {
            this._onTriggerStay(event.index1, event.index2);
            event.alreadyInvoked = true;
          }
        } else {
          event.state = TriggerEventState.Exit;
          this._eventMap[event.index1][event.index2] = void 0;
          this._onTriggerExit(event.index1, event.index2);
          currentEvents.deleteByIndex(i);
          eventPool.push(event);
        }
      }
    };
    _proto._boxCollision = function _boxCollision(other) {
      if (other instanceof LiteBoxColliderShape) {
        var box = LitePhysicsManager2._tempBox;
        LitePhysicsManager2._updateWorldBox(other, box);
        return miniprogram$a.CollisionUtil.intersectsBoxAndBox(box, this._box);
      } else if (other instanceof LiteSphereColliderShape) {
        var sphere = LitePhysicsManager2._tempSphere;
        LitePhysicsManager2._upWorldSphere(other, sphere);
        return miniprogram$a.CollisionUtil.intersectsSphereAndBox(sphere, this._box);
      }
      return false;
    };
    _proto._sphereCollision = function _sphereCollision(other) {
      if (other instanceof LiteBoxColliderShape) {
        var box = LitePhysicsManager2._tempBox;
        LitePhysicsManager2._updateWorldBox(other, box);
        return miniprogram$a.CollisionUtil.intersectsSphereAndBox(this._sphere, box);
      } else if (other instanceof LiteSphereColliderShape) {
        var sphere = LitePhysicsManager2._tempSphere;
        LitePhysicsManager2._upWorldSphere(other, sphere);
        return miniprogram$a.CollisionUtil.intersectsSphereAndSphere(sphere, this._sphere);
      }
      return false;
    };
    return LitePhysicsManager2;
  }();
  LitePhysicsManager._tempSphere = new miniprogram$a.BoundingSphere();
  LitePhysicsManager._tempBox = new miniprogram$a.BoundingBox();
  LitePhysicsManager._currentHit = new LiteHitResult();
  LitePhysicsManager._hitResult = new LiteHitResult();
  var TriggerEventState;
  (function(TriggerEventState2) {
    TriggerEventState2[TriggerEventState2["Enter"] = 0] = "Enter";
    TriggerEventState2[TriggerEventState2["Stay"] = 1] = "Stay";
    TriggerEventState2[TriggerEventState2["Exit"] = 2] = "Exit";
  })(TriggerEventState || (TriggerEventState = {}));
  var TriggerEvent = function TriggerEvent2(index1, index2) {
    this.state = void 0;
    this.index1 = void 0;
    this.index2 = void 0;
    this.alreadyInvoked = false;
    this.index1 = index1;
    this.index2 = index2;
  };
  var LitePhysicsMaterial = /* @__PURE__ */ function() {
    function LitePhysicsMaterial2(staticFriction, dynamicFriction, bounciness, frictionCombine, bounceCombine) {
    }
    var _proto = LitePhysicsMaterial2.prototype;
    _proto.setBounciness = function setBounciness(value) {
      throw "Physics-lite don't support physics material. Use Physics-PhysX instead!";
    };
    _proto.setDynamicFriction = function setDynamicFriction(value) {
      throw "Physics-lite don't support physics material. Use Physics-PhysX instead!";
    };
    _proto.setStaticFriction = function setStaticFriction(value) {
      throw "Physics-lite don't support physics material. Use Physics-PhysX instead!";
    };
    _proto.setBounceCombine = function setBounceCombine(value) {
      throw "Physics-lite don't support physics material. Use Physics-PhysX instead!";
    };
    _proto.setFrictionCombine = function setFrictionCombine(value) {
      throw "Physics-lite don't support physics material. Use Physics-PhysX instead!";
    };
    _proto.destroy = function destroy() {
    };
    return LitePhysicsMaterial2;
  }();
  var LiteStaticCollider = /* @__PURE__ */ function(_LiteCollider) {
    _inheritsLoose(LiteStaticCollider2, _LiteCollider);
    function LiteStaticCollider2(position, rotation) {
      var _this;
      _this = _LiteCollider.call(this) || this;
      _this._transform.setPosition(position.x, position.y, position.z);
      _this._transform.setRotationQuaternion(rotation.x, rotation.y, rotation.z, rotation.w);
      return _this;
    }
    return LiteStaticCollider2;
  }(LiteCollider);
  function StaticInterfaceImplement() {
    return function(constructor) {
    };
  }
  var _dec, _class;
  var LitePhysics = (_dec = StaticInterfaceImplement(), _dec(_class = /* @__PURE__ */ function() {
    function LitePhysics2() {
    }
    LitePhysics2.createPhysicsManager = function createPhysicsManager(onContactBegin, onContactEnd, onContactPersist, onTriggerBegin, onTriggerEnd, onTriggerPersist) {
      return new LitePhysicsManager(onContactBegin, onContactEnd, onContactPersist, onTriggerBegin, onTriggerEnd, onTriggerPersist);
    };
    LitePhysics2.createStaticCollider = function createStaticCollider(position, rotation) {
      return new LiteStaticCollider(position, rotation);
    };
    LitePhysics2.createDynamicCollider = function createDynamicCollider(position, rotation) {
      return new LiteDynamicCollider(position, rotation);
    };
    LitePhysics2.createCharacterController = function createCharacterController() {
      throw "Physics-lite don't support createCharacterController. Use Physics-PhysX instead!";
    };
    LitePhysics2.createPhysicsMaterial = function createPhysicsMaterial(staticFriction, dynamicFriction, bounciness, frictionCombine, bounceCombine) {
      return new LitePhysicsMaterial(staticFriction, dynamicFriction, bounciness, frictionCombine, bounceCombine);
    };
    LitePhysics2.createBoxColliderShape = function createBoxColliderShape(uniqueID, size, material) {
      return new LiteBoxColliderShape(uniqueID, size, material);
    };
    LitePhysics2.createSphereColliderShape = function createSphereColliderShape(uniqueID, radius, material) {
      return new LiteSphereColliderShape(uniqueID, radius, material);
    };
    LitePhysics2.createPlaneColliderShape = function createPlaneColliderShape(uniqueID, material) {
      throw "Physics-lite don't support PlaneColliderShape. Use Physics-PhysX instead!";
    };
    LitePhysics2.createCapsuleColliderShape = function createCapsuleColliderShape(uniqueID, radius, height, material) {
      throw "Physics-lite don't support CapsuleColliderShape. Use Physics-PhysX instead!";
    };
    LitePhysics2.createFixedJoint = function createFixedJoint(collider) {
      throw "Physics-lite don't support CapsuleColliderShape. Use Physics-PhysX instead!";
    };
    LitePhysics2.createHingeJoint = function createHingeJoint(collider) {
      throw "Physics-lite don't support CapsuleColliderShape. Use Physics-PhysX instead!";
    };
    LitePhysics2.createSpringJoint = function createSpringJoint(collider) {
      throw "Physics-lite don't support CapsuleColliderShape. Use Physics-PhysX instead!";
    };
    return LitePhysics2;
  }()) || _class);
  var GameState = /* @__PURE__ */ ((GameState2) => {
    GameState2[GameState2["NotInit"] = 0] = "NotInit";
    GameState2[GameState2["InitEngine"] = 1] = "InitEngine";
    GameState2[GameState2["InitScene"] = 2] = "InitScene";
    GameState2[GameState2["Start"] = 3] = "Start";
    return GameState2;
  })(GameState || {});
  const _GameCtrl = class {
    constructor() {
      __publicField(this, "_engine");
      __publicField(this, "_scene");
      __publicField(this, "_root");
      __publicField(this, "_state", 0);
      __publicField(this, "_tempVec30", new miniprogram$a.Vector3());
      __publicField(this, "_tempVec31", new miniprogram$a.Vector3());
    }
    static get ins() {
      if (!this._ins) {
        this._ins = new _GameCtrl();
      }
      return this._ins;
    }
    jump(state, ...arg) {
      if (this._state !== state) {
        switch (state) {
          case 1:
            this.initEngine();
            this.jump(2);
            break;
          case 2:
            this.initScene();
            this.jump(3);
            break;
        }
      }
    }
    initEngine() {
      const canvas = MiniAdapter.canvas;
      const engine = this._engine = new miniprogram$a.WebGLEngine(canvas);
      engine.physicsManager.initialize(LitePhysics);
      this._scene = engine.sceneManager.activeScene;
      this._root = this._scene.createRootEntity();
      engine.run();
    }
    initScene() {
      const { _root: root, _engine: engine } = this;
      const cameraEntity = root.createChild("Camera");
      cameraEntity.addComponent(miniprogram$a.Camera);
      const control = cameraEntity.addComponent(OrbitControl);
      control.minPolarAngle = 1 / 180 * Math.PI;
      control.maxPolarAngle = 179 / 180 * Math.PI;
      cameraEntity.transform.setPosition(0, 0, 5);
      const lightEntity = root.createChild("light");
      lightEntity.addComponent(miniprogram$a.DirectLight);
      lightEntity.transform.setPosition(5, 5, 5);
      lightEntity.transform.setRotation(-30, 20, 0);
      const boxEntity = root.createChild("Box");
      const boxRenderer = boxEntity.addComponent(miniprogram$a.MeshRenderer);
      boxRenderer.mesh = miniprogram$a.PrimitiveMesh.createCuboid(engine, 1, 1, 1);
      const boxMaterial = new miniprogram$a.BlinnPhongMaterial(engine);
      boxMaterial.baseColor = new miniprogram$a.Color(0.3, 0.3, 0.3, 1);
      boxRenderer.setMaterial(boxMaterial);
      this._addBoundingBox(boxRenderer);
      const textEntity = root.createChild("text");
      textEntity.transform.setPosition(0, 1.5, 0);
      const textRenderer = textEntity.addComponent(miniprogram$a.TextRenderer);
      textRenderer.fontSize = 30;
      textRenderer.text = "\u70B9\u51FB\u65B9\u5757\u4F1A\u5F39\u51FA toast !";
    }
    _addBoundingBox(renderer) {
      const { _tempVec30: localSize, _tempVec31: localPosition } = this;
      const boundingBox = renderer.mesh.bounds;
      const entity = renderer.entity;
      boundingBox.getCenter(localPosition);
      miniprogram$a.Vector3.subtract(boundingBox.max, boundingBox.min, localSize);
      const boxCollider = entity.addComponent(miniprogram$a.StaticCollider);
      const boxColliderShape = new miniprogram$a.BoxColliderShape();
      boxColliderShape.setPosition(
        localPosition.x,
        localPosition.y,
        localPosition.z
      );
      boxColliderShape.setSize(localSize.x, localSize.y, localSize.z);
      boxCollider.addShape(boxColliderShape);
      entity.addComponent(miniprogram$a.Script).onPointerClick = () => {
        MiniAdapter.toast("Click:" + entity.name);
      };
    }
  };
  let GameCtrl = _GameCtrl;
  __publicField(GameCtrl, "_ins");
  function start(canvas) {
    miniprogram$a.Logger.enable();
    MiniAdapter.init(canvas);
    GameCtrl.ins.jump(GameState.InitEngine);
  }
  exports2.start = start;
  Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
});
